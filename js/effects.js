/*! For license information please see main.js.LICENSE */
!(function (t) {
  var e = {};
  function n(r) {
    if (e[r]) return e[r].exports;
    var i = (e[r] = { i: r, l: !1, exports: {} });
    return t[r].call(i.exports, i, i.exports, n), (i.l = !0), i.exports;
  }
  (n.m = t),
    (n.c = e),
    (n.d = function (t, e, r) {
      n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: r });
    }),
    (n.r = function (t) {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(t, "__esModule", { value: !0 });
    }),
    (n.t = function (t, e) {
      if ((1 & e && (t = n(t)), 8 & e)) return t;
      if (4 & e && "object" == typeof t && t && t.__esModule) return t;
      var r = Object.create(null);
      if (
        (n.r(r),
        Object.defineProperty(r, "default", { enumerable: !0, value: t }),
        2 & e && "string" != typeof t)
      )
        for (var i in t)
          n.d(
            r,
            i,
            function (e) {
              return t[e];
            }.bind(null, i)
          );
      return r;
    }),
    (n.n = function (t) {
      var e =
        t && t.__esModule
          ? function () {
              return t.default;
            }
          : function () {
              return t;
            };
      return n.d(e, "a", e), e;
    }),
    (n.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }),
    (n.p = ""),
    n((n.s = 123));
})([
  function (t, e, n) {
    var r = n(1),
      i = n(7),
      o = n(14),
      a = n(11),
      s = n(17),
      c = function (t, e, n) {
        var u,
          l,
          h,
          p,
          f = t & c.F,
          d = t & c.G,
          m = t & c.S,
          v = t & c.P,
          g = t & c.B,
          y = d ? r : m ? r[e] || (r[e] = {}) : (r[e] || {}).prototype,
          x = d ? i : i[e] || (i[e] = {}),
          b = x.prototype || (x.prototype = {});
        for (u in (d && (n = e), n))
          (h = ((l = !f && y && void 0 !== y[u]) ? y : n)[u]),
            (p =
              g && l
                ? s(h, r)
                : v && "function" == typeof h
                ? s(Function.call, h)
                : h),
            y && a(y, u, h, t & c.U),
            x[u] != h && o(x, u, p),
            v && b[u] != h && (b[u] = h);
      };
    (r.core = i),
      (c.F = 1),
      (c.G = 2),
      (c.S = 4),
      (c.P = 8),
      (c.B = 16),
      (c.W = 32),
      (c.U = 64),
      (c.R = 128),
      (t.exports = c);
  },
  function (t, e) {
    var n = (t.exports =
      "undefined" != typeof window && window.Math == Math
        ? window
        : "undefined" != typeof self && self.Math == Math
        ? self
        : Function("return this")());
    "number" == typeof __g && (__g = n);
  },
  function (t, e) {
    t.exports = function (t) {
      try {
        return !!t();
      } catch (t) {
        return !0;
      }
    };
  },
  function (t, e, n) {
    var r = n(4);
    t.exports = function (t) {
      if (!r(t)) throw TypeError(t + " is not an object!");
      return t;
    };
  },
  function (t, e) {
    t.exports = function (t) {
      return "object" == typeof t ? null !== t : "function" == typeof t;
    };
  },
  function (t, e, n) {
    var r = n(48)("wks"),
      i = n(29),
      o = n(1).Symbol,
      a = "function" == typeof o;
    (t.exports = function (t) {
      return r[t] || (r[t] = (a && o[t]) || (a ? o : i)("Symbol." + t));
    }).store = r;
  },
  function (t, e, n) {
    var r = n(19),
      i = Math.min;
    t.exports = function (t) {
      return t > 0 ? i(r(t), 9007199254740991) : 0;
    };
  },
  function (t, e) {
    var n = (t.exports = { version: "2.6.9" });
    "number" == typeof __e && (__e = n);
  },
  function (t, e, n) {
    t.exports = !n(2)(function () {
      return (
        7 !=
        Object.defineProperty({}, "a", {
          get: function () {
            return 7;
          },
        }).a
      );
    });
  },
  function (t, e, n) {
    var r = n(3),
      i = n(89),
      o = n(26),
      a = Object.defineProperty;
    e.f = n(8)
      ? Object.defineProperty
      : function (t, e, n) {
          if ((r(t), (e = o(e, !0)), r(n), i))
            try {
              return a(t, e, n);
            } catch (t) {}
          if ("get" in n || "set" in n)
            throw TypeError("Accessors not supported!");
          return "value" in n && (t[e] = n.value), t;
        };
  },
  function (t, e, n) {
    var r = n(24);
    t.exports = function (t) {
      return Object(r(t));
    };
  },
  function (t, e, n) {
    var r = n(1),
      i = n(14),
      o = n(13),
      a = n(29)("src"),
      s = n(128),
      c = ("" + s).split("toString");
    (n(7).inspectSource = function (t) {
      return s.call(t);
    }),
      (t.exports = function (t, e, n, s) {
        var u = "function" == typeof n;
        u && (o(n, "name") || i(n, "name", e)),
          t[e] !== n &&
            (u && (o(n, a) || i(n, a, t[e] ? "" + t[e] : c.join(String(e)))),
            t === r
              ? (t[e] = n)
              : s
              ? t[e]
                ? (t[e] = n)
                : i(t, e, n)
              : (delete t[e], i(t, e, n)));
      })(Function.prototype, "toString", function () {
        return ("function" == typeof this && this[a]) || s.call(this);
      });
  },
  function (t, e, n) {
    var r = n(0),
      i = n(2),
      o = n(24),
      a = /"/g,
      s = function (t, e, n, r) {
        var i = String(o(t)),
          s = "<" + e;
        return (
          "" !== n &&
            (s += " " + n + '="' + String(r).replace(a, "&quot;") + '"'),
          s + ">" + i + "</" + e + ">"
        );
      };
    t.exports = function (t, e) {
      var n = {};
      (n[t] = e(s)),
        r(
          r.P +
            r.F *
              i(function () {
                var e = ""[t]('"');
                return e !== e.toLowerCase() || e.split('"').length > 3;
              }),
          "String",
          n
        );
    };
  },
  function (t, e) {
    var n = {}.hasOwnProperty;
    t.exports = function (t, e) {
      return n.call(t, e);
    };
  },
  function (t, e, n) {
    var r = n(9),
      i = n(28);
    t.exports = n(8)
      ? function (t, e, n) {
          return r.f(t, e, i(1, n));
        }
      : function (t, e, n) {
          return (t[e] = n), t;
        };
  },
  function (t, e, n) {
    var r = n(44),
      i = n(24);
    t.exports = function (t) {
      return r(i(t));
    };
  },
  function (t, e, n) {
    "use strict";
    var r = n(2);
    t.exports = function (t, e) {
      return (
        !!t &&
        r(function () {
          e ? t.call(null, function () {}, 1) : t.call(null);
        })
      );
    };
  },
  function (t, e, n) {
    var r = n(18);
    t.exports = function (t, e, n) {
      if ((r(t), void 0 === e)) return t;
      switch (n) {
        case 1:
          return function (n) {
            return t.call(e, n);
          };
        case 2:
          return function (n, r) {
            return t.call(e, n, r);
          };
        case 3:
          return function (n, r, i) {
            return t.call(e, n, r, i);
          };
      }
      return function () {
        return t.apply(e, arguments);
      };
    };
  },
  function (t, e) {
    t.exports = function (t) {
      if ("function" != typeof t) throw TypeError(t + " is not a function!");
      return t;
    };
  },
  function (t, e) {
    var n = Math.ceil,
      r = Math.floor;
    t.exports = function (t) {
      return isNaN((t = +t)) ? 0 : (t > 0 ? r : n)(t);
    };
  },
  function (t, e, n) {
    var r = n(45),
      i = n(28),
      o = n(15),
      a = n(26),
      s = n(13),
      c = n(89),
      u = Object.getOwnPropertyDescriptor;
    e.f = n(8)
      ? u
      : function (t, e) {
          if (((t = o(t)), (e = a(e, !0)), c))
            try {
              return u(t, e);
            } catch (t) {}
          if (s(t, e)) return i(!r.f.call(t, e), t[e]);
        };
  },
  function (t, e, n) {
    var r = n(0),
      i = n(7),
      o = n(2);
    t.exports = function (t, e) {
      var n = (i.Object || {})[t] || Object[t],
        a = {};
      (a[t] = e(n)),
        r(
          r.S +
            r.F *
              o(function () {
                n(1);
              }),
          "Object",
          a
        );
    };
  },
  function (t, e, n) {
    var r = n(17),
      i = n(44),
      o = n(10),
      a = n(6),
      s = n(105);
    t.exports = function (t, e) {
      var n = 1 == t,
        c = 2 == t,
        u = 3 == t,
        l = 4 == t,
        h = 6 == t,
        p = 5 == t || h,
        f = e || s;
      return function (e, s, d) {
        for (
          var m,
            v,
            g = o(e),
            y = i(g),
            x = r(s, d, 3),
            b = a(y.length),
            w = 0,
            _ = n ? f(e, b) : c ? f(e, 0) : void 0;
          b > w;
          w++
        )
          if ((p || w in y) && ((v = x((m = y[w]), w, g)), t))
            if (n) _[w] = v;
            else if (v)
              switch (t) {
                case 3:
                  return !0;
                case 5:
                  return m;
                case 6:
                  return w;
                case 2:
                  _.push(m);
              }
            else if (l) return !1;
        return h ? -1 : u || l ? l : _;
      };
    };
  },
  function (t, e) {
    var n = {}.toString;
    t.exports = function (t) {
      return n.call(t).slice(8, -1);
    };
  },
  function (t, e) {
    t.exports = function (t) {
      if (null == t) throw TypeError("Can't call method on  " + t);
      return t;
    };
  },
  function (t, e, n) {
    "use strict";
    if (n(8)) {
      var r = n(30),
        i = n(1),
        o = n(2),
        a = n(0),
        s = n(59),
        c = n(84),
        u = n(17),
        l = n(42),
        h = n(28),
        p = n(14),
        f = n(43),
        d = n(19),
        m = n(6),
        v = n(116),
        g = n(32),
        y = n(26),
        x = n(13),
        b = n(46),
        w = n(4),
        _ = n(10),
        M = n(76),
        S = n(33),
        E = n(35),
        T = n(34).f,
        A = n(78),
        L = n(29),
        P = n(5),
        R = n(22),
        C = n(49),
        O = n(47),
        I = n(80),
        N = n(40),
        D = n(52),
        z = n(41),
        F = n(79),
        U = n(107),
        B = n(9),
        G = n(20),
        j = B.f,
        V = G.f,
        H = i.RangeError,
        k = i.TypeError,
        W = i.Uint8Array,
        q = Array.prototype,
        X = c.ArrayBuffer,
        Y = c.DataView,
        J = R(0),
        Z = R(2),
        Q = R(3),
        K = R(4),
        $ = R(5),
        tt = R(6),
        et = C(!0),
        nt = C(!1),
        rt = I.values,
        it = I.keys,
        ot = I.entries,
        at = q.lastIndexOf,
        st = q.reduce,
        ct = q.reduceRight,
        ut = q.join,
        lt = q.sort,
        ht = q.slice,
        pt = q.toString,
        ft = q.toLocaleString,
        dt = P("iterator"),
        mt = P("toStringTag"),
        vt = L("typed_constructor"),
        gt = L("def_constructor"),
        yt = s.CONSTR,
        xt = s.TYPED,
        bt = s.VIEW,
        wt = R(1, function (t, e) {
          return Tt(O(t, t[gt]), e);
        }),
        _t = o(function () {
          return 1 === new W(new Uint16Array([1]).buffer)[0];
        }),
        Mt =
          !!W &&
          !!W.prototype.set &&
          o(function () {
            new W(1).set({});
          }),
        St = function (t, e) {
          var n = d(t);
          if (n < 0 || n % e) throw H("Wrong offset!");
          return n;
        },
        Et = function (t) {
          if (w(t) && xt in t) return t;
          throw k(t + " is not a typed array!");
        },
        Tt = function (t, e) {
          if (!(w(t) && vt in t))
            throw k("It is not a typed array constructor!");
          return new t(e);
        },
        At = function (t, e) {
          return Lt(O(t, t[gt]), e);
        },
        Lt = function (t, e) {
          for (var n = 0, r = e.length, i = Tt(t, r); r > n; ) i[n] = e[n++];
          return i;
        },
        Pt = function (t, e, n) {
          j(t, e, {
            get: function () {
              return this._d[n];
            },
          });
        },
        Rt = function (t) {
          var e,
            n,
            r,
            i,
            o,
            a,
            s = _(t),
            c = arguments.length,
            l = c > 1 ? arguments[1] : void 0,
            h = void 0 !== l,
            p = A(s);
          if (null != p && !M(p)) {
            for (a = p.call(s), r = [], e = 0; !(o = a.next()).done; e++)
              r.push(o.value);
            s = r;
          }
          for (
            h && c > 2 && (l = u(l, arguments[2], 2)),
              e = 0,
              n = m(s.length),
              i = Tt(this, n);
            n > e;
            e++
          )
            i[e] = h ? l(s[e], e) : s[e];
          return i;
        },
        Ct = function () {
          for (var t = 0, e = arguments.length, n = Tt(this, e); e > t; )
            n[t] = arguments[t++];
          return n;
        },
        Ot =
          !!W &&
          o(function () {
            ft.call(new W(1));
          }),
        It = function () {
          return ft.apply(Ot ? ht.call(Et(this)) : Et(this), arguments);
        },
        Nt = {
          copyWithin: function (t, e) {
            return U.call(
              Et(this),
              t,
              e,
              arguments.length > 2 ? arguments[2] : void 0
            );
          },
          every: function (t) {
            return K(Et(this), t, arguments.length > 1 ? arguments[1] : void 0);
          },
          fill: function (t) {
            return F.apply(Et(this), arguments);
          },
          filter: function (t) {
            return At(
              this,
              Z(Et(this), t, arguments.length > 1 ? arguments[1] : void 0)
            );
          },
          find: function (t) {
            return $(Et(this), t, arguments.length > 1 ? arguments[1] : void 0);
          },
          findIndex: function (t) {
            return tt(
              Et(this),
              t,
              arguments.length > 1 ? arguments[1] : void 0
            );
          },
          forEach: function (t) {
            J(Et(this), t, arguments.length > 1 ? arguments[1] : void 0);
          },
          indexOf: function (t) {
            return nt(
              Et(this),
              t,
              arguments.length > 1 ? arguments[1] : void 0
            );
          },
          includes: function (t) {
            return et(
              Et(this),
              t,
              arguments.length > 1 ? arguments[1] : void 0
            );
          },
          join: function (t) {
            return ut.apply(Et(this), arguments);
          },
          lastIndexOf: function (t) {
            return at.apply(Et(this), arguments);
          },
          map: function (t) {
            return wt(
              Et(this),
              t,
              arguments.length > 1 ? arguments[1] : void 0
            );
          },
          reduce: function (t) {
            return st.apply(Et(this), arguments);
          },
          reduceRight: function (t) {
            return ct.apply(Et(this), arguments);
          },
          reverse: function () {
            for (
              var t, e = Et(this).length, n = Math.floor(e / 2), r = 0;
              r < n;

            )
              (t = this[r]), (this[r++] = this[--e]), (this[e] = t);
            return this;
          },
          some: function (t) {
            return Q(Et(this), t, arguments.length > 1 ? arguments[1] : void 0);
          },
          sort: function (t) {
            return lt.call(Et(this), t);
          },
          subarray: function (t, e) {
            var n = Et(this),
              r = n.length,
              i = g(t, r);
            return new (O(n, n[gt]))(
              n.buffer,
              n.byteOffset + i * n.BYTES_PER_ELEMENT,
              m((void 0 === e ? r : g(e, r)) - i)
            );
          },
        },
        Dt = function (t, e) {
          return At(this, ht.call(Et(this), t, e));
        },
        zt = function (t) {
          Et(this);
          var e = St(arguments[1], 1),
            n = this.length,
            r = _(t),
            i = m(r.length),
            o = 0;
          if (i + e > n) throw H("Wrong length!");
          for (; o < i; ) this[e + o] = r[o++];
        },
        Ft = {
          entries: function () {
            return ot.call(Et(this));
          },
          keys: function () {
            return it.call(Et(this));
          },
          values: function () {
            return rt.call(Et(this));
          },
        },
        Ut = function (t, e) {
          return (
            w(t) &&
            t[xt] &&
            "symbol" != typeof e &&
            e in t &&
            String(+e) == String(e)
          );
        },
        Bt = function (t, e) {
          return Ut(t, (e = y(e, !0))) ? h(2, t[e]) : V(t, e);
        },
        Gt = function (t, e, n) {
          return !(Ut(t, (e = y(e, !0))) && w(n) && x(n, "value")) ||
            x(n, "get") ||
            x(n, "set") ||
            n.configurable ||
            (x(n, "writable") && !n.writable) ||
            (x(n, "enumerable") && !n.enumerable)
            ? j(t, e, n)
            : ((t[e] = n.value), t);
        };
      yt || ((G.f = Bt), (B.f = Gt)),
        a(a.S + a.F * !yt, "Object", {
          getOwnPropertyDescriptor: Bt,
          defineProperty: Gt,
        }),
        o(function () {
          pt.call({});
        }) &&
          (pt = ft =
            function () {
              return ut.call(this);
            });
      var jt = f({}, Nt);
      f(jt, Ft),
        p(jt, dt, Ft.values),
        f(jt, {
          slice: Dt,
          set: zt,
          constructor: function () {},
          toString: pt,
          toLocaleString: It,
        }),
        Pt(jt, "buffer", "b"),
        Pt(jt, "byteOffset", "o"),
        Pt(jt, "byteLength", "l"),
        Pt(jt, "length", "e"),
        j(jt, mt, {
          get: function () {
            return this[xt];
          },
        }),
        (t.exports = function (t, e, n, c) {
          var u = t + ((c = !!c) ? "Clamped" : "") + "Array",
            h = "get" + t,
            f = "set" + t,
            d = i[u],
            g = d || {},
            y = d && E(d),
            x = !d || !s.ABV,
            _ = {},
            M = d && d.prototype,
            A = function (t, n) {
              j(t, n, {
                get: function () {
                  return (function (t, n) {
                    var r = t._d;
                    return r.v[h](n * e + r.o, _t);
                  })(this, n);
                },
                set: function (t) {
                  return (function (t, n, r) {
                    var i = t._d;
                    c &&
                      (r =
                        (r = Math.round(r)) < 0 ? 0 : r > 255 ? 255 : 255 & r),
                      i.v[f](n * e + i.o, r, _t);
                  })(this, n, t);
                },
                enumerable: !0,
              });
            };
          x
            ? ((d = n(function (t, n, r, i) {
                l(t, d, u, "_d");
                var o,
                  a,
                  s,
                  c,
                  h = 0,
                  f = 0;
                if (w(n)) {
                  if (
                    !(
                      n instanceof X ||
                      "ArrayBuffer" == (c = b(n)) ||
                      "SharedArrayBuffer" == c
                    )
                  )
                    return xt in n ? Lt(d, n) : Rt.call(d, n);
                  (o = n), (f = St(r, e));
                  var g = n.byteLength;
                  if (void 0 === i) {
                    if (g % e) throw H("Wrong length!");
                    if ((a = g - f) < 0) throw H("Wrong length!");
                  } else if ((a = m(i) * e) + f > g) throw H("Wrong length!");
                  s = a / e;
                } else (s = v(n)), (o = new X((a = s * e)));
                for (
                  p(t, "_d", { b: o, o: f, l: a, e: s, v: new Y(o) });
                  h < s;

                )
                  A(t, h++);
              })),
              (M = d.prototype = S(jt)),
              p(M, "constructor", d))
            : (o(function () {
                d(1);
              }) &&
                o(function () {
                  new d(-1);
                }) &&
                D(function (t) {
                  new d(), new d(null), new d(1.5), new d(t);
                }, !0)) ||
              ((d = n(function (t, n, r, i) {
                var o;
                return (
                  l(t, d, u),
                  w(n)
                    ? n instanceof X ||
                      "ArrayBuffer" == (o = b(n)) ||
                      "SharedArrayBuffer" == o
                      ? void 0 !== i
                        ? new g(n, St(r, e), i)
                        : void 0 !== r
                        ? new g(n, St(r, e))
                        : new g(n)
                      : xt in n
                      ? Lt(d, n)
                      : Rt.call(d, n)
                    : new g(v(n))
                );
              })),
              J(
                y !== Function.prototype ? T(g).concat(T(y)) : T(g),
                function (t) {
                  t in d || p(d, t, g[t]);
                }
              ),
              (d.prototype = M),
              r || (M.constructor = d));
          var L = M[dt],
            P = !!L && ("values" == L.name || null == L.name),
            R = Ft.values;
          p(d, vt, !0),
            p(M, xt, u),
            p(M, bt, !0),
            p(M, gt, d),
            (c ? new d(1)[mt] == u : mt in M) ||
              j(M, mt, {
                get: function () {
                  return u;
                },
              }),
            (_[u] = d),
            a(a.G + a.W + a.F * (d != g), _),
            a(a.S, u, { BYTES_PER_ELEMENT: e }),
            a(
              a.S +
                a.F *
                  o(function () {
                    g.of.call(d, 1);
                  }),
              u,
              { from: Rt, of: Ct }
            ),
            "BYTES_PER_ELEMENT" in M || p(M, "BYTES_PER_ELEMENT", e),
            a(a.P, u, Nt),
            z(u),
            a(a.P + a.F * Mt, u, { set: zt }),
            a(a.P + a.F * !P, u, Ft),
            r || M.toString == pt || (M.toString = pt),
            a(
              a.P +
                a.F *
                  o(function () {
                    new d(1).slice();
                  }),
              u,
              { slice: Dt }
            ),
            a(
              a.P +
                a.F *
                  (o(function () {
                    return (
                      [1, 2].toLocaleString() != new d([1, 2]).toLocaleString()
                    );
                  }) ||
                    !o(function () {
                      M.toLocaleString.call([1, 2]);
                    })),
              u,
              { toLocaleString: It }
            ),
            (N[u] = P ? L : R),
            r || P || p(M, dt, R);
        });
    } else t.exports = function () {};
  },
  function (t, e, n) {
    var r = n(4);
    t.exports = function (t, e) {
      if (!r(t)) return t;
      var n, i;
      if (e && "function" == typeof (n = t.toString) && !r((i = n.call(t))))
        return i;
      if ("function" == typeof (n = t.valueOf) && !r((i = n.call(t)))) return i;
      if (!e && "function" == typeof (n = t.toString) && !r((i = n.call(t))))
        return i;
      throw TypeError("Can't convert object to primitive value");
    };
  },
  function (t, e, n) {
    var r = n(29)("meta"),
      i = n(4),
      o = n(13),
      a = n(9).f,
      s = 0,
      c =
        Object.isExtensible ||
        function () {
          return !0;
        },
      u = !n(2)(function () {
        return c(Object.preventExtensions({}));
      }),
      l = function (t) {
        a(t, r, { value: { i: "O" + ++s, w: {} } });
      },
      h = (t.exports = {
        KEY: r,
        NEED: !1,
        fastKey: function (t, e) {
          if (!i(t))
            return "symbol" == typeof t
              ? t
              : ("string" == typeof t ? "S" : "P") + t;
          if (!o(t, r)) {
            if (!c(t)) return "F";
            if (!e) return "E";
            l(t);
          }
          return t[r].i;
        },
        getWeak: function (t, e) {
          if (!o(t, r)) {
            if (!c(t)) return !0;
            if (!e) return !1;
            l(t);
          }
          return t[r].w;
        },
        onFreeze: function (t) {
          return u && h.NEED && c(t) && !o(t, r) && l(t), t;
        },
      });
  },
  function (t, e) {
    t.exports = function (t, e) {
      return {
        enumerable: !(1 & t),
        configurable: !(2 & t),
        writable: !(4 & t),
        value: e,
      };
    };
  },
  function (t, e) {
    var n = 0,
      r = Math.random();
    t.exports = function (t) {
      return "Symbol(".concat(
        void 0 === t ? "" : t,
        ")_",
        (++n + r).toString(36)
      );
    };
  },
  function (t, e) {
    t.exports = !1;
  },
  function (t, e, n) {
    var r = n(91),
      i = n(63);
    t.exports =
      Object.keys ||
      function (t) {
        return r(t, i);
      };
  },
  function (t, e, n) {
    var r = n(19),
      i = Math.max,
      o = Math.min;
    t.exports = function (t, e) {
      return (t = r(t)) < 0 ? i(t + e, 0) : o(t, e);
    };
  },
  function (t, e, n) {
    var r = n(3),
      i = n(92),
      o = n(63),
      a = n(62)("IE_PROTO"),
      s = function () {},
      c = function () {
        var t,
          e = n(60)("iframe"),
          r = o.length;
        for (
          e.style.display = "none",
            n(64).appendChild(e),
            e.src = "javascript:",
            (t = e.contentWindow.document).open(),
            t.write("<script>document.F=Object</script>"),
            t.close(),
            c = t.F;
          r--;

        )
          delete c.prototype[o[r]];
        return c();
      };
    t.exports =
      Object.create ||
      function (t, e) {
        var n;
        return (
          null !== t
            ? ((s.prototype = r(t)),
              (n = new s()),
              (s.prototype = null),
              (n[a] = t))
            : (n = c()),
          void 0 === e ? n : i(n, e)
        );
      };
  },
  function (t, e, n) {
    var r = n(91),
      i = n(63).concat("length", "prototype");
    e.f =
      Object.getOwnPropertyNames ||
      function (t) {
        return r(t, i);
      };
  },
  function (t, e, n) {
    var r = n(13),
      i = n(10),
      o = n(62)("IE_PROTO"),
      a = Object.prototype;
    t.exports =
      Object.getPrototypeOf ||
      function (t) {
        return (
          (t = i(t)),
          r(t, o)
            ? t[o]
            : "function" == typeof t.constructor && t instanceof t.constructor
            ? t.constructor.prototype
            : t instanceof Object
            ? a
            : null
        );
      };
  },
  function (t, e, n) {
    var r = n(5)("unscopables"),
      i = Array.prototype;
    null == i[r] && n(14)(i, r, {}),
      (t.exports = function (t) {
        i[r][t] = !0;
      });
  },
  function (t, e, n) {
    var r = n(4);
    t.exports = function (t, e) {
      if (!r(t) || t._t !== e)
        throw TypeError("Incompatible receiver, " + e + " required!");
      return t;
    };
  },
  function (t, e, n) {
    var r = n(9).f,
      i = n(13),
      o = n(5)("toStringTag");
    t.exports = function (t, e, n) {
      t &&
        !i((t = n ? t : t.prototype), o) &&
        r(t, o, { configurable: !0, value: e });
    };
  },
  function (t, e, n) {
    var r = n(0),
      i = n(24),
      o = n(2),
      a = n(66),
      s = "[" + a + "]",
      c = RegExp("^" + s + s + "*"),
      u = RegExp(s + s + "*$"),
      l = function (t, e, n) {
        var i = {},
          s = o(function () {
            return !!a[t]() || "​" != "​"[t]();
          }),
          c = (i[t] = s ? e(h) : a[t]);
        n && (i[n] = c), r(r.P + r.F * s, "String", i);
      },
      h = (l.trim = function (t, e) {
        return (
          (t = String(i(t))),
          1 & e && (t = t.replace(c, "")),
          2 & e && (t = t.replace(u, "")),
          t
        );
      });
    t.exports = l;
  },
  function (t, e) {
    t.exports = {};
  },
  function (t, e, n) {
    "use strict";
    var r = n(1),
      i = n(9),
      o = n(8),
      a = n(5)("species");
    t.exports = function (t) {
      var e = r[t];
      o &&
        e &&
        !e[a] &&
        i.f(e, a, {
          configurable: !0,
          get: function () {
            return this;
          },
        });
    };
  },
  function (t, e) {
    t.exports = function (t, e, n, r) {
      if (!(t instanceof e) || (void 0 !== r && r in t))
        throw TypeError(n + ": incorrect invocation!");
      return t;
    };
  },
  function (t, e, n) {
    var r = n(11);
    t.exports = function (t, e, n) {
      for (var i in e) r(t, i, e[i], n);
      return t;
    };
  },
  function (t, e, n) {
    var r = n(23);
    t.exports = Object("z").propertyIsEnumerable(0)
      ? Object
      : function (t) {
          return "String" == r(t) ? t.split("") : Object(t);
        };
  },
  function (t, e) {
    e.f = {}.propertyIsEnumerable;
  },
  function (t, e, n) {
    var r = n(23),
      i = n(5)("toStringTag"),
      o =
        "Arguments" ==
        r(
          (function () {
            return arguments;
          })()
        );
    t.exports = function (t) {
      var e, n, a;
      return void 0 === t
        ? "Undefined"
        : null === t
        ? "Null"
        : "string" ==
          typeof (n = (function (t, e) {
            try {
              return t[e];
            } catch (t) {}
          })((e = Object(t)), i))
        ? n
        : o
        ? r(e)
        : "Object" == (a = r(e)) && "function" == typeof e.callee
        ? "Arguments"
        : a;
    };
  },
  function (t, e, n) {
    var r = n(3),
      i = n(18),
      o = n(5)("species");
    t.exports = function (t, e) {
      var n,
        a = r(t).constructor;
      return void 0 === a || null == (n = r(a)[o]) ? e : i(n);
    };
  },
  function (t, e, n) {
    var r = n(7),
      i = n(1),
      o = i["__core-js_shared__"] || (i["__core-js_shared__"] = {});
    (t.exports = function (t, e) {
      return o[t] || (o[t] = void 0 !== e ? e : {});
    })("versions", []).push({
      version: r.version,
      mode: n(30) ? "pure" : "global",
      copyright: "© 2019 Denis Pushkarev (zloirock.ru)",
    });
  },
  function (t, e, n) {
    var r = n(15),
      i = n(6),
      o = n(32);
    t.exports = function (t) {
      return function (e, n, a) {
        var s,
          c = r(e),
          u = i(c.length),
          l = o(a, u);
        if (t && n != n) {
          for (; u > l; ) if ((s = c[l++]) != s) return !0;
        } else
          for (; u > l; l++)
            if ((t || l in c) && c[l] === n) return t || l || 0;
        return !t && -1;
      };
    };
  },
  function (t, e) {
    e.f = Object.getOwnPropertySymbols;
  },
  function (t, e, n) {
    var r = n(23);
    t.exports =
      Array.isArray ||
      function (t) {
        return "Array" == r(t);
      };
  },
  function (t, e, n) {
    var r = n(5)("iterator"),
      i = !1;
    try {
      var o = [7][r]();
      (o.return = function () {
        i = !0;
      }),
        Array.from(o, function () {
          throw 2;
        });
    } catch (t) {}
    t.exports = function (t, e) {
      if (!e && !i) return !1;
      var n = !1;
      try {
        var o = [7],
          a = o[r]();
        (a.next = function () {
          return { done: (n = !0) };
        }),
          (o[r] = function () {
            return a;
          }),
          t(o);
      } catch (t) {}
      return n;
    };
  },
  function (t, e, n) {
    "use strict";
    var r = n(3);
    t.exports = function () {
      var t = r(this),
        e = "";
      return (
        t.global && (e += "g"),
        t.ignoreCase && (e += "i"),
        t.multiline && (e += "m"),
        t.unicode && (e += "u"),
        t.sticky && (e += "y"),
        e
      );
    };
  },
  function (t, e, n) {
    "use strict";
    var r = n(46),
      i = RegExp.prototype.exec;
    t.exports = function (t, e) {
      var n = t.exec;
      if ("function" == typeof n) {
        var o = n.call(t, e);
        if ("object" != typeof o)
          throw new TypeError(
            "RegExp exec method returned something other than an Object or null"
          );
        return o;
      }
      if ("RegExp" !== r(t))
        throw new TypeError("RegExp#exec called on incompatible receiver");
      return i.call(t, e);
    };
  },
  function (t, e, n) {
    "use strict";
    n(109);
    var r = n(11),
      i = n(14),
      o = n(2),
      a = n(24),
      s = n(5),
      c = n(81),
      u = s("species"),
      l = !o(function () {
        var t = /./;
        return (
          (t.exec = function () {
            var t = [];
            return (t.groups = { a: "7" }), t;
          }),
          "7" !== "".replace(t, "$<a>")
        );
      }),
      h = (function () {
        var t = /(?:)/,
          e = t.exec;
        t.exec = function () {
          return e.apply(this, arguments);
        };
        var n = "ab".split(t);
        return 2 === n.length && "a" === n[0] && "b" === n[1];
      })();
    t.exports = function (t, e, n) {
      var p = s(t),
        f = !o(function () {
          var e = {};
          return (
            (e[p] = function () {
              return 7;
            }),
            7 != ""[t](e)
          );
        }),
        d = f
          ? !o(function () {
              var e = !1,
                n = /a/;
              return (
                (n.exec = function () {
                  return (e = !0), null;
                }),
                "split" === t &&
                  ((n.constructor = {}),
                  (n.constructor[u] = function () {
                    return n;
                  })),
                n[p](""),
                !e
              );
            })
          : void 0;
      if (!f || !d || ("replace" === t && !l) || ("split" === t && !h)) {
        var m = /./[p],
          v = n(a, p, ""[t], function (t, e, n, r, i) {
            return e.exec === c
              ? f && !i
                ? { done: !0, value: m.call(e, n, r) }
                : { done: !0, value: t.call(n, e, r) }
              : { done: !1 };
          }),
          g = v[0],
          y = v[1];
        r(String.prototype, t, g),
          i(
            RegExp.prototype,
            p,
            2 == e
              ? function (t, e) {
                  return y.call(t, this, e);
                }
              : function (t) {
                  return y.call(t, this);
                }
          );
      }
    };
  },
  function (t, e, n) {
    var r = n(17),
      i = n(104),
      o = n(76),
      a = n(3),
      s = n(6),
      c = n(78),
      u = {},
      l = {};
    ((e = t.exports =
      function (t, e, n, h, p) {
        var f,
          d,
          m,
          v,
          g = p
            ? function () {
                return t;
              }
            : c(t),
          y = r(n, h, e ? 2 : 1),
          x = 0;
        if ("function" != typeof g) throw TypeError(t + " is not iterable!");
        if (o(g)) {
          for (f = s(t.length); f > x; x++)
            if ((v = e ? y(a((d = t[x]))[0], d[1]) : y(t[x])) === u || v === l)
              return v;
        } else
          for (m = g.call(t); !(d = m.next()).done; )
            if ((v = i(m, y, d.value, e)) === u || v === l) return v;
      }).BREAK = u),
      (e.RETURN = l);
  },
  function (t, e, n) {
    var r = n(1).navigator;
    t.exports = (r && r.userAgent) || "";
  },
  function (t, e, n) {
    "use strict";
    var r = n(1),
      i = n(0),
      o = n(11),
      a = n(43),
      s = n(27),
      c = n(56),
      u = n(42),
      l = n(4),
      h = n(2),
      p = n(52),
      f = n(38),
      d = n(67);
    t.exports = function (t, e, n, m, v, g) {
      var y = r[t],
        x = y,
        b = v ? "set" : "add",
        w = x && x.prototype,
        _ = {},
        M = function (t) {
          var e = w[t];
          o(
            w,
            t,
            "delete" == t
              ? function (t) {
                  return !(g && !l(t)) && e.call(this, 0 === t ? 0 : t);
                }
              : "has" == t
              ? function (t) {
                  return !(g && !l(t)) && e.call(this, 0 === t ? 0 : t);
                }
              : "get" == t
              ? function (t) {
                  return g && !l(t) ? void 0 : e.call(this, 0 === t ? 0 : t);
                }
              : "add" == t
              ? function (t) {
                  return e.call(this, 0 === t ? 0 : t), this;
                }
              : function (t, n) {
                  return e.call(this, 0 === t ? 0 : t, n), this;
                }
          );
        };
      if (
        "function" == typeof x &&
        (g ||
          (w.forEach &&
            !h(function () {
              new x().entries().next();
            })))
      ) {
        var S = new x(),
          E = S[b](g ? {} : -0, 1) != S,
          T = h(function () {
            S.has(1);
          }),
          A = p(function (t) {
            new x(t);
          }),
          L =
            !g &&
            h(function () {
              for (var t = new x(), e = 5; e--; ) t[b](e, e);
              return !t.has(-0);
            });
        A ||
          (((x = e(function (e, n) {
            u(e, x, t);
            var r = d(new y(), e, x);
            return null != n && c(n, v, r[b], r), r;
          })).prototype = w),
          (w.constructor = x)),
          (T || L) && (M("delete"), M("has"), v && M("get")),
          (L || E) && M(b),
          g && w.clear && delete w.clear;
      } else
        (x = m.getConstructor(e, t, v, b)), a(x.prototype, n), (s.NEED = !0);
      return (
        f(x, t),
        (_[t] = x),
        i(i.G + i.W + i.F * (x != y), _),
        g || m.setStrong(x, t, v),
        x
      );
    };
  },
  function (t, e, n) {
    for (
      var r,
        i = n(1),
        o = n(14),
        a = n(29),
        s = a("typed_array"),
        c = a("view"),
        u = !(!i.ArrayBuffer || !i.DataView),
        l = u,
        h = 0,
        p =
          "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(
            ","
          );
      h < 9;

    )
      (r = i[p[h++]])
        ? (o(r.prototype, s, !0), o(r.prototype, c, !0))
        : (l = !1);
    t.exports = { ABV: u, CONSTR: l, TYPED: s, VIEW: c };
  },
  function (t, e, n) {
    var r = n(4),
      i = n(1).document,
      o = r(i) && r(i.createElement);
    t.exports = function (t) {
      return o ? i.createElement(t) : {};
    };
  },
  function (t, e, n) {
    e.f = n(5);
  },
  function (t, e, n) {
    var r = n(48)("keys"),
      i = n(29);
    t.exports = function (t) {
      return r[t] || (r[t] = i(t));
    };
  },
  function (t, e) {
    t.exports =
      "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(
        ","
      );
  },
  function (t, e, n) {
    var r = n(1).document;
    t.exports = r && r.documentElement;
  },
  function (t, e, n) {
    var r = n(4),
      i = n(3),
      o = function (t, e) {
        if ((i(t), !r(e) && null !== e))
          throw TypeError(e + ": can't set as prototype!");
      };
    t.exports = {
      set:
        Object.setPrototypeOf ||
        ("__proto__" in {}
          ? (function (t, e, r) {
              try {
                (r = n(17)(
                  Function.call,
                  n(20).f(Object.prototype, "__proto__").set,
                  2
                ))(t, []),
                  (e = !(t instanceof Array));
              } catch (t) {
                e = !0;
              }
              return function (t, n) {
                return o(t, n), e ? (t.__proto__ = n) : r(t, n), t;
              };
            })({}, !1)
          : void 0),
      check: o,
    };
  },
  function (t, e) {
    t.exports = "\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff";
  },
  function (t, e, n) {
    var r = n(4),
      i = n(65).set;
    t.exports = function (t, e, n) {
      var o,
        a = e.constructor;
      return (
        a !== n &&
          "function" == typeof a &&
          (o = a.prototype) !== n.prototype &&
          r(o) &&
          i &&
          i(t, o),
        t
      );
    };
  },
  function (t, e, n) {
    "use strict";
    var r = n(19),
      i = n(24);
    t.exports = function (t) {
      var e = String(i(this)),
        n = "",
        o = r(t);
      if (o < 0 || o == 1 / 0) throw RangeError("Count can't be negative");
      for (; o > 0; (o >>>= 1) && (e += e)) 1 & o && (n += e);
      return n;
    };
  },
  function (t, e) {
    t.exports =
      Math.sign ||
      function (t) {
        return 0 == (t = +t) || t != t ? t : t < 0 ? -1 : 1;
      };
  },
  function (t, e) {
    var n = Math.expm1;
    t.exports =
      !n ||
      n(10) > 22025.465794806718 ||
      n(10) < 22025.465794806718 ||
      -2e-17 != n(-2e-17)
        ? function (t) {
            return 0 == (t = +t)
              ? t
              : t > -1e-6 && t < 1e-6
              ? t + (t * t) / 2
              : Math.exp(t) - 1;
          }
        : n;
  },
  function (t, e, n) {
    var r = n(19),
      i = n(24);
    t.exports = function (t) {
      return function (e, n) {
        var o,
          a,
          s = String(i(e)),
          c = r(n),
          u = s.length;
        return c < 0 || c >= u
          ? t
            ? ""
            : void 0
          : (o = s.charCodeAt(c)) < 55296 ||
            o > 56319 ||
            c + 1 === u ||
            (a = s.charCodeAt(c + 1)) < 56320 ||
            a > 57343
          ? t
            ? s.charAt(c)
            : o
          : t
          ? s.slice(c, c + 2)
          : a - 56320 + ((o - 55296) << 10) + 65536;
      };
    };
  },
  function (t, e, n) {
    "use strict";
    var r = n(30),
      i = n(0),
      o = n(11),
      a = n(14),
      s = n(40),
      c = n(103),
      u = n(38),
      l = n(35),
      h = n(5)("iterator"),
      p = !([].keys && "next" in [].keys()),
      f = function () {
        return this;
      };
    t.exports = function (t, e, n, d, m, v, g) {
      c(n, e, d);
      var y,
        x,
        b,
        w = function (t) {
          if (!p && t in E) return E[t];
          switch (t) {
            case "keys":
            case "values":
              return function () {
                return new n(this, t);
              };
          }
          return function () {
            return new n(this, t);
          };
        },
        _ = e + " Iterator",
        M = "values" == m,
        S = !1,
        E = t.prototype,
        T = E[h] || E["@@iterator"] || (m && E[m]),
        A = T || w(m),
        L = m ? (M ? w("entries") : A) : void 0,
        P = ("Array" == e && E.entries) || T;
      if (
        (P &&
          (b = l(P.call(new t()))) !== Object.prototype &&
          b.next &&
          (u(b, _, !0), r || "function" == typeof b[h] || a(b, h, f)),
        M &&
          T &&
          "values" !== T.name &&
          ((S = !0),
          (A = function () {
            return T.call(this);
          })),
        (r && !g) || (!p && !S && E[h]) || a(E, h, A),
        (s[e] = A),
        (s[_] = f),
        m)
      )
        if (
          ((y = {
            values: M ? A : w("values"),
            keys: v ? A : w("keys"),
            entries: L,
          }),
          g)
        )
          for (x in y) x in E || o(E, x, y[x]);
        else i(i.P + i.F * (p || S), e, y);
      return y;
    };
  },
  function (t, e, n) {
    var r = n(74),
      i = n(24);
    t.exports = function (t, e, n) {
      if (r(e)) throw TypeError("String#" + n + " doesn't accept regex!");
      return String(i(t));
    };
  },
  function (t, e, n) {
    var r = n(4),
      i = n(23),
      o = n(5)("match");
    t.exports = function (t) {
      var e;
      return r(t) && (void 0 !== (e = t[o]) ? !!e : "RegExp" == i(t));
    };
  },
  function (t, e, n) {
    var r = n(5)("match");
    t.exports = function (t) {
      var e = /./;
      try {
        "/./"[t](e);
      } catch (n) {
        try {
          return (e[r] = !1), !"/./"[t](e);
        } catch (t) {}
      }
      return !0;
    };
  },
  function (t, e, n) {
    var r = n(40),
      i = n(5)("iterator"),
      o = Array.prototype;
    t.exports = function (t) {
      return void 0 !== t && (r.Array === t || o[i] === t);
    };
  },
  function (t, e, n) {
    "use strict";
    var r = n(9),
      i = n(28);
    t.exports = function (t, e, n) {
      e in t ? r.f(t, e, i(0, n)) : (t[e] = n);
    };
  },
  function (t, e, n) {
    var r = n(46),
      i = n(5)("iterator"),
      o = n(40);
    t.exports = n(7).getIteratorMethod = function (t) {
      if (null != t) return t[i] || t["@@iterator"] || o[r(t)];
    };
  },
  function (t, e, n) {
    "use strict";
    var r = n(10),
      i = n(32),
      o = n(6);
    t.exports = function (t) {
      for (
        var e = r(this),
          n = o(e.length),
          a = arguments.length,
          s = i(a > 1 ? arguments[1] : void 0, n),
          c = a > 2 ? arguments[2] : void 0,
          u = void 0 === c ? n : i(c, n);
        u > s;

      )
        e[s++] = t;
      return e;
    };
  },
  function (t, e, n) {
    "use strict";
    var r = n(36),
      i = n(108),
      o = n(40),
      a = n(15);
    (t.exports = n(72)(
      Array,
      "Array",
      function (t, e) {
        (this._t = a(t)), (this._i = 0), (this._k = e);
      },
      function () {
        var t = this._t,
          e = this._k,
          n = this._i++;
        return !t || n >= t.length
          ? ((this._t = void 0), i(1))
          : i(0, "keys" == e ? n : "values" == e ? t[n] : [n, t[n]]);
      },
      "values"
    )),
      (o.Arguments = o.Array),
      r("keys"),
      r("values"),
      r("entries");
  },
  function (t, e, n) {
    "use strict";
    var r,
      i,
      o = n(53),
      a = RegExp.prototype.exec,
      s = String.prototype.replace,
      c = a,
      u =
        ((r = /a/),
        (i = /b*/g),
        a.call(r, "a"),
        a.call(i, "a"),
        0 !== r.lastIndex || 0 !== i.lastIndex),
      l = void 0 !== /()??/.exec("")[1];
    (u || l) &&
      (c = function (t) {
        var e,
          n,
          r,
          i,
          c = this;
        return (
          l && (n = new RegExp("^" + c.source + "$(?!\\s)", o.call(c))),
          u && (e = c.lastIndex),
          (r = a.call(c, t)),
          u && r && (c.lastIndex = c.global ? r.index + r[0].length : e),
          l &&
            r &&
            r.length > 1 &&
            s.call(r[0], n, function () {
              for (i = 1; i < arguments.length - 2; i++)
                void 0 === arguments[i] && (r[i] = void 0);
            }),
          r
        );
      }),
      (t.exports = c);
  },
  function (t, e, n) {
    "use strict";
    var r = n(71)(!0);
    t.exports = function (t, e, n) {
      return e + (n ? r(t, e).length : 1);
    };
  },
  function (t, e, n) {
    var r,
      i,
      o,
      a = n(17),
      s = n(97),
      c = n(64),
      u = n(60),
      l = n(1),
      h = l.process,
      p = l.setImmediate,
      f = l.clearImmediate,
      d = l.MessageChannel,
      m = l.Dispatch,
      v = 0,
      g = {},
      y = function () {
        var t = +this;
        if (g.hasOwnProperty(t)) {
          var e = g[t];
          delete g[t], e();
        }
      },
      x = function (t) {
        y.call(t.data);
      };
    (p && f) ||
      ((p = function (t) {
        for (var e = [], n = 1; arguments.length > n; ) e.push(arguments[n++]);
        return (
          (g[++v] = function () {
            s("function" == typeof t ? t : Function(t), e);
          }),
          r(v),
          v
        );
      }),
      (f = function (t) {
        delete g[t];
      }),
      "process" == n(23)(h)
        ? (r = function (t) {
            h.nextTick(a(y, t, 1));
          })
        : m && m.now
        ? (r = function (t) {
            m.now(a(y, t, 1));
          })
        : d
        ? ((o = (i = new d()).port2),
          (i.port1.onmessage = x),
          (r = a(o.postMessage, o, 1)))
        : l.addEventListener &&
          "function" == typeof postMessage &&
          !l.importScripts
        ? ((r = function (t) {
            l.postMessage(t + "", "*");
          }),
          l.addEventListener("message", x, !1))
        : (r =
            "onreadystatechange" in u("script")
              ? function (t) {
                  c.appendChild(u("script")).onreadystatechange = function () {
                    c.removeChild(this), y.call(t);
                  };
                }
              : function (t) {
                  setTimeout(a(y, t, 1), 0);
                })),
      (t.exports = { set: p, clear: f });
  },
  function (t, e, n) {
    "use strict";
    var r = n(1),
      i = n(8),
      o = n(30),
      a = n(59),
      s = n(14),
      c = n(43),
      u = n(2),
      l = n(42),
      h = n(19),
      p = n(6),
      f = n(116),
      d = n(34).f,
      m = n(9).f,
      v = n(79),
      g = n(38),
      y = "prototype",
      x = "Wrong index!",
      b = r.ArrayBuffer,
      w = r.DataView,
      _ = r.Math,
      M = r.RangeError,
      S = r.Infinity,
      E = b,
      T = _.abs,
      A = _.pow,
      L = _.floor,
      P = _.log,
      R = _.LN2,
      C = i ? "_b" : "buffer",
      O = i ? "_l" : "byteLength",
      I = i ? "_o" : "byteOffset";
    function N(t, e, n) {
      var r,
        i,
        o,
        a = new Array(n),
        s = 8 * n - e - 1,
        c = (1 << s) - 1,
        u = c >> 1,
        l = 23 === e ? A(2, -24) - A(2, -77) : 0,
        h = 0,
        p = t < 0 || (0 === t && 1 / t < 0) ? 1 : 0;
      for (
        (t = T(t)) != t || t === S
          ? ((i = t != t ? 1 : 0), (r = c))
          : ((r = L(P(t) / R)),
            t * (o = A(2, -r)) < 1 && (r--, (o *= 2)),
            (t += r + u >= 1 ? l / o : l * A(2, 1 - u)) * o >= 2 &&
              (r++, (o /= 2)),
            r + u >= c
              ? ((i = 0), (r = c))
              : r + u >= 1
              ? ((i = (t * o - 1) * A(2, e)), (r += u))
              : ((i = t * A(2, u - 1) * A(2, e)), (r = 0)));
        e >= 8;
        a[h++] = 255 & i, i /= 256, e -= 8
      );
      for (r = (r << e) | i, s += e; s > 0; a[h++] = 255 & r, r /= 256, s -= 8);
      return (a[--h] |= 128 * p), a;
    }
    function D(t, e, n) {
      var r,
        i = 8 * n - e - 1,
        o = (1 << i) - 1,
        a = o >> 1,
        s = i - 7,
        c = n - 1,
        u = t[c--],
        l = 127 & u;
      for (u >>= 7; s > 0; l = 256 * l + t[c], c--, s -= 8);
      for (
        r = l & ((1 << -s) - 1), l >>= -s, s += e;
        s > 0;
        r = 256 * r + t[c], c--, s -= 8
      );
      if (0 === l) l = 1 - a;
      else {
        if (l === o) return r ? NaN : u ? -S : S;
        (r += A(2, e)), (l -= a);
      }
      return (u ? -1 : 1) * r * A(2, l - e);
    }
    function z(t) {
      return (t[3] << 24) | (t[2] << 16) | (t[1] << 8) | t[0];
    }
    function F(t) {
      return [255 & t];
    }
    function U(t) {
      return [255 & t, (t >> 8) & 255];
    }
    function B(t) {
      return [255 & t, (t >> 8) & 255, (t >> 16) & 255, (t >> 24) & 255];
    }
    function G(t) {
      return N(t, 52, 8);
    }
    function j(t) {
      return N(t, 23, 4);
    }
    function V(t, e, n) {
      m(t[y], e, {
        get: function () {
          return this[n];
        },
      });
    }
    function H(t, e, n, r) {
      var i = f(+n);
      if (i + e > t[O]) throw M(x);
      var o = t[C]._b,
        a = i + t[I],
        s = o.slice(a, a + e);
      return r ? s : s.reverse();
    }
    function k(t, e, n, r, i, o) {
      var a = f(+n);
      if (a + e > t[O]) throw M(x);
      for (var s = t[C]._b, c = a + t[I], u = r(+i), l = 0; l < e; l++)
        s[c + l] = u[o ? l : e - l - 1];
    }
    if (a.ABV) {
      if (
        !u(function () {
          b(1);
        }) ||
        !u(function () {
          new b(-1);
        }) ||
        u(function () {
          return new b(), new b(1.5), new b(NaN), "ArrayBuffer" != b.name;
        })
      ) {
        for (
          var W,
            q = ((b = function (t) {
              return l(this, b), new E(f(t));
            })[y] = E[y]),
            X = d(E),
            Y = 0;
          X.length > Y;

        )
          (W = X[Y++]) in b || s(b, W, E[W]);
        o || (q.constructor = b);
      }
      var J = new w(new b(2)),
        Z = w[y].setInt8;
      J.setInt8(0, 2147483648),
        J.setInt8(1, 2147483649),
        (!J.getInt8(0) && J.getInt8(1)) ||
          c(
            w[y],
            {
              setInt8: function (t, e) {
                Z.call(this, t, (e << 24) >> 24);
              },
              setUint8: function (t, e) {
                Z.call(this, t, (e << 24) >> 24);
              },
            },
            !0
          );
    } else
      (b = function (t) {
        l(this, b, "ArrayBuffer");
        var e = f(t);
        (this._b = v.call(new Array(e), 0)), (this[O] = e);
      }),
        (w = function (t, e, n) {
          l(this, w, "DataView"), l(t, b, "DataView");
          var r = t[O],
            i = h(e);
          if (i < 0 || i > r) throw M("Wrong offset!");
          if (i + (n = void 0 === n ? r - i : p(n)) > r)
            throw M("Wrong length!");
          (this[C] = t), (this[I] = i), (this[O] = n);
        }),
        i &&
          (V(b, "byteLength", "_l"),
          V(w, "buffer", "_b"),
          V(w, "byteLength", "_l"),
          V(w, "byteOffset", "_o")),
        c(w[y], {
          getInt8: function (t) {
            return (H(this, 1, t)[0] << 24) >> 24;
          },
          getUint8: function (t) {
            return H(this, 1, t)[0];
          },
          getInt16: function (t) {
            var e = H(this, 2, t, arguments[1]);
            return (((e[1] << 8) | e[0]) << 16) >> 16;
          },
          getUint16: function (t) {
            var e = H(this, 2, t, arguments[1]);
            return (e[1] << 8) | e[0];
          },
          getInt32: function (t) {
            return z(H(this, 4, t, arguments[1]));
          },
          getUint32: function (t) {
            return z(H(this, 4, t, arguments[1])) >>> 0;
          },
          getFloat32: function (t) {
            return D(H(this, 4, t, arguments[1]), 23, 4);
          },
          getFloat64: function (t) {
            return D(H(this, 8, t, arguments[1]), 52, 8);
          },
          setInt8: function (t, e) {
            k(this, 1, t, F, e);
          },
          setUint8: function (t, e) {
            k(this, 1, t, F, e);
          },
          setInt16: function (t, e) {
            k(this, 2, t, U, e, arguments[2]);
          },
          setUint16: function (t, e) {
            k(this, 2, t, U, e, arguments[2]);
          },
          setInt32: function (t, e) {
            k(this, 4, t, B, e, arguments[2]);
          },
          setUint32: function (t, e) {
            k(this, 4, t, B, e, arguments[2]);
          },
          setFloat32: function (t, e) {
            k(this, 4, t, j, e, arguments[2]);
          },
          setFloat64: function (t, e) {
            k(this, 8, t, G, e, arguments[2]);
          },
        });
    g(b, "ArrayBuffer"),
      g(w, "DataView"),
      s(w[y], a.VIEW, !0),
      (e.ArrayBuffer = b),
      (e.DataView = w);
  },
  function (t, e) {
    var n = (t.exports =
      "undefined" != typeof window && window.Math == Math
        ? window
        : "undefined" != typeof self && self.Math == Math
        ? self
        : Function("return this")());
    "number" == typeof __g && (__g = n);
  },
  function (t, e) {
    t.exports = function (t) {
      return "object" == typeof t ? null !== t : "function" == typeof t;
    };
  },
  function (t, e, n) {
    t.exports = !n(121)(function () {
      return (
        7 !=
        Object.defineProperty({}, "a", {
          get: function () {
            return 7;
          },
        }).a
      );
    });
  },
  function (t, e, n) {
    (function (e) {
      for (
        var r = n(312),
          i = "undefined" == typeof window ? e : window,
          o = ["moz", "webkit"],
          a = "AnimationFrame",
          s = i["request" + a],
          c = i["cancel" + a] || i["cancelRequest" + a],
          u = 0;
        !s && u < o.length;
        u++
      )
        (s = i[o[u] + "Request" + a]),
          (c = i[o[u] + "Cancel" + a] || i[o[u] + "CancelRequest" + a]);
      if (!s || !c) {
        var l = 0,
          h = 0,
          p = [];
        (s = function (t) {
          if (0 === p.length) {
            var e = r(),
              n = Math.max(0, 1e3 / 60 - (e - l));
            (l = n + e),
              setTimeout(function () {
                var t = p.slice(0);
                p.length = 0;
                for (var e = 0; e < t.length; e++)
                  if (!t[e].cancelled)
                    try {
                      t[e].callback(l);
                    } catch (t) {
                      setTimeout(function () {
                        throw t;
                      }, 0);
                    }
              }, Math.round(n));
          }
          return p.push({ handle: ++h, callback: t, cancelled: !1 }), h;
        }),
          (c = function (t) {
            for (var e = 0; e < p.length; e++)
              p[e].handle === t && (p[e].cancelled = !0);
          });
      }
      (t.exports = function (t) {
        return s.call(i, t);
      }),
        (t.exports.cancel = function () {
          c.apply(i, arguments);
        }),
        (t.exports.polyfill = function (t) {
          t || (t = i),
            (t.requestAnimationFrame = s),
            (t.cancelAnimationFrame = c);
        });
    }.call(this, n(311)));
  },
  function (t, e, n) {
    t.exports =
      !n(8) &&
      !n(2)(function () {
        return (
          7 !=
          Object.defineProperty(n(60)("div"), "a", {
            get: function () {
              return 7;
            },
          }).a
        );
      });
  },
  function (t, e, n) {
    var r = n(1),
      i = n(7),
      o = n(30),
      a = n(61),
      s = n(9).f;
    t.exports = function (t) {
      var e = i.Symbol || (i.Symbol = o ? {} : r.Symbol || {});
      "_" == t.charAt(0) || t in e || s(e, t, { value: a.f(t) });
    };
  },
  function (t, e, n) {
    var r = n(13),
      i = n(15),
      o = n(49)(!1),
      a = n(62)("IE_PROTO");
    t.exports = function (t, e) {
      var n,
        s = i(t),
        c = 0,
        u = [];
      for (n in s) n != a && r(s, n) && u.push(n);
      for (; e.length > c; ) r(s, (n = e[c++])) && (~o(u, n) || u.push(n));
      return u;
    };
  },
  function (t, e, n) {
    var r = n(9),
      i = n(3),
      o = n(31);
    t.exports = n(8)
      ? Object.defineProperties
      : function (t, e) {
          i(t);
          for (var n, a = o(e), s = a.length, c = 0; s > c; )
            r.f(t, (n = a[c++]), e[n]);
          return t;
        };
  },
  function (t, e, n) {
    var r = n(15),
      i = n(34).f,
      o = {}.toString,
      a =
        "object" == typeof window && window && Object.getOwnPropertyNames
          ? Object.getOwnPropertyNames(window)
          : [];
    t.exports.f = function (t) {
      return a && "[object Window]" == o.call(t)
        ? (function (t) {
            try {
              return i(t);
            } catch (t) {
              return a.slice();
            }
          })(t)
        : i(r(t));
    };
  },
  function (t, e, n) {
    "use strict";
    var r = n(8),
      i = n(31),
      o = n(50),
      a = n(45),
      s = n(10),
      c = n(44),
      u = Object.assign;
    t.exports =
      !u ||
      n(2)(function () {
        var t = {},
          e = {},
          n = Symbol(),
          r = "abcdefghijklmnopqrst";
        return (
          (t[n] = 7),
          r.split("").forEach(function (t) {
            e[t] = t;
          }),
          7 != u({}, t)[n] || Object.keys(u({}, e)).join("") != r
        );
      })
        ? function (t, e) {
            for (
              var n = s(t), u = arguments.length, l = 1, h = o.f, p = a.f;
              u > l;

            )
              for (
                var f,
                  d = c(arguments[l++]),
                  m = h ? i(d).concat(h(d)) : i(d),
                  v = m.length,
                  g = 0;
                v > g;

              )
                (f = m[g++]), (r && !p.call(d, f)) || (n[f] = d[f]);
            return n;
          }
        : u;
  },
  function (t, e) {
    t.exports =
      Object.is ||
      function (t, e) {
        return t === e ? 0 !== t || 1 / t == 1 / e : t != t && e != e;
      };
  },
  function (t, e, n) {
    "use strict";
    var r = n(18),
      i = n(4),
      o = n(97),
      a = [].slice,
      s = {},
      c = function (t, e, n) {
        if (!(e in s)) {
          for (var r = [], i = 0; i < e; i++) r[i] = "a[" + i + "]";
          s[e] = Function("F,a", "return new F(" + r.join(",") + ")");
        }
        return s[e](t, n);
      };
    t.exports =
      Function.bind ||
      function (t) {
        var e = r(this),
          n = a.call(arguments, 1),
          s = function () {
            var r = n.concat(a.call(arguments));
            return this instanceof s ? c(e, r.length, r) : o(e, r, t);
          };
        return i(e.prototype) && (s.prototype = e.prototype), s;
      };
  },
  function (t, e) {
    t.exports = function (t, e, n) {
      var r = void 0 === n;
      switch (e.length) {
        case 0:
          return r ? t() : t.call(n);
        case 1:
          return r ? t(e[0]) : t.call(n, e[0]);
        case 2:
          return r ? t(e[0], e[1]) : t.call(n, e[0], e[1]);
        case 3:
          return r ? t(e[0], e[1], e[2]) : t.call(n, e[0], e[1], e[2]);
        case 4:
          return r
            ? t(e[0], e[1], e[2], e[3])
            : t.call(n, e[0], e[1], e[2], e[3]);
      }
      return t.apply(n, e);
    };
  },
  function (t, e, n) {
    var r = n(1).parseInt,
      i = n(39).trim,
      o = n(66),
      a = /^[-+]?0[xX]/;
    t.exports =
      8 !== r(o + "08") || 22 !== r(o + "0x16")
        ? function (t, e) {
            var n = i(String(t), 3);
            return r(n, e >>> 0 || (a.test(n) ? 16 : 10));
          }
        : r;
  },
  function (t, e, n) {
    var r = n(1).parseFloat,
      i = n(39).trim;
    t.exports =
      1 / r(n(66) + "-0") != -1 / 0
        ? function (t) {
            var e = i(String(t), 3),
              n = r(e);
            return 0 === n && "-" == e.charAt(0) ? -0 : n;
          }
        : r;
  },
  function (t, e, n) {
    var r = n(23);
    t.exports = function (t, e) {
      if ("number" != typeof t && "Number" != r(t)) throw TypeError(e);
      return +t;
    };
  },
  function (t, e, n) {
    var r = n(4),
      i = Math.floor;
    t.exports = function (t) {
      return !r(t) && isFinite(t) && i(t) === t;
    };
  },
  function (t, e) {
    t.exports =
      Math.log1p ||
      function (t) {
        return (t = +t) > -1e-8 && t < 1e-8 ? t - (t * t) / 2 : Math.log(1 + t);
      };
  },
  function (t, e, n) {
    "use strict";
    var r = n(33),
      i = n(28),
      o = n(38),
      a = {};
    n(14)(a, n(5)("iterator"), function () {
      return this;
    }),
      (t.exports = function (t, e, n) {
        (t.prototype = r(a, { next: i(1, n) })), o(t, e + " Iterator");
      });
  },
  function (t, e, n) {
    var r = n(3);
    t.exports = function (t, e, n, i) {
      try {
        return i ? e(r(n)[0], n[1]) : e(n);
      } catch (e) {
        var o = t.return;
        throw (void 0 !== o && r(o.call(t)), e);
      }
    };
  },
  function (t, e, n) {
    var r = n(218);
    t.exports = function (t, e) {
      return new (r(t))(e);
    };
  },
  function (t, e, n) {
    var r = n(18),
      i = n(10),
      o = n(44),
      a = n(6);
    t.exports = function (t, e, n, s, c) {
      r(e);
      var u = i(t),
        l = o(u),
        h = a(u.length),
        p = c ? h - 1 : 0,
        f = c ? -1 : 1;
      if (n < 2)
        for (;;) {
          if (p in l) {
            (s = l[p]), (p += f);
            break;
          }
          if (((p += f), c ? p < 0 : h <= p))
            throw TypeError("Reduce of empty array with no initial value");
        }
      for (; c ? p >= 0 : h > p; p += f) p in l && (s = e(s, l[p], p, u));
      return s;
    };
  },
  function (t, e, n) {
    "use strict";
    var r = n(10),
      i = n(32),
      o = n(6);
    t.exports =
      [].copyWithin ||
      function (t, e) {
        var n = r(this),
          a = o(n.length),
          s = i(t, a),
          c = i(e, a),
          u = arguments.length > 2 ? arguments[2] : void 0,
          l = Math.min((void 0 === u ? a : i(u, a)) - c, a - s),
          h = 1;
        for (
          c < s && s < c + l && ((h = -1), (c += l - 1), (s += l - 1));
          l-- > 0;

        )
          c in n ? (n[s] = n[c]) : delete n[s], (s += h), (c += h);
        return n;
      };
  },
  function (t, e) {
    t.exports = function (t, e) {
      return { value: e, done: !!t };
    };
  },
  function (t, e, n) {
    "use strict";
    var r = n(81);
    n(0)({ target: "RegExp", proto: !0, forced: r !== /./.exec }, { exec: r });
  },
  function (t, e, n) {
    n(8) &&
      "g" != /./g.flags &&
      n(9).f(RegExp.prototype, "flags", { configurable: !0, get: n(53) });
  },
  function (t, e, n) {
    "use strict";
    var r,
      i,
      o,
      a,
      s = n(30),
      c = n(1),
      u = n(17),
      l = n(46),
      h = n(0),
      p = n(4),
      f = n(18),
      d = n(42),
      m = n(56),
      v = n(47),
      g = n(83).set,
      y = n(238)(),
      x = n(112),
      b = n(239),
      w = n(57),
      _ = n(113),
      M = c.TypeError,
      S = c.process,
      E = S && S.versions,
      T = (E && E.v8) || "",
      A = c.Promise,
      L = "process" == l(S),
      P = function () {},
      R = (i = x.f),
      C = !!(function () {
        try {
          var t = A.resolve(1),
            e = ((t.constructor = {})[n(5)("species")] = function (t) {
              t(P, P);
            });
          return (
            (L || "function" == typeof PromiseRejectionEvent) &&
            t.then(P) instanceof e &&
            0 !== T.indexOf("6.6") &&
            -1 === w.indexOf("Chrome/66")
          );
        } catch (t) {}
      })(),
      O = function (t) {
        var e;
        return !(!p(t) || "function" != typeof (e = t.then)) && e;
      },
      I = function (t, e) {
        if (!t._n) {
          t._n = !0;
          var n = t._c;
          y(function () {
            for (
              var r = t._v,
                i = 1 == t._s,
                o = 0,
                a = function (e) {
                  var n,
                    o,
                    a,
                    s = i ? e.ok : e.fail,
                    c = e.resolve,
                    u = e.reject,
                    l = e.domain;
                  try {
                    s
                      ? (i || (2 == t._h && z(t), (t._h = 1)),
                        !0 === s
                          ? (n = r)
                          : (l && l.enter(),
                            (n = s(r)),
                            l && (l.exit(), (a = !0))),
                        n === e.promise
                          ? u(M("Promise-chain cycle"))
                          : (o = O(n))
                          ? o.call(n, c, u)
                          : c(n))
                      : u(r);
                  } catch (t) {
                    l && !a && l.exit(), u(t);
                  }
                };
              n.length > o;

            )
              a(n[o++]);
            (t._c = []), (t._n = !1), e && !t._h && N(t);
          });
        }
      },
      N = function (t) {
        g.call(c, function () {
          var e,
            n,
            r,
            i = t._v,
            o = D(t);
          if (
            (o &&
              ((e = b(function () {
                L
                  ? S.emit("unhandledRejection", i, t)
                  : (n = c.onunhandledrejection)
                  ? n({ promise: t, reason: i })
                  : (r = c.console) &&
                    r.error &&
                    r.error("Unhandled promise rejection", i);
              })),
              (t._h = L || D(t) ? 2 : 1)),
            (t._a = void 0),
            o && e.e)
          )
            throw e.v;
        });
      },
      D = function (t) {
        return 1 !== t._h && 0 === (t._a || t._c).length;
      },
      z = function (t) {
        g.call(c, function () {
          var e;
          L
            ? S.emit("rejectionHandled", t)
            : (e = c.onrejectionhandled) && e({ promise: t, reason: t._v });
        });
      },
      F = function (t) {
        var e = this;
        e._d ||
          ((e._d = !0),
          ((e = e._w || e)._v = t),
          (e._s = 2),
          e._a || (e._a = e._c.slice()),
          I(e, !0));
      },
      U = function (t) {
        var e,
          n = this;
        if (!n._d) {
          (n._d = !0), (n = n._w || n);
          try {
            if (n === t) throw M("Promise can't be resolved itself");
            (e = O(t))
              ? y(function () {
                  var r = { _w: n, _d: !1 };
                  try {
                    e.call(t, u(U, r, 1), u(F, r, 1));
                  } catch (t) {
                    F.call(r, t);
                  }
                })
              : ((n._v = t), (n._s = 1), I(n, !1));
          } catch (t) {
            F.call({ _w: n, _d: !1 }, t);
          }
        }
      };
    C ||
      ((A = function (t) {
        d(this, A, "Promise", "_h"), f(t), r.call(this);
        try {
          t(u(U, this, 1), u(F, this, 1));
        } catch (t) {
          F.call(this, t);
        }
      }),
      ((r = function (t) {
        (this._c = []),
          (this._a = void 0),
          (this._s = 0),
          (this._d = !1),
          (this._v = void 0),
          (this._h = 0),
          (this._n = !1);
      }).prototype = n(43)(A.prototype, {
        then: function (t, e) {
          var n = R(v(this, A));
          return (
            (n.ok = "function" != typeof t || t),
            (n.fail = "function" == typeof e && e),
            (n.domain = L ? S.domain : void 0),
            this._c.push(n),
            this._a && this._a.push(n),
            this._s && I(this, !1),
            n.promise
          );
        },
        catch: function (t) {
          return this.then(void 0, t);
        },
      })),
      (o = function () {
        var t = new r();
        (this.promise = t),
          (this.resolve = u(U, t, 1)),
          (this.reject = u(F, t, 1));
      }),
      (x.f = R =
        function (t) {
          return t === A || t === a ? new o(t) : i(t);
        })),
      h(h.G + h.W + h.F * !C, { Promise: A }),
      n(38)(A, "Promise"),
      n(41)("Promise"),
      (a = n(7).Promise),
      h(h.S + h.F * !C, "Promise", {
        reject: function (t) {
          var e = R(this);
          return (0, e.reject)(t), e.promise;
        },
      }),
      h(h.S + h.F * (s || !C), "Promise", {
        resolve: function (t) {
          return _(s && this === a ? A : this, t);
        },
      }),
      h(
        h.S +
          h.F *
            !(
              C &&
              n(52)(function (t) {
                A.all(t).catch(P);
              })
            ),
        "Promise",
        {
          all: function (t) {
            var e = this,
              n = R(e),
              r = n.resolve,
              i = n.reject,
              o = b(function () {
                var n = [],
                  o = 0,
                  a = 1;
                m(t, !1, function (t) {
                  var s = o++,
                    c = !1;
                  n.push(void 0),
                    a++,
                    e.resolve(t).then(function (t) {
                      c || ((c = !0), (n[s] = t), --a || r(n));
                    }, i);
                }),
                  --a || r(n);
              });
            return o.e && i(o.v), n.promise;
          },
          race: function (t) {
            var e = this,
              n = R(e),
              r = n.reject,
              i = b(function () {
                m(t, !1, function (t) {
                  e.resolve(t).then(n.resolve, r);
                });
              });
            return i.e && r(i.v), n.promise;
          },
        }
      );
  },
  function (t, e, n) {
    "use strict";
    var r = n(18);
    function i(t) {
      var e, n;
      (this.promise = new t(function (t, r) {
        if (void 0 !== e || void 0 !== n)
          throw TypeError("Bad Promise constructor");
        (e = t), (n = r);
      })),
        (this.resolve = r(e)),
        (this.reject = r(n));
    }
    t.exports.f = function (t) {
      return new i(t);
    };
  },
  function (t, e, n) {
    var r = n(3),
      i = n(4),
      o = n(112);
    t.exports = function (t, e) {
      if ((r(t), i(e) && e.constructor === t)) return e;
      var n = o.f(t);
      return (0, n.resolve)(e), n.promise;
    };
  },
  function (t, e, n) {
    "use strict";
    var r = n(9).f,
      i = n(33),
      o = n(43),
      a = n(17),
      s = n(42),
      c = n(56),
      u = n(72),
      l = n(108),
      h = n(41),
      p = n(8),
      f = n(27).fastKey,
      d = n(37),
      m = p ? "_s" : "size",
      v = function (t, e) {
        var n,
          r = f(e);
        if ("F" !== r) return t._i[r];
        for (n = t._f; n; n = n.n) if (n.k == e) return n;
      };
    t.exports = {
      getConstructor: function (t, e, n, u) {
        var l = t(function (t, r) {
          s(t, l, e, "_i"),
            (t._t = e),
            (t._i = i(null)),
            (t._f = void 0),
            (t._l = void 0),
            (t[m] = 0),
            null != r && c(r, n, t[u], t);
        });
        return (
          o(l.prototype, {
            clear: function () {
              for (var t = d(this, e), n = t._i, r = t._f; r; r = r.n)
                (r.r = !0), r.p && (r.p = r.p.n = void 0), delete n[r.i];
              (t._f = t._l = void 0), (t[m] = 0);
            },
            delete: function (t) {
              var n = d(this, e),
                r = v(n, t);
              if (r) {
                var i = r.n,
                  o = r.p;
                delete n._i[r.i],
                  (r.r = !0),
                  o && (o.n = i),
                  i && (i.p = o),
                  n._f == r && (n._f = i),
                  n._l == r && (n._l = o),
                  n[m]--;
              }
              return !!r;
            },
            forEach: function (t) {
              d(this, e);
              for (
                var n,
                  r = a(t, arguments.length > 1 ? arguments[1] : void 0, 3);
                (n = n ? n.n : this._f);

              )
                for (r(n.v, n.k, this); n && n.r; ) n = n.p;
            },
            has: function (t) {
              return !!v(d(this, e), t);
            },
          }),
          p &&
            r(l.prototype, "size", {
              get: function () {
                return d(this, e)[m];
              },
            }),
          l
        );
      },
      def: function (t, e, n) {
        var r,
          i,
          o = v(t, e);
        return (
          o
            ? (o.v = n)
            : ((t._l = o =
                {
                  i: (i = f(e, !0)),
                  k: e,
                  v: n,
                  p: (r = t._l),
                  n: void 0,
                  r: !1,
                }),
              t._f || (t._f = o),
              r && (r.n = o),
              t[m]++,
              "F" !== i && (t._i[i] = o)),
          t
        );
      },
      getEntry: v,
      setStrong: function (t, e, n) {
        u(
          t,
          e,
          function (t, n) {
            (this._t = d(t, e)), (this._k = n), (this._l = void 0);
          },
          function () {
            for (var t = this._k, e = this._l; e && e.r; ) e = e.p;
            return this._t && (this._l = e = e ? e.n : this._t._f)
              ? l(0, "keys" == t ? e.k : "values" == t ? e.v : [e.k, e.v])
              : ((this._t = void 0), l(1));
          },
          n ? "entries" : "values",
          !n,
          !0
        ),
          h(e);
      },
    };
  },
  function (t, e, n) {
    "use strict";
    var r = n(43),
      i = n(27).getWeak,
      o = n(3),
      a = n(4),
      s = n(42),
      c = n(56),
      u = n(22),
      l = n(13),
      h = n(37),
      p = u(5),
      f = u(6),
      d = 0,
      m = function (t) {
        return t._l || (t._l = new v());
      },
      v = function () {
        this.a = [];
      },
      g = function (t, e) {
        return p(t.a, function (t) {
          return t[0] === e;
        });
      };
    (v.prototype = {
      get: function (t) {
        var e = g(this, t);
        if (e) return e[1];
      },
      has: function (t) {
        return !!g(this, t);
      },
      set: function (t, e) {
        var n = g(this, t);
        n ? (n[1] = e) : this.a.push([t, e]);
      },
      delete: function (t) {
        var e = f(this.a, function (e) {
          return e[0] === t;
        });
        return ~e && this.a.splice(e, 1), !!~e;
      },
    }),
      (t.exports = {
        getConstructor: function (t, e, n, o) {
          var u = t(function (t, r) {
            s(t, u, e, "_i"),
              (t._t = e),
              (t._i = d++),
              (t._l = void 0),
              null != r && c(r, n, t[o], t);
          });
          return (
            r(u.prototype, {
              delete: function (t) {
                if (!a(t)) return !1;
                var n = i(t);
                return !0 === n
                  ? m(h(this, e)).delete(t)
                  : n && l(n, this._i) && delete n[this._i];
              },
              has: function (t) {
                if (!a(t)) return !1;
                var n = i(t);
                return !0 === n ? m(h(this, e)).has(t) : n && l(n, this._i);
              },
            }),
            u
          );
        },
        def: function (t, e, n) {
          var r = i(o(e), !0);
          return !0 === r ? m(t).set(e, n) : (r[t._i] = n), t;
        },
        ufstore: m,
      });
  },
  function (t, e, n) {
    var r = n(19),
      i = n(6);
    t.exports = function (t) {
      if (void 0 === t) return 0;
      var e = r(t),
        n = i(e);
      if (e !== n) throw RangeError("Wrong length!");
      return n;
    };
  },
  function (t, e, n) {
    var r = n(34),
      i = n(50),
      o = n(3),
      a = n(1).Reflect;
    t.exports =
      (a && a.ownKeys) ||
      function (t) {
        var e = r.f(o(t)),
          n = i.f;
        return n ? e.concat(n(t)) : e;
      };
  },
  function (t, e, n) {
    var r = n(6),
      i = n(68),
      o = n(24);
    t.exports = function (t, e, n, a) {
      var s = String(o(t)),
        c = s.length,
        u = void 0 === n ? " " : String(n),
        l = r(e);
      if (l <= c || "" == u) return s;
      var h = l - c,
        p = i.call(u, Math.ceil(h / u.length));
      return p.length > h && (p = p.slice(0, h)), a ? p + s : s + p;
    };
  },
  function (t, e, n) {
    var r = n(8),
      i = n(31),
      o = n(15),
      a = n(45).f;
    t.exports = function (t) {
      return function (e) {
        for (var n, s = o(e), c = i(s), u = c.length, l = 0, h = []; u > l; )
          (n = c[l++]), (r && !a.call(s, n)) || h.push(t ? [n, s[n]] : s[n]);
        return h;
      };
    };
  },
  function (t, e) {
    var n = (t.exports = { version: "2.6.9" });
    "number" == typeof __e && (__e = n);
  },
  function (t, e) {
    t.exports = function (t) {
      try {
        return !!t();
      } catch (t) {
        return !0;
      }
    };
  },
  function (t, e) {
    function n(t, e, n) {
      var r, i, o, a, s;
      function c() {
        var u = Date.now() - a;
        u < e && u >= 0
          ? (r = setTimeout(c, e - u))
          : ((r = null), n || ((s = t.apply(o, i)), (o = i = null)));
      }
      null == e && (e = 100);
      var u = function () {
        (o = this), (i = arguments), (a = Date.now());
        var u = n && !r;
        return (
          r || (r = setTimeout(c, e)),
          u && ((s = t.apply(o, i)), (o = i = null)),
          s
        );
      };
      return (
        (u.clear = function () {
          r && (clearTimeout(r), (r = null));
        }),
        (u.flush = function () {
          r &&
            ((s = t.apply(o, i)), (o = i = null), clearTimeout(r), (r = null));
        }),
        u
      );
    }
    (n.debounce = n), (t.exports = n);
  },
  function (t, e, n) {
    n(124), (t.exports = n(314));
  },
  function (t, e, n) {
    "use strict";
    n(125);
    var r,
      i = (r = n(297)) && r.__esModule ? r : { default: r };
    i.default._babelPolyfill &&
      "undefined" != typeof console &&
      console.warn &&
      console.warn(
        "@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended and may have consequences if different versions of the polyfills are applied sequentially. If you do need to load the polyfill more than once, use @babel/polyfill/noConflict instead to bypass the warning."
      ),
      (i.default._babelPolyfill = !0);
  },
  function (t, e, n) {
    "use strict";
    n(126),
      n(269),
      n(271),
      n(274),
      n(276),
      n(278),
      n(280),
      n(282),
      n(284),
      n(286),
      n(288),
      n(290),
      n(292),
      n(296);
  },
  function (t, e, n) {
    n(127),
      n(130),
      n(131),
      n(132),
      n(133),
      n(134),
      n(135),
      n(136),
      n(137),
      n(138),
      n(139),
      n(140),
      n(141),
      n(142),
      n(143),
      n(144),
      n(145),
      n(146),
      n(147),
      n(148),
      n(149),
      n(150),
      n(151),
      n(152),
      n(153),
      n(154),
      n(155),
      n(156),
      n(157),
      n(158),
      n(159),
      n(160),
      n(161),
      n(162),
      n(163),
      n(164),
      n(165),
      n(166),
      n(167),
      n(168),
      n(169),
      n(170),
      n(171),
      n(173),
      n(174),
      n(175),
      n(176),
      n(177),
      n(178),
      n(179),
      n(180),
      n(181),
      n(182),
      n(183),
      n(184),
      n(185),
      n(186),
      n(187),
      n(188),
      n(189),
      n(190),
      n(191),
      n(192),
      n(193),
      n(194),
      n(195),
      n(196),
      n(197),
      n(198),
      n(199),
      n(200),
      n(201),
      n(202),
      n(203),
      n(204),
      n(205),
      n(206),
      n(208),
      n(209),
      n(211),
      n(212),
      n(213),
      n(214),
      n(215),
      n(216),
      n(217),
      n(219),
      n(220),
      n(221),
      n(222),
      n(223),
      n(224),
      n(225),
      n(226),
      n(227),
      n(228),
      n(229),
      n(230),
      n(231),
      n(80),
      n(232),
      n(109),
      n(233),
      n(110),
      n(234),
      n(235),
      n(236),
      n(237),
      n(111),
      n(240),
      n(241),
      n(242),
      n(243),
      n(244),
      n(245),
      n(246),
      n(247),
      n(248),
      n(249),
      n(250),
      n(251),
      n(252),
      n(253),
      n(254),
      n(255),
      n(256),
      n(257),
      n(258),
      n(259),
      n(260),
      n(261),
      n(262),
      n(263),
      n(264),
      n(265),
      n(266),
      n(267),
      n(268),
      (t.exports = n(7));
  },
  function (t, e, n) {
    "use strict";
    var r = n(1),
      i = n(13),
      o = n(8),
      a = n(0),
      s = n(11),
      c = n(27).KEY,
      u = n(2),
      l = n(48),
      h = n(38),
      p = n(29),
      f = n(5),
      d = n(61),
      m = n(90),
      v = n(129),
      g = n(51),
      y = n(3),
      x = n(4),
      b = n(10),
      w = n(15),
      _ = n(26),
      M = n(28),
      S = n(33),
      E = n(93),
      T = n(20),
      A = n(50),
      L = n(9),
      P = n(31),
      R = T.f,
      C = L.f,
      O = E.f,
      I = r.Symbol,
      N = r.JSON,
      D = N && N.stringify,
      z = f("_hidden"),
      F = f("toPrimitive"),
      U = {}.propertyIsEnumerable,
      B = l("symbol-registry"),
      G = l("symbols"),
      j = l("op-symbols"),
      V = Object.prototype,
      H = "function" == typeof I && !!A.f,
      k = r.QObject,
      W = !k || !k.prototype || !k.prototype.findChild,
      q =
        o &&
        u(function () {
          return (
            7 !=
            S(
              C({}, "a", {
                get: function () {
                  return C(this, "a", { value: 7 }).a;
                },
              })
            ).a
          );
        })
          ? function (t, e, n) {
              var r = R(V, e);
              r && delete V[e], C(t, e, n), r && t !== V && C(V, e, r);
            }
          : C,
      X = function (t) {
        var e = (G[t] = S(I.prototype));
        return (e._k = t), e;
      },
      Y =
        H && "symbol" == typeof I.iterator
          ? function (t) {
              return "symbol" == typeof t;
            }
          : function (t) {
              return t instanceof I;
            },
      J = function (t, e, n) {
        return (
          t === V && J(j, e, n),
          y(t),
          (e = _(e, !0)),
          y(n),
          i(G, e)
            ? (n.enumerable
                ? (i(t, z) && t[z][e] && (t[z][e] = !1),
                  (n = S(n, { enumerable: M(0, !1) })))
                : (i(t, z) || C(t, z, M(1, {})), (t[z][e] = !0)),
              q(t, e, n))
            : C(t, e, n)
        );
      },
      Z = function (t, e) {
        y(t);
        for (var n, r = v((e = w(e))), i = 0, o = r.length; o > i; )
          J(t, (n = r[i++]), e[n]);
        return t;
      },
      Q = function (t) {
        var e = U.call(this, (t = _(t, !0)));
        return (
          !(this === V && i(G, t) && !i(j, t)) &&
          (!(e || !i(this, t) || !i(G, t) || (i(this, z) && this[z][t])) || e)
        );
      },
      K = function (t, e) {
        if (((t = w(t)), (e = _(e, !0)), t !== V || !i(G, e) || i(j, e))) {
          var n = R(t, e);
          return (
            !n || !i(G, e) || (i(t, z) && t[z][e]) || (n.enumerable = !0), n
          );
        }
      },
      $ = function (t) {
        for (var e, n = O(w(t)), r = [], o = 0; n.length > o; )
          i(G, (e = n[o++])) || e == z || e == c || r.push(e);
        return r;
      },
      tt = function (t) {
        for (
          var e, n = t === V, r = O(n ? j : w(t)), o = [], a = 0;
          r.length > a;

        )
          !i(G, (e = r[a++])) || (n && !i(V, e)) || o.push(G[e]);
        return o;
      };
    H ||
      (s(
        (I = function () {
          if (this instanceof I)
            throw TypeError("Symbol is not a constructor!");
          var t = p(arguments.length > 0 ? arguments[0] : void 0),
            e = function (n) {
              this === V && e.call(j, n),
                i(this, z) && i(this[z], t) && (this[z][t] = !1),
                q(this, t, M(1, n));
            };
          return o && W && q(V, t, { configurable: !0, set: e }), X(t);
        }).prototype,
        "toString",
        function () {
          return this._k;
        }
      ),
      (T.f = K),
      (L.f = J),
      (n(34).f = E.f = $),
      (n(45).f = Q),
      (A.f = tt),
      o && !n(30) && s(V, "propertyIsEnumerable", Q, !0),
      (d.f = function (t) {
        return X(f(t));
      })),
      a(a.G + a.W + a.F * !H, { Symbol: I });
    for (
      var et =
          "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(
            ","
          ),
        nt = 0;
      et.length > nt;

    )
      f(et[nt++]);
    for (var rt = P(f.store), it = 0; rt.length > it; ) m(rt[it++]);
    a(a.S + a.F * !H, "Symbol", {
      for: function (t) {
        return i(B, (t += "")) ? B[t] : (B[t] = I(t));
      },
      keyFor: function (t) {
        if (!Y(t)) throw TypeError(t + " is not a symbol!");
        for (var e in B) if (B[e] === t) return e;
      },
      useSetter: function () {
        W = !0;
      },
      useSimple: function () {
        W = !1;
      },
    }),
      a(a.S + a.F * !H, "Object", {
        create: function (t, e) {
          return void 0 === e ? S(t) : Z(S(t), e);
        },
        defineProperty: J,
        defineProperties: Z,
        getOwnPropertyDescriptor: K,
        getOwnPropertyNames: $,
        getOwnPropertySymbols: tt,
      });
    var ot = u(function () {
      A.f(1);
    });
    a(a.S + a.F * ot, "Object", {
      getOwnPropertySymbols: function (t) {
        return A.f(b(t));
      },
    }),
      N &&
        a(
          a.S +
            a.F *
              (!H ||
                u(function () {
                  var t = I();
                  return (
                    "[null]" != D([t]) ||
                    "{}" != D({ a: t }) ||
                    "{}" != D(Object(t))
                  );
                })),
          "JSON",
          {
            stringify: function (t) {
              for (var e, n, r = [t], i = 1; arguments.length > i; )
                r.push(arguments[i++]);
              if (((n = e = r[1]), (x(e) || void 0 !== t) && !Y(t)))
                return (
                  g(e) ||
                    (e = function (t, e) {
                      if (
                        ("function" == typeof n && (e = n.call(this, t, e)),
                        !Y(e))
                      )
                        return e;
                    }),
                  (r[1] = e),
                  D.apply(N, r)
                );
            },
          }
        ),
      I.prototype[F] || n(14)(I.prototype, F, I.prototype.valueOf),
      h(I, "Symbol"),
      h(Math, "Math", !0),
      h(r.JSON, "JSON", !0);
  },
  function (t, e, n) {
    t.exports = n(48)("native-function-to-string", Function.toString);
  },
  function (t, e, n) {
    var r = n(31),
      i = n(50),
      o = n(45);
    t.exports = function (t) {
      var e = r(t),
        n = i.f;
      if (n)
        for (var a, s = n(t), c = o.f, u = 0; s.length > u; )
          c.call(t, (a = s[u++])) && e.push(a);
      return e;
    };
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S, "Object", { create: n(33) });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S + r.F * !n(8), "Object", { defineProperty: n(9).f });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S + r.F * !n(8), "Object", { defineProperties: n(92) });
  },
  function (t, e, n) {
    var r = n(15),
      i = n(20).f;
    n(21)("getOwnPropertyDescriptor", function () {
      return function (t, e) {
        return i(r(t), e);
      };
    });
  },
  function (t, e, n) {
    var r = n(10),
      i = n(35);
    n(21)("getPrototypeOf", function () {
      return function (t) {
        return i(r(t));
      };
    });
  },
  function (t, e, n) {
    var r = n(10),
      i = n(31);
    n(21)("keys", function () {
      return function (t) {
        return i(r(t));
      };
    });
  },
  function (t, e, n) {
    n(21)("getOwnPropertyNames", function () {
      return n(93).f;
    });
  },
  function (t, e, n) {
    var r = n(4),
      i = n(27).onFreeze;
    n(21)("freeze", function (t) {
      return function (e) {
        return t && r(e) ? t(i(e)) : e;
      };
    });
  },
  function (t, e, n) {
    var r = n(4),
      i = n(27).onFreeze;
    n(21)("seal", function (t) {
      return function (e) {
        return t && r(e) ? t(i(e)) : e;
      };
    });
  },
  function (t, e, n) {
    var r = n(4),
      i = n(27).onFreeze;
    n(21)("preventExtensions", function (t) {
      return function (e) {
        return t && r(e) ? t(i(e)) : e;
      };
    });
  },
  function (t, e, n) {
    var r = n(4);
    n(21)("isFrozen", function (t) {
      return function (e) {
        return !r(e) || (!!t && t(e));
      };
    });
  },
  function (t, e, n) {
    var r = n(4);
    n(21)("isSealed", function (t) {
      return function (e) {
        return !r(e) || (!!t && t(e));
      };
    });
  },
  function (t, e, n) {
    var r = n(4);
    n(21)("isExtensible", function (t) {
      return function (e) {
        return !!r(e) && (!t || t(e));
      };
    });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S + r.F, "Object", { assign: n(94) });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S, "Object", { is: n(95) });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S, "Object", { setPrototypeOf: n(65).set });
  },
  function (t, e, n) {
    "use strict";
    var r = n(46),
      i = {};
    (i[n(5)("toStringTag")] = "z"),
      i + "" != "[object z]" &&
        n(11)(
          Object.prototype,
          "toString",
          function () {
            return "[object " + r(this) + "]";
          },
          !0
        );
  },
  function (t, e, n) {
    var r = n(0);
    r(r.P, "Function", { bind: n(96) });
  },
  function (t, e, n) {
    var r = n(9).f,
      i = Function.prototype,
      o = /^\s*function ([^ (]*)/;
    "name" in i ||
      (n(8) &&
        r(i, "name", {
          configurable: !0,
          get: function () {
            try {
              return ("" + this).match(o)[1];
            } catch (t) {
              return "";
            }
          },
        }));
  },
  function (t, e, n) {
    "use strict";
    var r = n(4),
      i = n(35),
      o = n(5)("hasInstance"),
      a = Function.prototype;
    o in a ||
      n(9).f(a, o, {
        value: function (t) {
          if ("function" != typeof this || !r(t)) return !1;
          if (!r(this.prototype)) return t instanceof this;
          for (; (t = i(t)); ) if (this.prototype === t) return !0;
          return !1;
        },
      });
  },
  function (t, e, n) {
    var r = n(0),
      i = n(98);
    r(r.G + r.F * (parseInt != i), { parseInt: i });
  },
  function (t, e, n) {
    var r = n(0),
      i = n(99);
    r(r.G + r.F * (parseFloat != i), { parseFloat: i });
  },
  function (t, e, n) {
    "use strict";
    var r = n(1),
      i = n(13),
      o = n(23),
      a = n(67),
      s = n(26),
      c = n(2),
      u = n(34).f,
      l = n(20).f,
      h = n(9).f,
      p = n(39).trim,
      f = r.Number,
      d = f,
      m = f.prototype,
      v = "Number" == o(n(33)(m)),
      g = "trim" in String.prototype,
      y = function (t) {
        var e = s(t, !1);
        if ("string" == typeof e && e.length > 2) {
          var n,
            r,
            i,
            o = (e = g ? e.trim() : p(e, 3)).charCodeAt(0);
          if (43 === o || 45 === o) {
            if (88 === (n = e.charCodeAt(2)) || 120 === n) return NaN;
          } else if (48 === o) {
            switch (e.charCodeAt(1)) {
              case 66:
              case 98:
                (r = 2), (i = 49);
                break;
              case 79:
              case 111:
                (r = 8), (i = 55);
                break;
              default:
                return +e;
            }
            for (var a, c = e.slice(2), u = 0, l = c.length; u < l; u++)
              if ((a = c.charCodeAt(u)) < 48 || a > i) return NaN;
            return parseInt(c, r);
          }
        }
        return +e;
      };
    if (!f(" 0o1") || !f("0b1") || f("+0x1")) {
      f = function (t) {
        var e = arguments.length < 1 ? 0 : t,
          n = this;
        return n instanceof f &&
          (v
            ? c(function () {
                m.valueOf.call(n);
              })
            : "Number" != o(n))
          ? a(new d(y(e)), n, f)
          : y(e);
      };
      for (
        var x,
          b = n(8)
            ? u(d)
            : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(
                ","
              ),
          w = 0;
        b.length > w;
        w++
      )
        i(d, (x = b[w])) && !i(f, x) && h(f, x, l(d, x));
      (f.prototype = m), (m.constructor = f), n(11)(r, "Number", f);
    }
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(19),
      o = n(100),
      a = n(68),
      s = (1).toFixed,
      c = Math.floor,
      u = [0, 0, 0, 0, 0, 0],
      l = "Number.toFixed: incorrect invocation!",
      h = function (t, e) {
        for (var n = -1, r = e; ++n < 6; )
          (r += t * u[n]), (u[n] = r % 1e7), (r = c(r / 1e7));
      },
      p = function (t) {
        for (var e = 6, n = 0; --e >= 0; )
          (n += u[e]), (u[e] = c(n / t)), (n = (n % t) * 1e7);
      },
      f = function () {
        for (var t = 6, e = ""; --t >= 0; )
          if ("" !== e || 0 === t || 0 !== u[t]) {
            var n = String(u[t]);
            e = "" === e ? n : e + a.call("0", 7 - n.length) + n;
          }
        return e;
      },
      d = function (t, e, n) {
        return 0 === e
          ? n
          : e % 2 == 1
          ? d(t, e - 1, n * t)
          : d(t * t, e / 2, n);
      };
    r(
      r.P +
        r.F *
          ((!!s &&
            ("0.000" !== (8e-5).toFixed(3) ||
              "1" !== (0.9).toFixed(0) ||
              "1.25" !== (1.255).toFixed(2) ||
              "1000000000000000128" !== (0xde0b6b3a7640080).toFixed(0))) ||
            !n(2)(function () {
              s.call({});
            })),
      "Number",
      {
        toFixed: function (t) {
          var e,
            n,
            r,
            s,
            c = o(this, l),
            u = i(t),
            m = "",
            v = "0";
          if (u < 0 || u > 20) throw RangeError(l);
          if (c != c) return "NaN";
          if (c <= -1e21 || c >= 1e21) return String(c);
          if ((c < 0 && ((m = "-"), (c = -c)), c > 1e-21))
            if (
              ((n =
                (e =
                  (function (t) {
                    for (var e = 0, n = t; n >= 4096; ) (e += 12), (n /= 4096);
                    for (; n >= 2; ) (e += 1), (n /= 2);
                    return e;
                  })(c * d(2, 69, 1)) - 69) < 0
                  ? c * d(2, -e, 1)
                  : c / d(2, e, 1)),
              (n *= 4503599627370496),
              (e = 52 - e) > 0)
            ) {
              for (h(0, n), r = u; r >= 7; ) h(1e7, 0), (r -= 7);
              for (h(d(10, r, 1), 0), r = e - 1; r >= 23; )
                p(1 << 23), (r -= 23);
              p(1 << r), h(1, 1), p(2), (v = f());
            } else h(0, n), h(1 << -e, 0), (v = f() + a.call("0", u));
          return (v =
            u > 0
              ? m +
                ((s = v.length) <= u
                  ? "0." + a.call("0", u - s) + v
                  : v.slice(0, s - u) + "." + v.slice(s - u))
              : m + v);
        },
      }
    );
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(2),
      o = n(100),
      a = (1).toPrecision;
    r(
      r.P +
        r.F *
          (i(function () {
            return "1" !== a.call(1, void 0);
          }) ||
            !i(function () {
              a.call({});
            })),
      "Number",
      {
        toPrecision: function (t) {
          var e = o(this, "Number#toPrecision: incorrect invocation!");
          return void 0 === t ? a.call(e) : a.call(e, t);
        },
      }
    );
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S, "Number", { EPSILON: Math.pow(2, -52) });
  },
  function (t, e, n) {
    var r = n(0),
      i = n(1).isFinite;
    r(r.S, "Number", {
      isFinite: function (t) {
        return "number" == typeof t && i(t);
      },
    });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S, "Number", { isInteger: n(101) });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S, "Number", {
      isNaN: function (t) {
        return t != t;
      },
    });
  },
  function (t, e, n) {
    var r = n(0),
      i = n(101),
      o = Math.abs;
    r(r.S, "Number", {
      isSafeInteger: function (t) {
        return i(t) && o(t) <= 9007199254740991;
      },
    });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S, "Number", { MAX_SAFE_INTEGER: 9007199254740991 });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S, "Number", { MIN_SAFE_INTEGER: -9007199254740991 });
  },
  function (t, e, n) {
    var r = n(0),
      i = n(99);
    r(r.S + r.F * (Number.parseFloat != i), "Number", { parseFloat: i });
  },
  function (t, e, n) {
    var r = n(0),
      i = n(98);
    r(r.S + r.F * (Number.parseInt != i), "Number", { parseInt: i });
  },
  function (t, e, n) {
    var r = n(0),
      i = n(102),
      o = Math.sqrt,
      a = Math.acosh;
    r(
      r.S +
        r.F *
          !(a && 710 == Math.floor(a(Number.MAX_VALUE)) && a(1 / 0) == 1 / 0),
      "Math",
      {
        acosh: function (t) {
          return (t = +t) < 1
            ? NaN
            : t > 94906265.62425156
            ? Math.log(t) + Math.LN2
            : i(t - 1 + o(t - 1) * o(t + 1));
        },
      }
    );
  },
  function (t, e, n) {
    var r = n(0),
      i = Math.asinh;
    r(r.S + r.F * !(i && 1 / i(0) > 0), "Math", {
      asinh: function t(e) {
        return isFinite((e = +e)) && 0 != e
          ? e < 0
            ? -t(-e)
            : Math.log(e + Math.sqrt(e * e + 1))
          : e;
      },
    });
  },
  function (t, e, n) {
    var r = n(0),
      i = Math.atanh;
    r(r.S + r.F * !(i && 1 / i(-0) < 0), "Math", {
      atanh: function (t) {
        return 0 == (t = +t) ? t : Math.log((1 + t) / (1 - t)) / 2;
      },
    });
  },
  function (t, e, n) {
    var r = n(0),
      i = n(69);
    r(r.S, "Math", {
      cbrt: function (t) {
        return i((t = +t)) * Math.pow(Math.abs(t), 1 / 3);
      },
    });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S, "Math", {
      clz32: function (t) {
        return (t >>>= 0)
          ? 31 - Math.floor(Math.log(t + 0.5) * Math.LOG2E)
          : 32;
      },
    });
  },
  function (t, e, n) {
    var r = n(0),
      i = Math.exp;
    r(r.S, "Math", {
      cosh: function (t) {
        return (i((t = +t)) + i(-t)) / 2;
      },
    });
  },
  function (t, e, n) {
    var r = n(0),
      i = n(70);
    r(r.S + r.F * (i != Math.expm1), "Math", { expm1: i });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S, "Math", { fround: n(172) });
  },
  function (t, e, n) {
    var r = n(69),
      i = Math.pow,
      o = i(2, -52),
      a = i(2, -23),
      s = i(2, 127) * (2 - a),
      c = i(2, -126);
    t.exports =
      Math.fround ||
      function (t) {
        var e,
          n,
          i = Math.abs(t),
          u = r(t);
        return i < c
          ? u * (i / c / a + 1 / o - 1 / o) * c * a
          : (n = (e = (1 + a / o) * i) - (e - i)) > s || n != n
          ? u * (1 / 0)
          : u * n;
      };
  },
  function (t, e, n) {
    var r = n(0),
      i = Math.abs;
    r(r.S, "Math", {
      hypot: function (t, e) {
        for (var n, r, o = 0, a = 0, s = arguments.length, c = 0; a < s; )
          c < (n = i(arguments[a++]))
            ? ((o = o * (r = c / n) * r + 1), (c = n))
            : (o += n > 0 ? (r = n / c) * r : n);
        return c === 1 / 0 ? 1 / 0 : c * Math.sqrt(o);
      },
    });
  },
  function (t, e, n) {
    var r = n(0),
      i = Math.imul;
    r(
      r.S +
        r.F *
          n(2)(function () {
            return -5 != i(4294967295, 5) || 2 != i.length;
          }),
      "Math",
      {
        imul: function (t, e) {
          var n = +t,
            r = +e,
            i = 65535 & n,
            o = 65535 & r;
          return (
            0 |
            (i * o +
              ((((65535 & (n >>> 16)) * o + i * (65535 & (r >>> 16))) << 16) >>>
                0))
          );
        },
      }
    );
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S, "Math", {
      log10: function (t) {
        return Math.log(t) * Math.LOG10E;
      },
    });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S, "Math", { log1p: n(102) });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S, "Math", {
      log2: function (t) {
        return Math.log(t) / Math.LN2;
      },
    });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S, "Math", { sign: n(69) });
  },
  function (t, e, n) {
    var r = n(0),
      i = n(70),
      o = Math.exp;
    r(
      r.S +
        r.F *
          n(2)(function () {
            return -2e-17 != !Math.sinh(-2e-17);
          }),
      "Math",
      {
        sinh: function (t) {
          return Math.abs((t = +t)) < 1
            ? (i(t) - i(-t)) / 2
            : (o(t - 1) - o(-t - 1)) * (Math.E / 2);
        },
      }
    );
  },
  function (t, e, n) {
    var r = n(0),
      i = n(70),
      o = Math.exp;
    r(r.S, "Math", {
      tanh: function (t) {
        var e = i((t = +t)),
          n = i(-t);
        return e == 1 / 0 ? 1 : n == 1 / 0 ? -1 : (e - n) / (o(t) + o(-t));
      },
    });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S, "Math", {
      trunc: function (t) {
        return (t > 0 ? Math.floor : Math.ceil)(t);
      },
    });
  },
  function (t, e, n) {
    var r = n(0),
      i = n(32),
      o = String.fromCharCode,
      a = String.fromCodePoint;
    r(r.S + r.F * (!!a && 1 != a.length), "String", {
      fromCodePoint: function (t) {
        for (var e, n = [], r = arguments.length, a = 0; r > a; ) {
          if (((e = +arguments[a++]), i(e, 1114111) !== e))
            throw RangeError(e + " is not a valid code point");
          n.push(
            e < 65536
              ? o(e)
              : o(55296 + ((e -= 65536) >> 10), (e % 1024) + 56320)
          );
        }
        return n.join("");
      },
    });
  },
  function (t, e, n) {
    var r = n(0),
      i = n(15),
      o = n(6);
    r(r.S, "String", {
      raw: function (t) {
        for (
          var e = i(t.raw),
            n = o(e.length),
            r = arguments.length,
            a = [],
            s = 0;
          n > s;

        )
          a.push(String(e[s++])), s < r && a.push(String(arguments[s]));
        return a.join("");
      },
    });
  },
  function (t, e, n) {
    "use strict";
    n(39)("trim", function (t) {
      return function () {
        return t(this, 3);
      };
    });
  },
  function (t, e, n) {
    "use strict";
    var r = n(71)(!0);
    n(72)(
      String,
      "String",
      function (t) {
        (this._t = String(t)), (this._i = 0);
      },
      function () {
        var t,
          e = this._t,
          n = this._i;
        return n >= e.length
          ? { value: void 0, done: !0 }
          : ((t = r(e, n)), (this._i += t.length), { value: t, done: !1 });
      }
    );
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(71)(!1);
    r(r.P, "String", {
      codePointAt: function (t) {
        return i(this, t);
      },
    });
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(6),
      o = n(73),
      a = "".endsWith;
    r(r.P + r.F * n(75)("endsWith"), "String", {
      endsWith: function (t) {
        var e = o(this, t, "endsWith"),
          n = arguments.length > 1 ? arguments[1] : void 0,
          r = i(e.length),
          s = void 0 === n ? r : Math.min(i(n), r),
          c = String(t);
        return a ? a.call(e, c, s) : e.slice(s - c.length, s) === c;
      },
    });
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(73);
    r(r.P + r.F * n(75)("includes"), "String", {
      includes: function (t) {
        return !!~i(this, t, "includes").indexOf(
          t,
          arguments.length > 1 ? arguments[1] : void 0
        );
      },
    });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.P, "String", { repeat: n(68) });
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(6),
      o = n(73),
      a = "".startsWith;
    r(r.P + r.F * n(75)("startsWith"), "String", {
      startsWith: function (t) {
        var e = o(this, t, "startsWith"),
          n = i(
            Math.min(arguments.length > 1 ? arguments[1] : void 0, e.length)
          ),
          r = String(t);
        return a ? a.call(e, r, n) : e.slice(n, n + r.length) === r;
      },
    });
  },
  function (t, e, n) {
    "use strict";
    n(12)("anchor", function (t) {
      return function (e) {
        return t(this, "a", "name", e);
      };
    });
  },
  function (t, e, n) {
    "use strict";
    n(12)("big", function (t) {
      return function () {
        return t(this, "big", "", "");
      };
    });
  },
  function (t, e, n) {
    "use strict";
    n(12)("blink", function (t) {
      return function () {
        return t(this, "blink", "", "");
      };
    });
  },
  function (t, e, n) {
    "use strict";
    n(12)("bold", function (t) {
      return function () {
        return t(this, "b", "", "");
      };
    });
  },
  function (t, e, n) {
    "use strict";
    n(12)("fixed", function (t) {
      return function () {
        return t(this, "tt", "", "");
      };
    });
  },
  function (t, e, n) {
    "use strict";
    n(12)("fontcolor", function (t) {
      return function (e) {
        return t(this, "font", "color", e);
      };
    });
  },
  function (t, e, n) {
    "use strict";
    n(12)("fontsize", function (t) {
      return function (e) {
        return t(this, "font", "size", e);
      };
    });
  },
  function (t, e, n) {
    "use strict";
    n(12)("italics", function (t) {
      return function () {
        return t(this, "i", "", "");
      };
    });
  },
  function (t, e, n) {
    "use strict";
    n(12)("link", function (t) {
      return function (e) {
        return t(this, "a", "href", e);
      };
    });
  },
  function (t, e, n) {
    "use strict";
    n(12)("small", function (t) {
      return function () {
        return t(this, "small", "", "");
      };
    });
  },
  function (t, e, n) {
    "use strict";
    n(12)("strike", function (t) {
      return function () {
        return t(this, "strike", "", "");
      };
    });
  },
  function (t, e, n) {
    "use strict";
    n(12)("sub", function (t) {
      return function () {
        return t(this, "sub", "", "");
      };
    });
  },
  function (t, e, n) {
    "use strict";
    n(12)("sup", function (t) {
      return function () {
        return t(this, "sup", "", "");
      };
    });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S, "Date", {
      now: function () {
        return new Date().getTime();
      },
    });
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(10),
      o = n(26);
    r(
      r.P +
        r.F *
          n(2)(function () {
            return (
              null !== new Date(NaN).toJSON() ||
              1 !==
                Date.prototype.toJSON.call({
                  toISOString: function () {
                    return 1;
                  },
                })
            );
          }),
      "Date",
      {
        toJSON: function (t) {
          var e = i(this),
            n = o(e);
          return "number" != typeof n || isFinite(n) ? e.toISOString() : null;
        },
      }
    );
  },
  function (t, e, n) {
    var r = n(0),
      i = n(207);
    r(r.P + r.F * (Date.prototype.toISOString !== i), "Date", {
      toISOString: i,
    });
  },
  function (t, e, n) {
    "use strict";
    var r = n(2),
      i = Date.prototype.getTime,
      o = Date.prototype.toISOString,
      a = function (t) {
        return t > 9 ? t : "0" + t;
      };
    t.exports =
      r(function () {
        return "0385-07-25T07:06:39.999Z" != o.call(new Date(-5e13 - 1));
      }) ||
      !r(function () {
        o.call(new Date(NaN));
      })
        ? function () {
            if (!isFinite(i.call(this))) throw RangeError("Invalid time value");
            var t = this,
              e = t.getUTCFullYear(),
              n = t.getUTCMilliseconds(),
              r = e < 0 ? "-" : e > 9999 ? "+" : "";
            return (
              r +
              ("00000" + Math.abs(e)).slice(r ? -6 : -4) +
              "-" +
              a(t.getUTCMonth() + 1) +
              "-" +
              a(t.getUTCDate()) +
              "T" +
              a(t.getUTCHours()) +
              ":" +
              a(t.getUTCMinutes()) +
              ":" +
              a(t.getUTCSeconds()) +
              "." +
              (n > 99 ? n : "0" + a(n)) +
              "Z"
            );
          }
        : o;
  },
  function (t, e, n) {
    var r = Date.prototype,
      i = r.toString,
      o = r.getTime;
    new Date(NaN) + "" != "Invalid Date" &&
      n(11)(r, "toString", function () {
        var t = o.call(this);
        return t == t ? i.call(this) : "Invalid Date";
      });
  },
  function (t, e, n) {
    var r = n(5)("toPrimitive"),
      i = Date.prototype;
    r in i || n(14)(i, r, n(210));
  },
  function (t, e, n) {
    "use strict";
    var r = n(3),
      i = n(26);
    t.exports = function (t) {
      if ("string" !== t && "number" !== t && "default" !== t)
        throw TypeError("Incorrect hint");
      return i(r(this), "number" != t);
    };
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S, "Array", { isArray: n(51) });
  },
  function (t, e, n) {
    "use strict";
    var r = n(17),
      i = n(0),
      o = n(10),
      a = n(104),
      s = n(76),
      c = n(6),
      u = n(77),
      l = n(78);
    i(
      i.S +
        i.F *
          !n(52)(function (t) {
            Array.from(t);
          }),
      "Array",
      {
        from: function (t) {
          var e,
            n,
            i,
            h,
            p = o(t),
            f = "function" == typeof this ? this : Array,
            d = arguments.length,
            m = d > 1 ? arguments[1] : void 0,
            v = void 0 !== m,
            g = 0,
            y = l(p);
          if (
            (v && (m = r(m, d > 2 ? arguments[2] : void 0, 2)),
            null == y || (f == Array && s(y)))
          )
            for (n = new f((e = c(p.length))); e > g; g++)
              u(n, g, v ? m(p[g], g) : p[g]);
          else
            for (h = y.call(p), n = new f(); !(i = h.next()).done; g++)
              u(n, g, v ? a(h, m, [i.value, g], !0) : i.value);
          return (n.length = g), n;
        },
      }
    );
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(77);
    r(
      r.S +
        r.F *
          n(2)(function () {
            function t() {}
            return !(Array.of.call(t) instanceof t);
          }),
      "Array",
      {
        of: function () {
          for (
            var t = 0,
              e = arguments.length,
              n = new ("function" == typeof this ? this : Array)(e);
            e > t;

          )
            i(n, t, arguments[t++]);
          return (n.length = e), n;
        },
      }
    );
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(15),
      o = [].join;
    r(r.P + r.F * (n(44) != Object || !n(16)(o)), "Array", {
      join: function (t) {
        return o.call(i(this), void 0 === t ? "," : t);
      },
    });
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(64),
      o = n(23),
      a = n(32),
      s = n(6),
      c = [].slice;
    r(
      r.P +
        r.F *
          n(2)(function () {
            i && c.call(i);
          }),
      "Array",
      {
        slice: function (t, e) {
          var n = s(this.length),
            r = o(this);
          if (((e = void 0 === e ? n : e), "Array" == r))
            return c.call(this, t, e);
          for (
            var i = a(t, n), u = a(e, n), l = s(u - i), h = new Array(l), p = 0;
            p < l;
            p++
          )
            h[p] = "String" == r ? this.charAt(i + p) : this[i + p];
          return h;
        },
      }
    );
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(18),
      o = n(10),
      a = n(2),
      s = [].sort,
      c = [1, 2, 3];
    r(
      r.P +
        r.F *
          (a(function () {
            c.sort(void 0);
          }) ||
            !a(function () {
              c.sort(null);
            }) ||
            !n(16)(s)),
      "Array",
      {
        sort: function (t) {
          return void 0 === t ? s.call(o(this)) : s.call(o(this), i(t));
        },
      }
    );
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(22)(0),
      o = n(16)([].forEach, !0);
    r(r.P + r.F * !o, "Array", {
      forEach: function (t) {
        return i(this, t, arguments[1]);
      },
    });
  },
  function (t, e, n) {
    var r = n(4),
      i = n(51),
      o = n(5)("species");
    t.exports = function (t) {
      var e;
      return (
        i(t) &&
          ("function" != typeof (e = t.constructor) ||
            (e !== Array && !i(e.prototype)) ||
            (e = void 0),
          r(e) && null === (e = e[o]) && (e = void 0)),
        void 0 === e ? Array : e
      );
    };
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(22)(1);
    r(r.P + r.F * !n(16)([].map, !0), "Array", {
      map: function (t) {
        return i(this, t, arguments[1]);
      },
    });
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(22)(2);
    r(r.P + r.F * !n(16)([].filter, !0), "Array", {
      filter: function (t) {
        return i(this, t, arguments[1]);
      },
    });
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(22)(3);
    r(r.P + r.F * !n(16)([].some, !0), "Array", {
      some: function (t) {
        return i(this, t, arguments[1]);
      },
    });
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(22)(4);
    r(r.P + r.F * !n(16)([].every, !0), "Array", {
      every: function (t) {
        return i(this, t, arguments[1]);
      },
    });
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(106);
    r(r.P + r.F * !n(16)([].reduce, !0), "Array", {
      reduce: function (t) {
        return i(this, t, arguments.length, arguments[1], !1);
      },
    });
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(106);
    r(r.P + r.F * !n(16)([].reduceRight, !0), "Array", {
      reduceRight: function (t) {
        return i(this, t, arguments.length, arguments[1], !0);
      },
    });
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(49)(!1),
      o = [].indexOf,
      a = !!o && 1 / [1].indexOf(1, -0) < 0;
    r(r.P + r.F * (a || !n(16)(o)), "Array", {
      indexOf: function (t) {
        return a ? o.apply(this, arguments) || 0 : i(this, t, arguments[1]);
      },
    });
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(15),
      o = n(19),
      a = n(6),
      s = [].lastIndexOf,
      c = !!s && 1 / [1].lastIndexOf(1, -0) < 0;
    r(r.P + r.F * (c || !n(16)(s)), "Array", {
      lastIndexOf: function (t) {
        if (c) return s.apply(this, arguments) || 0;
        var e = i(this),
          n = a(e.length),
          r = n - 1;
        for (
          arguments.length > 1 && (r = Math.min(r, o(arguments[1]))),
            r < 0 && (r = n + r);
          r >= 0;
          r--
        )
          if (r in e && e[r] === t) return r || 0;
        return -1;
      },
    });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.P, "Array", { copyWithin: n(107) }), n(36)("copyWithin");
  },
  function (t, e, n) {
    var r = n(0);
    r(r.P, "Array", { fill: n(79) }), n(36)("fill");
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(22)(5),
      o = !0;
    "find" in [] &&
      Array(1).find(function () {
        o = !1;
      }),
      r(r.P + r.F * o, "Array", {
        find: function (t) {
          return i(this, t, arguments.length > 1 ? arguments[1] : void 0);
        },
      }),
      n(36)("find");
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(22)(6),
      o = "findIndex",
      a = !0;
    o in [] &&
      Array(1)[o](function () {
        a = !1;
      }),
      r(r.P + r.F * a, "Array", {
        findIndex: function (t) {
          return i(this, t, arguments.length > 1 ? arguments[1] : void 0);
        },
      }),
      n(36)(o);
  },
  function (t, e, n) {
    n(41)("Array");
  },
  function (t, e, n) {
    var r = n(1),
      i = n(67),
      o = n(9).f,
      a = n(34).f,
      s = n(74),
      c = n(53),
      u = r.RegExp,
      l = u,
      h = u.prototype,
      p = /a/g,
      f = /a/g,
      d = new u(p) !== p;
    if (
      n(8) &&
      (!d ||
        n(2)(function () {
          return (
            (f[n(5)("match")] = !1),
            u(p) != p || u(f) == f || "/a/i" != u(p, "i")
          );
        }))
    ) {
      u = function (t, e) {
        var n = this instanceof u,
          r = s(t),
          o = void 0 === e;
        return !n && r && t.constructor === u && o
          ? t
          : i(
              d
                ? new l(r && !o ? t.source : t, e)
                : l(
                    (r = t instanceof u) ? t.source : t,
                    r && o ? c.call(t) : e
                  ),
              n ? this : h,
              u
            );
      };
      for (
        var m = function (t) {
            (t in u) ||
              o(u, t, {
                configurable: !0,
                get: function () {
                  return l[t];
                },
                set: function (e) {
                  l[t] = e;
                },
              });
          },
          v = a(l),
          g = 0;
        v.length > g;

      )
        m(v[g++]);
      (h.constructor = u), (u.prototype = h), n(11)(r, "RegExp", u);
    }
    n(41)("RegExp");
  },
  function (t, e, n) {
    "use strict";
    n(110);
    var r = n(3),
      i = n(53),
      o = n(8),
      a = /./.toString,
      s = function (t) {
        n(11)(RegExp.prototype, "toString", t, !0);
      };
    n(2)(function () {
      return "/a/b" != a.call({ source: "a", flags: "b" });
    })
      ? s(function () {
          var t = r(this);
          return "/".concat(
            t.source,
            "/",
            "flags" in t
              ? t.flags
              : !o && t instanceof RegExp
              ? i.call(t)
              : void 0
          );
        })
      : "toString" != a.name &&
        s(function () {
          return a.call(this);
        });
  },
  function (t, e, n) {
    "use strict";
    var r = n(3),
      i = n(6),
      o = n(82),
      a = n(54);
    n(55)("match", 1, function (t, e, n, s) {
      return [
        function (n) {
          var r = t(this),
            i = null == n ? void 0 : n[e];
          return void 0 !== i ? i.call(n, r) : new RegExp(n)[e](String(r));
        },
        function (t) {
          var e = s(n, t, this);
          if (e.done) return e.value;
          var c = r(t),
            u = String(this);
          if (!c.global) return a(c, u);
          var l = c.unicode;
          c.lastIndex = 0;
          for (var h, p = [], f = 0; null !== (h = a(c, u)); ) {
            var d = String(h[0]);
            (p[f] = d),
              "" === d && (c.lastIndex = o(u, i(c.lastIndex), l)),
              f++;
          }
          return 0 === f ? null : p;
        },
      ];
    });
  },
  function (t, e, n) {
    "use strict";
    var r = n(3),
      i = n(10),
      o = n(6),
      a = n(19),
      s = n(82),
      c = n(54),
      u = Math.max,
      l = Math.min,
      h = Math.floor,
      p = /\$([$&`']|\d\d?|<[^>]*>)/g,
      f = /\$([$&`']|\d\d?)/g;
    n(55)("replace", 2, function (t, e, n, d) {
      return [
        function (r, i) {
          var o = t(this),
            a = null == r ? void 0 : r[e];
          return void 0 !== a ? a.call(r, o, i) : n.call(String(o), r, i);
        },
        function (t, e) {
          var i = d(n, t, this, e);
          if (i.done) return i.value;
          var h = r(t),
            p = String(this),
            f = "function" == typeof e;
          f || (e = String(e));
          var v = h.global;
          if (v) {
            var g = h.unicode;
            h.lastIndex = 0;
          }
          for (var y = []; ; ) {
            var x = c(h, p);
            if (null === x) break;
            if ((y.push(x), !v)) break;
            "" === String(x[0]) && (h.lastIndex = s(p, o(h.lastIndex), g));
          }
          for (var b, w = "", _ = 0, M = 0; M < y.length; M++) {
            x = y[M];
            for (
              var S = String(x[0]),
                E = u(l(a(x.index), p.length), 0),
                T = [],
                A = 1;
              A < x.length;
              A++
            )
              T.push(void 0 === (b = x[A]) ? b : String(b));
            var L = x.groups;
            if (f) {
              var P = [S].concat(T, E, p);
              void 0 !== L && P.push(L);
              var R = String(e.apply(void 0, P));
            } else R = m(S, p, E, T, L, e);
            E >= _ && ((w += p.slice(_, E) + R), (_ = E + S.length));
          }
          return w + p.slice(_);
        },
      ];
      function m(t, e, r, o, a, s) {
        var c = r + t.length,
          u = o.length,
          l = f;
        return (
          void 0 !== a && ((a = i(a)), (l = p)),
          n.call(s, l, function (n, i) {
            var s;
            switch (i.charAt(0)) {
              case "$":
                return "$";
              case "&":
                return t;
              case "`":
                return e.slice(0, r);
              case "'":
                return e.slice(c);
              case "<":
                s = a[i.slice(1, -1)];
                break;
              default:
                var l = +i;
                if (0 === l) return n;
                if (l > u) {
                  var p = h(l / 10);
                  return 0 === p
                    ? n
                    : p <= u
                    ? void 0 === o[p - 1]
                      ? i.charAt(1)
                      : o[p - 1] + i.charAt(1)
                    : n;
                }
                s = o[l - 1];
            }
            return void 0 === s ? "" : s;
          })
        );
      }
    });
  },
  function (t, e, n) {
    "use strict";
    var r = n(3),
      i = n(95),
      o = n(54);
    n(55)("search", 1, function (t, e, n, a) {
      return [
        function (n) {
          var r = t(this),
            i = null == n ? void 0 : n[e];
          return void 0 !== i ? i.call(n, r) : new RegExp(n)[e](String(r));
        },
        function (t) {
          var e = a(n, t, this);
          if (e.done) return e.value;
          var s = r(t),
            c = String(this),
            u = s.lastIndex;
          i(u, 0) || (s.lastIndex = 0);
          var l = o(s, c);
          return (
            i(s.lastIndex, u) || (s.lastIndex = u), null === l ? -1 : l.index
          );
        },
      ];
    });
  },
  function (t, e, n) {
    "use strict";
    var r = n(74),
      i = n(3),
      o = n(47),
      a = n(82),
      s = n(6),
      c = n(54),
      u = n(81),
      l = n(2),
      h = Math.min,
      p = [].push,
      f = !l(function () {
        RegExp(4294967295, "y");
      });
    n(55)("split", 2, function (t, e, n, l) {
      var d;
      return (
        (d =
          "c" == "abbc".split(/(b)*/)[1] ||
          4 != "test".split(/(?:)/, -1).length ||
          2 != "ab".split(/(?:ab)*/).length ||
          4 != ".".split(/(.?)(.?)/).length ||
          ".".split(/()()/).length > 1 ||
          "".split(/.?/).length
            ? function (t, e) {
                var i = String(this);
                if (void 0 === t && 0 === e) return [];
                if (!r(t)) return n.call(i, t, e);
                for (
                  var o,
                    a,
                    s,
                    c = [],
                    l =
                      (t.ignoreCase ? "i" : "") +
                      (t.multiline ? "m" : "") +
                      (t.unicode ? "u" : "") +
                      (t.sticky ? "y" : ""),
                    h = 0,
                    f = void 0 === e ? 4294967295 : e >>> 0,
                    d = new RegExp(t.source, l + "g");
                  (o = u.call(d, i)) &&
                  !(
                    (a = d.lastIndex) > h &&
                    (c.push(i.slice(h, o.index)),
                    o.length > 1 &&
                      o.index < i.length &&
                      p.apply(c, o.slice(1)),
                    (s = o[0].length),
                    (h = a),
                    c.length >= f)
                  );

                )
                  d.lastIndex === o.index && d.lastIndex++;
                return (
                  h === i.length
                    ? (!s && d.test("")) || c.push("")
                    : c.push(i.slice(h)),
                  c.length > f ? c.slice(0, f) : c
                );
              }
            : "0".split(void 0, 0).length
            ? function (t, e) {
                return void 0 === t && 0 === e ? [] : n.call(this, t, e);
              }
            : n),
        [
          function (n, r) {
            var i = t(this),
              o = null == n ? void 0 : n[e];
            return void 0 !== o ? o.call(n, i, r) : d.call(String(i), n, r);
          },
          function (t, e) {
            var r = l(d, t, this, e, d !== n);
            if (r.done) return r.value;
            var u = i(t),
              p = String(this),
              m = o(u, RegExp),
              v = u.unicode,
              g =
                (u.ignoreCase ? "i" : "") +
                (u.multiline ? "m" : "") +
                (u.unicode ? "u" : "") +
                (f ? "y" : "g"),
              y = new m(f ? u : "^(?:" + u.source + ")", g),
              x = void 0 === e ? 4294967295 : e >>> 0;
            if (0 === x) return [];
            if (0 === p.length) return null === c(y, p) ? [p] : [];
            for (var b = 0, w = 0, _ = []; w < p.length; ) {
              y.lastIndex = f ? w : 0;
              var M,
                S = c(y, f ? p : p.slice(w));
              if (
                null === S ||
                (M = h(s(y.lastIndex + (f ? 0 : w)), p.length)) === b
              )
                w = a(p, w, v);
              else {
                if ((_.push(p.slice(b, w)), _.length === x)) return _;
                for (var E = 1; E <= S.length - 1; E++)
                  if ((_.push(S[E]), _.length === x)) return _;
                w = b = M;
              }
            }
            return _.push(p.slice(b)), _;
          },
        ]
      );
    });
  },
  function (t, e, n) {
    var r = n(1),
      i = n(83).set,
      o = r.MutationObserver || r.WebKitMutationObserver,
      a = r.process,
      s = r.Promise,
      c = "process" == n(23)(a);
    t.exports = function () {
      var t,
        e,
        n,
        u = function () {
          var r, i;
          for (c && (r = a.domain) && r.exit(); t; ) {
            (i = t.fn), (t = t.next);
            try {
              i();
            } catch (r) {
              throw (t ? n() : (e = void 0), r);
            }
          }
          (e = void 0), r && r.enter();
        };
      if (c)
        n = function () {
          a.nextTick(u);
        };
      else if (!o || (r.navigator && r.navigator.standalone))
        if (s && s.resolve) {
          var l = s.resolve(void 0);
          n = function () {
            l.then(u);
          };
        } else
          n = function () {
            i.call(r, u);
          };
      else {
        var h = !0,
          p = document.createTextNode("");
        new o(u).observe(p, { characterData: !0 }),
          (n = function () {
            p.data = h = !h;
          });
      }
      return function (r) {
        var i = { fn: r, next: void 0 };
        e && (e.next = i), t || ((t = i), n()), (e = i);
      };
    };
  },
  function (t, e) {
    t.exports = function (t) {
      try {
        return { e: !1, v: t() };
      } catch (t) {
        return { e: !0, v: t };
      }
    };
  },
  function (t, e, n) {
    "use strict";
    var r = n(114),
      i = n(37);
    t.exports = n(58)(
      "Map",
      function (t) {
        return function () {
          return t(this, arguments.length > 0 ? arguments[0] : void 0);
        };
      },
      {
        get: function (t) {
          var e = r.getEntry(i(this, "Map"), t);
          return e && e.v;
        },
        set: function (t, e) {
          return r.def(i(this, "Map"), 0 === t ? 0 : t, e);
        },
      },
      r,
      !0
    );
  },
  function (t, e, n) {
    "use strict";
    var r = n(114),
      i = n(37);
    t.exports = n(58)(
      "Set",
      function (t) {
        return function () {
          return t(this, arguments.length > 0 ? arguments[0] : void 0);
        };
      },
      {
        add: function (t) {
          return r.def(i(this, "Set"), (t = 0 === t ? 0 : t), t);
        },
      },
      r
    );
  },
  function (t, e, n) {
    "use strict";
    var r,
      i = n(1),
      o = n(22)(0),
      a = n(11),
      s = n(27),
      c = n(94),
      u = n(115),
      l = n(4),
      h = n(37),
      p = n(37),
      f = !i.ActiveXObject && "ActiveXObject" in i,
      d = s.getWeak,
      m = Object.isExtensible,
      v = u.ufstore,
      g = function (t) {
        return function () {
          return t(this, arguments.length > 0 ? arguments[0] : void 0);
        };
      },
      y = {
        get: function (t) {
          if (l(t)) {
            var e = d(t);
            return !0 === e
              ? v(h(this, "WeakMap")).get(t)
              : e
              ? e[this._i]
              : void 0;
          }
        },
        set: function (t, e) {
          return u.def(h(this, "WeakMap"), t, e);
        },
      },
      x = (t.exports = n(58)("WeakMap", g, y, u, !0, !0));
    p &&
      f &&
      (c((r = u.getConstructor(g, "WeakMap")).prototype, y),
      (s.NEED = !0),
      o(["delete", "has", "get", "set"], function (t) {
        var e = x.prototype,
          n = e[t];
        a(e, t, function (e, i) {
          if (l(e) && !m(e)) {
            this._f || (this._f = new r());
            var o = this._f[t](e, i);
            return "set" == t ? this : o;
          }
          return n.call(this, e, i);
        });
      }));
  },
  function (t, e, n) {
    "use strict";
    var r = n(115),
      i = n(37);
    n(58)(
      "WeakSet",
      function (t) {
        return function () {
          return t(this, arguments.length > 0 ? arguments[0] : void 0);
        };
      },
      {
        add: function (t) {
          return r.def(i(this, "WeakSet"), t, !0);
        },
      },
      r,
      !1,
      !0
    );
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(59),
      o = n(84),
      a = n(3),
      s = n(32),
      c = n(6),
      u = n(4),
      l = n(1).ArrayBuffer,
      h = n(47),
      p = o.ArrayBuffer,
      f = o.DataView,
      d = i.ABV && l.isView,
      m = p.prototype.slice,
      v = i.VIEW;
    r(r.G + r.W + r.F * (l !== p), { ArrayBuffer: p }),
      r(r.S + r.F * !i.CONSTR, "ArrayBuffer", {
        isView: function (t) {
          return (d && d(t)) || (u(t) && v in t);
        },
      }),
      r(
        r.P +
          r.U +
          r.F *
            n(2)(function () {
              return !new p(2).slice(1, void 0).byteLength;
            }),
        "ArrayBuffer",
        {
          slice: function (t, e) {
            if (void 0 !== m && void 0 === e) return m.call(a(this), t);
            for (
              var n = a(this).byteLength,
                r = s(t, n),
                i = s(void 0 === e ? n : e, n),
                o = new (h(this, p))(c(i - r)),
                u = new f(this),
                l = new f(o),
                d = 0;
              r < i;

            )
              l.setUint8(d++, u.getUint8(r++));
            return o;
          },
        }
      ),
      n(41)("ArrayBuffer");
  },
  function (t, e, n) {
    var r = n(0);
    r(r.G + r.W + r.F * !n(59).ABV, { DataView: n(84).DataView });
  },
  function (t, e, n) {
    n(25)("Int8", 1, function (t) {
      return function (e, n, r) {
        return t(this, e, n, r);
      };
    });
  },
  function (t, e, n) {
    n(25)("Uint8", 1, function (t) {
      return function (e, n, r) {
        return t(this, e, n, r);
      };
    });
  },
  function (t, e, n) {
    n(25)(
      "Uint8",
      1,
      function (t) {
        return function (e, n, r) {
          return t(this, e, n, r);
        };
      },
      !0
    );
  },
  function (t, e, n) {
    n(25)("Int16", 2, function (t) {
      return function (e, n, r) {
        return t(this, e, n, r);
      };
    });
  },
  function (t, e, n) {
    n(25)("Uint16", 2, function (t) {
      return function (e, n, r) {
        return t(this, e, n, r);
      };
    });
  },
  function (t, e, n) {
    n(25)("Int32", 4, function (t) {
      return function (e, n, r) {
        return t(this, e, n, r);
      };
    });
  },
  function (t, e, n) {
    n(25)("Uint32", 4, function (t) {
      return function (e, n, r) {
        return t(this, e, n, r);
      };
    });
  },
  function (t, e, n) {
    n(25)("Float32", 4, function (t) {
      return function (e, n, r) {
        return t(this, e, n, r);
      };
    });
  },
  function (t, e, n) {
    n(25)("Float64", 8, function (t) {
      return function (e, n, r) {
        return t(this, e, n, r);
      };
    });
  },
  function (t, e, n) {
    var r = n(0),
      i = n(18),
      o = n(3),
      a = (n(1).Reflect || {}).apply,
      s = Function.apply;
    r(
      r.S +
        r.F *
          !n(2)(function () {
            a(function () {});
          }),
      "Reflect",
      {
        apply: function (t, e, n) {
          var r = i(t),
            c = o(n);
          return a ? a(r, e, c) : s.call(r, e, c);
        },
      }
    );
  },
  function (t, e, n) {
    var r = n(0),
      i = n(33),
      o = n(18),
      a = n(3),
      s = n(4),
      c = n(2),
      u = n(96),
      l = (n(1).Reflect || {}).construct,
      h = c(function () {
        function t() {}
        return !(l(function () {}, [], t) instanceof t);
      }),
      p = !c(function () {
        l(function () {});
      });
    r(r.S + r.F * (h || p), "Reflect", {
      construct: function (t, e) {
        o(t), a(e);
        var n = arguments.length < 3 ? t : o(arguments[2]);
        if (p && !h) return l(t, e, n);
        if (t == n) {
          switch (e.length) {
            case 0:
              return new t();
            case 1:
              return new t(e[0]);
            case 2:
              return new t(e[0], e[1]);
            case 3:
              return new t(e[0], e[1], e[2]);
            case 4:
              return new t(e[0], e[1], e[2], e[3]);
          }
          var r = [null];
          return r.push.apply(r, e), new (u.apply(t, r))();
        }
        var c = n.prototype,
          f = i(s(c) ? c : Object.prototype),
          d = Function.apply.call(t, f, e);
        return s(d) ? d : f;
      },
    });
  },
  function (t, e, n) {
    var r = n(9),
      i = n(0),
      o = n(3),
      a = n(26);
    i(
      i.S +
        i.F *
          n(2)(function () {
            Reflect.defineProperty(r.f({}, 1, { value: 1 }), 1, { value: 2 });
          }),
      "Reflect",
      {
        defineProperty: function (t, e, n) {
          o(t), (e = a(e, !0)), o(n);
          try {
            return r.f(t, e, n), !0;
          } catch (t) {
            return !1;
          }
        },
      }
    );
  },
  function (t, e, n) {
    var r = n(0),
      i = n(20).f,
      o = n(3);
    r(r.S, "Reflect", {
      deleteProperty: function (t, e) {
        var n = i(o(t), e);
        return !(n && !n.configurable) && delete t[e];
      },
    });
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(3),
      o = function (t) {
        (this._t = i(t)), (this._i = 0);
        var e,
          n = (this._k = []);
        for (e in t) n.push(e);
      };
    n(103)(o, "Object", function () {
      var t,
        e = this._k;
      do {
        if (this._i >= e.length) return { value: void 0, done: !0 };
      } while (!((t = e[this._i++]) in this._t));
      return { value: t, done: !1 };
    }),
      r(r.S, "Reflect", {
        enumerate: function (t) {
          return new o(t);
        },
      });
  },
  function (t, e, n) {
    var r = n(20),
      i = n(35),
      o = n(13),
      a = n(0),
      s = n(4),
      c = n(3);
    a(a.S, "Reflect", {
      get: function t(e, n) {
        var a,
          u,
          l = arguments.length < 3 ? e : arguments[2];
        return c(e) === l
          ? e[n]
          : (a = r.f(e, n))
          ? o(a, "value")
            ? a.value
            : void 0 !== a.get
            ? a.get.call(l)
            : void 0
          : s((u = i(e)))
          ? t(u, n, l)
          : void 0;
      },
    });
  },
  function (t, e, n) {
    var r = n(20),
      i = n(0),
      o = n(3);
    i(i.S, "Reflect", {
      getOwnPropertyDescriptor: function (t, e) {
        return r.f(o(t), e);
      },
    });
  },
  function (t, e, n) {
    var r = n(0),
      i = n(35),
      o = n(3);
    r(r.S, "Reflect", {
      getPrototypeOf: function (t) {
        return i(o(t));
      },
    });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S, "Reflect", {
      has: function (t, e) {
        return e in t;
      },
    });
  },
  function (t, e, n) {
    var r = n(0),
      i = n(3),
      o = Object.isExtensible;
    r(r.S, "Reflect", {
      isExtensible: function (t) {
        return i(t), !o || o(t);
      },
    });
  },
  function (t, e, n) {
    var r = n(0);
    r(r.S, "Reflect", { ownKeys: n(117) });
  },
  function (t, e, n) {
    var r = n(0),
      i = n(3),
      o = Object.preventExtensions;
    r(r.S, "Reflect", {
      preventExtensions: function (t) {
        i(t);
        try {
          return o && o(t), !0;
        } catch (t) {
          return !1;
        }
      },
    });
  },
  function (t, e, n) {
    var r = n(9),
      i = n(20),
      o = n(35),
      a = n(13),
      s = n(0),
      c = n(28),
      u = n(3),
      l = n(4);
    s(s.S, "Reflect", {
      set: function t(e, n, s) {
        var h,
          p,
          f = arguments.length < 4 ? e : arguments[3],
          d = i.f(u(e), n);
        if (!d) {
          if (l((p = o(e)))) return t(p, n, s, f);
          d = c(0);
        }
        if (a(d, "value")) {
          if (!1 === d.writable || !l(f)) return !1;
          if ((h = i.f(f, n))) {
            if (h.get || h.set || !1 === h.writable) return !1;
            (h.value = s), r.f(f, n, h);
          } else r.f(f, n, c(0, s));
          return !0;
        }
        return void 0 !== d.set && (d.set.call(f, s), !0);
      },
    });
  },
  function (t, e, n) {
    var r = n(0),
      i = n(65);
    i &&
      r(r.S, "Reflect", {
        setPrototypeOf: function (t, e) {
          i.check(t, e);
          try {
            return i.set(t, e), !0;
          } catch (t) {
            return !1;
          }
        },
      });
  },
  function (t, e, n) {
    n(270), (t.exports = n(7).Array.includes);
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(49)(!0);
    r(r.P, "Array", {
      includes: function (t) {
        return i(this, t, arguments.length > 1 ? arguments[1] : void 0);
      },
    }),
      n(36)("includes");
  },
  function (t, e, n) {
    n(272), (t.exports = n(7).Array.flatMap);
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(273),
      o = n(10),
      a = n(6),
      s = n(18),
      c = n(105);
    r(r.P, "Array", {
      flatMap: function (t) {
        var e,
          n,
          r = o(this);
        return (
          s(t),
          (e = a(r.length)),
          (n = c(r, 0)),
          i(n, r, r, e, 0, 1, t, arguments[1]),
          n
        );
      },
    }),
      n(36)("flatMap");
  },
  function (t, e, n) {
    "use strict";
    var r = n(51),
      i = n(4),
      o = n(6),
      a = n(17),
      s = n(5)("isConcatSpreadable");
    t.exports = function t(e, n, c, u, l, h, p, f) {
      for (var d, m, v = l, g = 0, y = !!p && a(p, f, 3); g < u; ) {
        if (g in c) {
          if (
            ((d = y ? y(c[g], g, n) : c[g]),
            (m = !1),
            i(d) && (m = void 0 !== (m = d[s]) ? !!m : r(d)),
            m && h > 0)
          )
            v = t(e, n, d, o(d.length), v, h - 1) - 1;
          else {
            if (v >= 9007199254740991) throw TypeError();
            e[v] = d;
          }
          v++;
        }
        g++;
      }
      return v;
    };
  },
  function (t, e, n) {
    n(275), (t.exports = n(7).String.padStart);
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(118),
      o = n(57),
      a = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(o);
    r(r.P + r.F * a, "String", {
      padStart: function (t) {
        return i(this, t, arguments.length > 1 ? arguments[1] : void 0, !0);
      },
    });
  },
  function (t, e, n) {
    n(277), (t.exports = n(7).String.padEnd);
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(118),
      o = n(57),
      a = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(o);
    r(r.P + r.F * a, "String", {
      padEnd: function (t) {
        return i(this, t, arguments.length > 1 ? arguments[1] : void 0, !1);
      },
    });
  },
  function (t, e, n) {
    n(279), (t.exports = n(7).String.trimLeft);
  },
  function (t, e, n) {
    "use strict";
    n(39)(
      "trimLeft",
      function (t) {
        return function () {
          return t(this, 1);
        };
      },
      "trimStart"
    );
  },
  function (t, e, n) {
    n(281), (t.exports = n(7).String.trimRight);
  },
  function (t, e, n) {
    "use strict";
    n(39)(
      "trimRight",
      function (t) {
        return function () {
          return t(this, 2);
        };
      },
      "trimEnd"
    );
  },
  function (t, e, n) {
    n(283), (t.exports = n(61).f("asyncIterator"));
  },
  function (t, e, n) {
    n(90)("asyncIterator");
  },
  function (t, e, n) {
    n(285), (t.exports = n(7).Object.getOwnPropertyDescriptors);
  },
  function (t, e, n) {
    var r = n(0),
      i = n(117),
      o = n(15),
      a = n(20),
      s = n(77);
    r(r.S, "Object", {
      getOwnPropertyDescriptors: function (t) {
        for (
          var e, n, r = o(t), c = a.f, u = i(r), l = {}, h = 0;
          u.length > h;

        )
          void 0 !== (n = c(r, (e = u[h++]))) && s(l, e, n);
        return l;
      },
    });
  },
  function (t, e, n) {
    n(287), (t.exports = n(7).Object.values);
  },
  function (t, e, n) {
    var r = n(0),
      i = n(119)(!1);
    r(r.S, "Object", {
      values: function (t) {
        return i(t);
      },
    });
  },
  function (t, e, n) {
    n(289), (t.exports = n(7).Object.entries);
  },
  function (t, e, n) {
    var r = n(0),
      i = n(119)(!0);
    r(r.S, "Object", {
      entries: function (t) {
        return i(t);
      },
    });
  },
  function (t, e, n) {
    "use strict";
    n(111), n(291), (t.exports = n(7).Promise.finally);
  },
  function (t, e, n) {
    "use strict";
    var r = n(0),
      i = n(7),
      o = n(1),
      a = n(47),
      s = n(113);
    r(r.P + r.R, "Promise", {
      finally: function (t) {
        var e = a(this, i.Promise || o.Promise),
          n = "function" == typeof t;
        return this.then(
          n
            ? function (n) {
                return s(e, t()).then(function () {
                  return n;
                });
              }
            : t,
          n
            ? function (n) {
                return s(e, t()).then(function () {
                  throw n;
                });
              }
            : t
        );
      },
    });
  },
  function (t, e, n) {
    n(293), n(294), n(295), (t.exports = n(7));
  },
  function (t, e, n) {
    var r = n(1),
      i = n(0),
      o = n(57),
      a = [].slice,
      s = /MSIE .\./.test(o),
      c = function (t) {
        return function (e, n) {
          var r = arguments.length > 2,
            i = !!r && a.call(arguments, 2);
          return t(
            r
              ? function () {
                  ("function" == typeof e ? e : Function(e)).apply(this, i);
                }
              : e,
            n
          );
        };
      };
    i(i.G + i.B + i.F * s, {
      setTimeout: c(r.setTimeout),
      setInterval: c(r.setInterval),
    });
  },
  function (t, e, n) {
    var r = n(0),
      i = n(83);
    r(r.G + r.B, { setImmediate: i.set, clearImmediate: i.clear });
  },
  function (t, e, n) {
    for (
      var r = n(80),
        i = n(31),
        o = n(11),
        a = n(1),
        s = n(14),
        c = n(40),
        u = n(5),
        l = u("iterator"),
        h = u("toStringTag"),
        p = c.Array,
        f = {
          CSSRuleList: !0,
          CSSStyleDeclaration: !1,
          CSSValueList: !1,
          ClientRectList: !1,
          DOMRectList: !1,
          DOMStringList: !1,
          DOMTokenList: !0,
          DataTransferItemList: !1,
          FileList: !1,
          HTMLAllCollection: !1,
          HTMLCollection: !1,
          HTMLFormElement: !1,
          HTMLSelectElement: !1,
          MediaList: !0,
          MimeTypeArray: !1,
          NamedNodeMap: !1,
          NodeList: !0,
          PaintRequestList: !1,
          Plugin: !1,
          PluginArray: !1,
          SVGLengthList: !1,
          SVGNumberList: !1,
          SVGPathSegList: !1,
          SVGPointList: !1,
          SVGStringList: !1,
          SVGTransformList: !1,
          SourceBufferList: !1,
          StyleSheetList: !0,
          TextTrackCueList: !1,
          TextTrackList: !1,
          TouchList: !1,
        },
        d = i(f),
        m = 0;
      m < d.length;
      m++
    ) {
      var v,
        g = d[m],
        y = f[g],
        x = a[g],
        b = x && x.prototype;
      if (b && (b[l] || s(b, l, p), b[h] || s(b, h, g), (c[g] = p), y))
        for (v in r) b[v] || o(b, v, r[v], !0);
    }
  },
  function (t, e, n) {
    var r = (function (t) {
      "use strict";
      var e,
        n = Object.prototype,
        r = n.hasOwnProperty,
        i = "function" == typeof Symbol ? Symbol : {},
        o = i.iterator || "@@iterator",
        a = i.asyncIterator || "@@asyncIterator",
        s = i.toStringTag || "@@toStringTag";
      function c(t, e, n, r) {
        var i = e && e.prototype instanceof m ? e : m,
          o = Object.create(i.prototype),
          a = new A(r || []);
        return (
          (o._invoke = (function (t, e, n) {
            var r = l;
            return function (i, o) {
              if (r === p) throw new Error("Generator is already running");
              if (r === f) {
                if ("throw" === i) throw o;
                return P();
              }
              for (n.method = i, n.arg = o; ; ) {
                var a = n.delegate;
                if (a) {
                  var s = S(a, n);
                  if (s) {
                    if (s === d) continue;
                    return s;
                  }
                }
                if ("next" === n.method) n.sent = n._sent = n.arg;
                else if ("throw" === n.method) {
                  if (r === l) throw ((r = f), n.arg);
                  n.dispatchException(n.arg);
                } else "return" === n.method && n.abrupt("return", n.arg);
                r = p;
                var c = u(t, e, n);
                if ("normal" === c.type) {
                  if (((r = n.done ? f : h), c.arg === d)) continue;
                  return { value: c.arg, done: n.done };
                }
                "throw" === c.type &&
                  ((r = f), (n.method = "throw"), (n.arg = c.arg));
              }
            };
          })(t, n, a)),
          o
        );
      }
      function u(t, e, n) {
        try {
          return { type: "normal", arg: t.call(e, n) };
        } catch (t) {
          return { type: "throw", arg: t };
        }
      }
      t.wrap = c;
      var l = "suspendedStart",
        h = "suspendedYield",
        p = "executing",
        f = "completed",
        d = {};
      function m() {}
      function v() {}
      function g() {}
      var y = {};
      y[o] = function () {
        return this;
      };
      var x = Object.getPrototypeOf,
        b = x && x(x(L([])));
      b && b !== n && r.call(b, o) && (y = b);
      var w = (g.prototype = m.prototype = Object.create(y));
      function _(t) {
        ["next", "throw", "return"].forEach(function (e) {
          t[e] = function (t) {
            return this._invoke(e, t);
          };
        });
      }
      function M(t) {
        var e;
        this._invoke = function (n, i) {
          function o() {
            return new Promise(function (e, o) {
              !(function e(n, i, o, a) {
                var s = u(t[n], t, i);
                if ("throw" !== s.type) {
                  var c = s.arg,
                    l = c.value;
                  return l && "object" == typeof l && r.call(l, "__await")
                    ? Promise.resolve(l.__await).then(
                        function (t) {
                          e("next", t, o, a);
                        },
                        function (t) {
                          e("throw", t, o, a);
                        }
                      )
                    : Promise.resolve(l).then(
                        function (t) {
                          (c.value = t), o(c);
                        },
                        function (t) {
                          return e("throw", t, o, a);
                        }
                      );
                }
                a(s.arg);
              })(n, i, e, o);
            });
          }
          return (e = e ? e.then(o, o) : o());
        };
      }
      function S(t, n) {
        var r = t.iterator[n.method];
        if (r === e) {
          if (((n.delegate = null), "throw" === n.method)) {
            if (
              t.iterator.return &&
              ((n.method = "return"),
              (n.arg = e),
              S(t, n),
              "throw" === n.method)
            )
              return d;
            (n.method = "throw"),
              (n.arg = new TypeError(
                "The iterator does not provide a 'throw' method"
              ));
          }
          return d;
        }
        var i = u(r, t.iterator, n.arg);
        if ("throw" === i.type)
          return (n.method = "throw"), (n.arg = i.arg), (n.delegate = null), d;
        var o = i.arg;
        return o
          ? o.done
            ? ((n[t.resultName] = o.value),
              (n.next = t.nextLoc),
              "return" !== n.method && ((n.method = "next"), (n.arg = e)),
              (n.delegate = null),
              d)
            : o
          : ((n.method = "throw"),
            (n.arg = new TypeError("iterator result is not an object")),
            (n.delegate = null),
            d);
      }
      function E(t) {
        var e = { tryLoc: t[0] };
        1 in t && (e.catchLoc = t[1]),
          2 in t && ((e.finallyLoc = t[2]), (e.afterLoc = t[3])),
          this.tryEntries.push(e);
      }
      function T(t) {
        var e = t.completion || {};
        (e.type = "normal"), delete e.arg, (t.completion = e);
      }
      function A(t) {
        (this.tryEntries = [{ tryLoc: "root" }]),
          t.forEach(E, this),
          this.reset(!0);
      }
      function L(t) {
        if (t) {
          var n = t[o];
          if (n) return n.call(t);
          if ("function" == typeof t.next) return t;
          if (!isNaN(t.length)) {
            var i = -1,
              a = function n() {
                for (; ++i < t.length; )
                  if (r.call(t, i)) return (n.value = t[i]), (n.done = !1), n;
                return (n.value = e), (n.done = !0), n;
              };
            return (a.next = a);
          }
        }
        return { next: P };
      }
      function P() {
        return { value: e, done: !0 };
      }
      return (
        (v.prototype = w.constructor = g),
        (g.constructor = v),
        (g[s] = v.displayName = "GeneratorFunction"),
        (t.isGeneratorFunction = function (t) {
          var e = "function" == typeof t && t.constructor;
          return (
            !!e &&
            (e === v || "GeneratorFunction" === (e.displayName || e.name))
          );
        }),
        (t.mark = function (t) {
          return (
            Object.setPrototypeOf
              ? Object.setPrototypeOf(t, g)
              : ((t.__proto__ = g), s in t || (t[s] = "GeneratorFunction")),
            (t.prototype = Object.create(w)),
            t
          );
        }),
        (t.awrap = function (t) {
          return { __await: t };
        }),
        _(M.prototype),
        (M.prototype[a] = function () {
          return this;
        }),
        (t.AsyncIterator = M),
        (t.async = function (e, n, r, i) {
          var o = new M(c(e, n, r, i));
          return t.isGeneratorFunction(n)
            ? o
            : o.next().then(function (t) {
                return t.done ? t.value : o.next();
              });
        }),
        _(w),
        (w[s] = "Generator"),
        (w[o] = function () {
          return this;
        }),
        (w.toString = function () {
          return "[object Generator]";
        }),
        (t.keys = function (t) {
          var e = [];
          for (var n in t) e.push(n);
          return (
            e.reverse(),
            function n() {
              for (; e.length; ) {
                var r = e.pop();
                if (r in t) return (n.value = r), (n.done = !1), n;
              }
              return (n.done = !0), n;
            }
          );
        }),
        (t.values = L),
        (A.prototype = {
          constructor: A,
          reset: function (t) {
            if (
              ((this.prev = 0),
              (this.next = 0),
              (this.sent = this._sent = e),
              (this.done = !1),
              (this.delegate = null),
              (this.method = "next"),
              (this.arg = e),
              this.tryEntries.forEach(T),
              !t)
            )
              for (var n in this)
                "t" === n.charAt(0) &&
                  r.call(this, n) &&
                  !isNaN(+n.slice(1)) &&
                  (this[n] = e);
          },
          stop: function () {
            this.done = !0;
            var t = this.tryEntries[0].completion;
            if ("throw" === t.type) throw t.arg;
            return this.rval;
          },
          dispatchException: function (t) {
            if (this.done) throw t;
            var n = this;
            function i(r, i) {
              return (
                (s.type = "throw"),
                (s.arg = t),
                (n.next = r),
                i && ((n.method = "next"), (n.arg = e)),
                !!i
              );
            }
            for (var o = this.tryEntries.length - 1; o >= 0; --o) {
              var a = this.tryEntries[o],
                s = a.completion;
              if ("root" === a.tryLoc) return i("end");
              if (a.tryLoc <= this.prev) {
                var c = r.call(a, "catchLoc"),
                  u = r.call(a, "finallyLoc");
                if (c && u) {
                  if (this.prev < a.catchLoc) return i(a.catchLoc, !0);
                  if (this.prev < a.finallyLoc) return i(a.finallyLoc);
                } else if (c) {
                  if (this.prev < a.catchLoc) return i(a.catchLoc, !0);
                } else {
                  if (!u)
                    throw new Error("try statement without catch or finally");
                  if (this.prev < a.finallyLoc) return i(a.finallyLoc);
                }
              }
            }
          },
          abrupt: function (t, e) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var i = this.tryEntries[n];
              if (
                i.tryLoc <= this.prev &&
                r.call(i, "finallyLoc") &&
                this.prev < i.finallyLoc
              ) {
                var o = i;
                break;
              }
            }
            o &&
              ("break" === t || "continue" === t) &&
              o.tryLoc <= e &&
              e <= o.finallyLoc &&
              (o = null);
            var a = o ? o.completion : {};
            return (
              (a.type = t),
              (a.arg = e),
              o
                ? ((this.method = "next"), (this.next = o.finallyLoc), d)
                : this.complete(a)
            );
          },
          complete: function (t, e) {
            if ("throw" === t.type) throw t.arg;
            return (
              "break" === t.type || "continue" === t.type
                ? (this.next = t.arg)
                : "return" === t.type
                ? ((this.rval = this.arg = t.arg),
                  (this.method = "return"),
                  (this.next = "end"))
                : "normal" === t.type && e && (this.next = e),
              d
            );
          },
          finish: function (t) {
            for (var e = this.tryEntries.length - 1; e >= 0; --e) {
              var n = this.tryEntries[e];
              if (n.finallyLoc === t)
                return this.complete(n.completion, n.afterLoc), T(n), d;
            }
          },
          catch: function (t) {
            for (var e = this.tryEntries.length - 1; e >= 0; --e) {
              var n = this.tryEntries[e];
              if (n.tryLoc === t) {
                var r = n.completion;
                if ("throw" === r.type) {
                  var i = r.arg;
                  T(n);
                }
                return i;
              }
            }
            throw new Error("illegal catch attempt");
          },
          delegateYield: function (t, n, r) {
            return (
              (this.delegate = { iterator: L(t), resultName: n, nextLoc: r }),
              "next" === this.method && (this.arg = e),
              d
            );
          },
        }),
        t
      );
    })(t.exports);
    try {
      regeneratorRuntime = r;
    } catch (t) {
      Function("r", "regeneratorRuntime = r")(r);
    }
  },
  function (t, e, n) {
    n(298), (t.exports = n(120).global);
  },
  function (t, e, n) {
    var r = n(299);
    r(r.G, { global: n(85) });
  },
  function (t, e, n) {
    var r = n(85),
      i = n(120),
      o = n(300),
      a = n(302),
      s = n(309),
      c = function (t, e, n) {
        var u,
          l,
          h,
          p = t & c.F,
          f = t & c.G,
          d = t & c.S,
          m = t & c.P,
          v = t & c.B,
          g = t & c.W,
          y = f ? i : i[e] || (i[e] = {}),
          x = y.prototype,
          b = f ? r : d ? r[e] : (r[e] || {}).prototype;
        for (u in (f && (n = e), n))
          ((l = !p && b && void 0 !== b[u]) && s(y, u)) ||
            ((h = l ? b[u] : n[u]),
            (y[u] =
              f && "function" != typeof b[u]
                ? n[u]
                : v && l
                ? o(h, r)
                : g && b[u] == h
                ? (function (t) {
                    var e = function (e, n, r) {
                      if (this instanceof t) {
                        switch (arguments.length) {
                          case 0:
                            return new t();
                          case 1:
                            return new t(e);
                          case 2:
                            return new t(e, n);
                        }
                        return new t(e, n, r);
                      }
                      return t.apply(this, arguments);
                    };
                    return (e.prototype = t.prototype), e;
                  })(h)
                : m && "function" == typeof h
                ? o(Function.call, h)
                : h),
            m &&
              (((y.virtual || (y.virtual = {}))[u] = h),
              t & c.R && x && !x[u] && a(x, u, h)));
      };
    (c.F = 1),
      (c.G = 2),
      (c.S = 4),
      (c.P = 8),
      (c.B = 16),
      (c.W = 32),
      (c.U = 64),
      (c.R = 128),
      (t.exports = c);
  },
  function (t, e, n) {
    var r = n(301);
    t.exports = function (t, e, n) {
      if ((r(t), void 0 === e)) return t;
      switch (n) {
        case 1:
          return function (n) {
            return t.call(e, n);
          };
        case 2:
          return function (n, r) {
            return t.call(e, n, r);
          };
        case 3:
          return function (n, r, i) {
            return t.call(e, n, r, i);
          };
      }
      return function () {
        return t.apply(e, arguments);
      };
    };
  },
  function (t, e) {
    t.exports = function (t) {
      if ("function" != typeof t) throw TypeError(t + " is not a function!");
      return t;
    };
  },
  function (t, e, n) {
    var r = n(303),
      i = n(308);
    t.exports = n(87)
      ? function (t, e, n) {
          return r.f(t, e, i(1, n));
        }
      : function (t, e, n) {
          return (t[e] = n), t;
        };
  },
  function (t, e, n) {
    var r = n(304),
      i = n(305),
      o = n(307),
      a = Object.defineProperty;
    e.f = n(87)
      ? Object.defineProperty
      : function (t, e, n) {
          if ((r(t), (e = o(e, !0)), r(n), i))
            try {
              return a(t, e, n);
            } catch (t) {}
          if ("get" in n || "set" in n)
            throw TypeError("Accessors not supported!");
          return "value" in n && (t[e] = n.value), t;
        };
  },
  function (t, e, n) {
    var r = n(86);
    t.exports = function (t) {
      if (!r(t)) throw TypeError(t + " is not an object!");
      return t;
    };
  },
  function (t, e, n) {
    t.exports =
      !n(87) &&
      !n(121)(function () {
        return (
          7 !=
          Object.defineProperty(n(306)("div"), "a", {
            get: function () {
              return 7;
            },
          }).a
        );
      });
  },
  function (t, e, n) {
    var r = n(86),
      i = n(85).document,
      o = r(i) && r(i.createElement);
    t.exports = function (t) {
      return o ? i.createElement(t) : {};
    };
  },
  function (t, e, n) {
    var r = n(86);
    t.exports = function (t, e) {
      if (!r(t)) return t;
      var n, i;
      if (e && "function" == typeof (n = t.toString) && !r((i = n.call(t))))
        return i;
      if ("function" == typeof (n = t.valueOf) && !r((i = n.call(t)))) return i;
      if (!e && "function" == typeof (n = t.toString) && !r((i = n.call(t))))
        return i;
      throw TypeError("Can't convert object to primitive value");
    };
  },
  function (t, e) {
    t.exports = function (t, e) {
      return {
        enumerable: !(1 & t),
        configurable: !(2 & t),
        writable: !(4 & t),
        value: e,
      };
    };
  },
  function (t, e) {
    var n = {}.hasOwnProperty;
    t.exports = function (t, e) {
      return n.call(t, e);
    };
  },
  function (t, e, n) {},
  function (t, e) {
    var n;
    n = (function () {
      return this;
    })();
    try {
      n = n || new Function("return this")();
    } catch (t) {
      "object" == typeof window && (n = window);
    }
    t.exports = n;
  },
  function (t, e, n) {
    (function (e) {
      (function () {
        var n, r, i, o, a, s;
        "undefined" != typeof performance &&
        null !== performance &&
        performance.now
          ? (t.exports = function () {
              return performance.now();
            })
          : null != e && e.hrtime
          ? ((t.exports = function () {
              return (n() - a) / 1e6;
            }),
            (r = e.hrtime),
            (o = (n = function () {
              var t;
              return 1e9 * (t = r())[0] + t[1];
            })()),
            (s = 1e9 * e.uptime()),
            (a = o - s))
          : Date.now
          ? ((t.exports = function () {
              return Date.now() - i;
            }),
            (i = Date.now()))
          : ((t.exports = function () {
              return new Date().getTime() - i;
            }),
            (i = new Date().getTime()));
      }.call(this));
    }.call(this, n(313)));
  },
  function (t, e) {
    var n,
      r,
      i = (t.exports = {});
    function o() {
      throw new Error("setTimeout has not been defined");
    }
    function a() {
      throw new Error("clearTimeout has not been defined");
    }
    function s(t) {
      if (n === setTimeout) return setTimeout(t, 0);
      if ((n === o || !n) && setTimeout)
        return (n = setTimeout), setTimeout(t, 0);
      try {
        return n(t, 0);
      } catch (e) {
        try {
          return n.call(null, t, 0);
        } catch (e) {
          return n.call(this, t, 0);
        }
      }
    }
    !(function () {
      try {
        n = "function" == typeof setTimeout ? setTimeout : o;
      } catch (t) {
        n = o;
      }
      try {
        r = "function" == typeof clearTimeout ? clearTimeout : a;
      } catch (t) {
        r = a;
      }
    })();
    var c,
      u = [],
      l = !1,
      h = -1;
    function p() {
      l &&
        c &&
        ((l = !1), c.length ? (u = c.concat(u)) : (h = -1), u.length && f());
    }
    function f() {
      if (!l) {
        var t = s(p);
        l = !0;
        for (var e = u.length; e; ) {
          for (c = u, u = []; ++h < e; ) c && c[h].run();
          (h = -1), (e = u.length);
        }
        (c = null),
          (l = !1),
          (function (t) {
            if (r === clearTimeout) return clearTimeout(t);
            if ((r === a || !r) && clearTimeout)
              return (r = clearTimeout), clearTimeout(t);
            try {
              r(t);
            } catch (e) {
              try {
                return r.call(null, t);
              } catch (e) {
                return r.call(this, t);
              }
            }
          })(t);
      }
    }
    function d(t, e) {
      (this.fun = t), (this.array = e);
    }
    function m() {}
    (i.nextTick = function (t) {
      var e = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
      u.push(new d(t, e)), 1 !== u.length || l || s(f);
    }),
      (d.prototype.run = function () {
        this.fun.apply(null, this.array);
      }),
      (i.title = "browser"),
      (i.browser = !0),
      (i.env = {}),
      (i.argv = []),
      (i.version = ""),
      (i.versions = {}),
      (i.on = m),
      (i.addListener = m),
      (i.once = m),
      (i.off = m),
      (i.removeListener = m),
      (i.removeAllListeners = m),
      (i.emit = m),
      (i.prependListener = m),
      (i.prependOnceListener = m),
      (i.listeners = function (t) {
        return [];
      }),
      (i.binding = function (t) {
        throw new Error("process.binding is not supported");
      }),
      (i.cwd = function () {
        return "/";
      }),
      (i.chdir = function (t) {
        throw new Error("process.chdir is not supported");
      }),
      (i.umask = function () {
        return 0;
      });
  },
  function (t, e, n) {
    "use strict";
    n.r(e);
    n(310);
    var r = n(122),
      i = n.n(r),
      o = [],
      a = [];
    function s(t) {
      var e = t();
      e && o.push(e);
    }
    function c(t) {
      a.push(t), s(t);
    }
    window.addEventListener(
      "resize",
      i()(function () {
        o.forEach(function (t) {
          return t();
        }),
          (o = []),
          a.forEach(s);
      }),
      500
    );
    var u = { width: 0, height: 0, scale: 1 };
    function l() {
      return u;
    }
    c(function () {
      window.visualViewport
        ? ((u.width = window.visualViewport.width),
          (u.height = window.visualViewport.height))
        : ((u.width = window.innerWidth), (u.height = window.innerHeight)),
        (u.scale = window.devicePixelRatio || 1);
    });
    var h = n(88),
      p = n.n(h),
      f = [],
      d = 0;
    function m(t) {
      return (
        f.push(t),
        function () {
          return (f = f.filter(function (e) {
            return e !== t;
          }));
        }
      );
    }
    function v(t, e, n) {
      return (1 - n) * t + n * e;
    }
    function g(t, e, n, r, i, o, a) {
      try {
        var s = t[o](a),
          c = s.value;
      } catch (t) {
        return void n(t);
      }
      s.done ? e(c) : Promise.resolve(c).then(r, i);
    }
    function y() {
      var t;
      return (
        (t = regeneratorRuntime.mark(function t(e) {
          return regeneratorRuntime.wrap(function (t) {
            for (;;)
              switch ((t.prev = t.next)) {
                case 0:
                  c(function () {
                    var t = l(),
                      n = t.width,
                      r = t.height;
                    if (n >= 768) {
                      var i = n / 4,
                        o = n / 2,
                        a = r / 2,
                        s = o,
                        c = a,
                        u = function (t) {
                          (s = t.clientX), (c = t.clientY);
                        },
                        h = m(function () {
                          (o = v(o, s - i, 0.05)),
                            (a = v(a, c - i, 0.05)),
                            (e.style.transform = "translate3d("
                              .concat(Math.round(o), "px, ")
                              .concat(Math.round(a), "px, 0)"));
                        });
                      return (
                        document.addEventListener("mousemove", u),
                        function () {
                          h(), document.removeEventListener("mousemove", u);
                        }
                      );
                    }
                  });
                case 1:
                case "end":
                  return t.stop();
              }
          }, t);
        })),
        (y = function () {
          var e = this,
            n = arguments;
          return new Promise(function (r, i) {
            var o = t.apply(e, n);
            function a(t) {
              g(o, r, i, a, s, "next", t);
            }
            function s(t) {
              g(o, r, i, a, s, "throw", t);
            }
            a(void 0);
          });
        }).apply(this, arguments)
      );
    }
    (window.onload = function () {
      p()(function t() {
        f.forEach(function (t) {
          return t(d);
        }),
          (d += 1),
          p()(t);
      });
    }),
      void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
      void 0 === Number.isInteger &&
        (Number.isInteger = function (t) {
          return "number" == typeof t && isFinite(t) && Math.floor(t) === t;
        }),
      void 0 === Math.sign &&
        (Math.sign = function (t) {
          return t < 0 ? -1 : t > 0 ? 1 : +t;
        }),
      "name" in Function.prototype == !1 &&
        Object.defineProperty(Function.prototype, "name", {
          get: function () {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
          },
        }),
      void 0 === Object.assign &&
        (Object.assign = function (t) {
          if (null == t)
            throw new TypeError("Cannot convert undefined or null to object");
          for (var e = Object(t), n = 1; n < arguments.length; n++) {
            var r = arguments[n];
            if (null != r)
              for (var i in r)
                Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
          }
          return e;
        });
    var x = 0,
      b = 1,
      w = 2,
      _ = 1,
      M = 2,
      S = 3,
      E = 0,
      T = 1,
      A = 2,
      L = 0,
      P = 1,
      R = 2,
      C = 0,
      O = 1,
      I = 2,
      N = 3,
      D = 4,
      z = 5,
      F = 100,
      U = 101,
      B = 102,
      G = 103,
      j = 104,
      V = 200,
      H = 201,
      k = 202,
      W = 203,
      q = 204,
      X = 205,
      Y = 206,
      J = 207,
      Z = 208,
      Q = 209,
      K = 210,
      $ = 0,
      tt = 1,
      et = 2,
      nt = 3,
      rt = 4,
      it = 5,
      ot = 6,
      at = 7,
      st = 0,
      ct = 1,
      ut = 2,
      lt = 0,
      ht = 1,
      pt = 2,
      ft = 3,
      dt = 4,
      mt = 5,
      vt = 301,
      gt = 302,
      yt = 303,
      xt = 304,
      bt = 305,
      wt = 306,
      _t = 307,
      Mt = 1e3,
      St = 1001,
      Et = 1002,
      Tt = 1003,
      At = 1004,
      Lt = 1005,
      Pt = 1006,
      Rt = 1007,
      Ct = 1008,
      Ot = 1009,
      It = 1010,
      Nt = 1011,
      Dt = 1012,
      zt = 1013,
      Ft = 1014,
      Ut = 1015,
      Bt = 1016,
      Gt = 1017,
      jt = 1018,
      Vt = 1019,
      Ht = 1020,
      kt = 1021,
      Wt = 1022,
      qt = 1023,
      Xt = 1024,
      Yt = 1025,
      Jt = 1026,
      Zt = 1027,
      Qt = 1028,
      Kt = 33776,
      $t = 33777,
      te = 33778,
      ee = 33779,
      ne = 35840,
      re = 35841,
      ie = 35842,
      oe = 35843,
      ae = 36196,
      se = 37808,
      ce = 37809,
      ue = 37810,
      le = 37811,
      he = 37812,
      pe = 37813,
      fe = 37814,
      de = 37815,
      me = 37816,
      ve = 37817,
      ge = 37818,
      ye = 37819,
      xe = 37820,
      be = 37821,
      we = 2201,
      _e = 2400,
      Me = 0,
      Se = 1,
      Ee = 2,
      Te = 3e3,
      Ae = 3001,
      Le = 3007,
      Pe = 3002,
      Re = 3003,
      Ce = 3004,
      Oe = 3005,
      Ie = 3006,
      Ne = 3200,
      De = 3201,
      ze = 0,
      Fe = 1,
      Ue = 7680,
      Be = 519;
    function Ge() {}
    Object.assign(Ge.prototype, {
      addEventListener: function (t, e) {
        void 0 === this._listeners && (this._listeners = {});
        var n = this._listeners;
        void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
      },
      hasEventListener: function (t, e) {
        if (void 0 === this._listeners) return !1;
        var n = this._listeners;
        return void 0 !== n[t] && -1 !== n[t].indexOf(e);
      },
      removeEventListener: function (t, e) {
        if (void 0 !== this._listeners) {
          var n = this._listeners[t];
          if (void 0 !== n) {
            var r = n.indexOf(e);
            -1 !== r && n.splice(r, 1);
          }
        }
      },
      dispatchEvent: function (t) {
        if (void 0 !== this._listeners) {
          var e = this._listeners[t.type];
          if (void 0 !== e) {
            t.target = this;
            for (var n = e.slice(0), r = 0, i = n.length; r < i; r++)
              n[r].call(this, t);
          }
        }
      },
    });
    for (var je = [], Ve = 0; Ve < 256; Ve++)
      je[Ve] = (Ve < 16 ? "0" : "") + Ve.toString(16);
    var He = {
      DEG2RAD: Math.PI / 180,
      RAD2DEG: 180 / Math.PI,
      generateUUID: function () {
        var t = (4294967295 * Math.random()) | 0,
          e = (4294967295 * Math.random()) | 0,
          n = (4294967295 * Math.random()) | 0,
          r = (4294967295 * Math.random()) | 0;
        return (
          je[255 & t] +
          je[(t >> 8) & 255] +
          je[(t >> 16) & 255] +
          je[(t >> 24) & 255] +
          "-" +
          je[255 & e] +
          je[(e >> 8) & 255] +
          "-" +
          je[((e >> 16) & 15) | 64] +
          je[(e >> 24) & 255] +
          "-" +
          je[(63 & n) | 128] +
          je[(n >> 8) & 255] +
          "-" +
          je[(n >> 16) & 255] +
          je[(n >> 24) & 255] +
          je[255 & r] +
          je[(r >> 8) & 255] +
          je[(r >> 16) & 255] +
          je[(r >> 24) & 255]
        ).toUpperCase();
      },
      clamp: function (t, e, n) {
        return Math.max(e, Math.min(n, t));
      },
      euclideanModulo: function (t, e) {
        return ((t % e) + e) % e;
      },
      mapLinear: function (t, e, n, r, i) {
        return r + ((t - e) * (i - r)) / (n - e);
      },
      lerp: function (t, e, n) {
        return (1 - n) * t + n * e;
      },
      smoothstep: function (t, e, n) {
        return t <= e
          ? 0
          : t >= n
          ? 1
          : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
      },
      smootherstep: function (t, e, n) {
        return t <= e
          ? 0
          : t >= n
          ? 1
          : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
      },
      randInt: function (t, e) {
        return t + Math.floor(Math.random() * (e - t + 1));
      },
      randFloat: function (t, e) {
        return t + Math.random() * (e - t);
      },
      randFloatSpread: function (t) {
        return t * (0.5 - Math.random());
      },
      degToRad: function (t) {
        return t * He.DEG2RAD;
      },
      radToDeg: function (t) {
        return t * He.RAD2DEG;
      },
      isPowerOfTwo: function (t) {
        return 0 == (t & (t - 1)) && 0 !== t;
      },
      ceilPowerOfTwo: function (t) {
        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
      },
      floorPowerOfTwo: function (t) {
        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
      },
    };
    function ke(t, e) {
      (this.x = t || 0), (this.y = e || 0);
    }
    function We(t, e, n, r) {
      (this._x = t || 0),
        (this._y = e || 0),
        (this._z = n || 0),
        (this._w = void 0 !== r ? r : 1);
    }
    Object.defineProperties(ke.prototype, {
      width: {
        get: function () {
          return this.x;
        },
        set: function (t) {
          this.x = t;
        },
      },
      height: {
        get: function () {
          return this.y;
        },
        set: function (t) {
          this.y = t;
        },
      },
    }),
      Object.assign(ke.prototype, {
        isVector2: !0,
        set: function (t, e) {
          return (this.x = t), (this.y = e), this;
        },
        setScalar: function (t) {
          return (this.x = t), (this.y = t), this;
        },
        setX: function (t) {
          return (this.x = t), this;
        },
        setY: function (t) {
          return (this.y = t), this;
        },
        setComponent: function (t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        },
        getComponent: function (t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + t);
          }
        },
        clone: function () {
          return new this.constructor(this.x, this.y);
        },
        copy: function (t) {
          return (this.x = t.x), (this.y = t.y), this;
        },
        add: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(t, e))
            : ((this.x += t.x), (this.y += t.y), this);
        },
        addScalar: function (t) {
          return (this.x += t), (this.y += t), this;
        },
        addVectors: function (t, e) {
          return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
        },
        addScaledVector: function (t, e) {
          return (this.x += t.x * e), (this.y += t.y * e), this;
        },
        sub: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x), (this.y -= t.y), this);
        },
        subScalar: function (t) {
          return (this.x -= t), (this.y -= t), this;
        },
        subVectors: function (t, e) {
          return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
        },
        multiply: function (t) {
          return (this.x *= t.x), (this.y *= t.y), this;
        },
        multiplyScalar: function (t) {
          return (this.x *= t), (this.y *= t), this;
        },
        divide: function (t) {
          return (this.x /= t.x), (this.y /= t.y), this;
        },
        divideScalar: function (t) {
          return this.multiplyScalar(1 / t);
        },
        applyMatrix3: function (t) {
          var e = this.x,
            n = this.y,
            r = t.elements;
          return (
            (this.x = r[0] * e + r[3] * n + r[6]),
            (this.y = r[1] * e + r[4] * n + r[7]),
            this
          );
        },
        min: function (t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            this
          );
        },
        max: function (t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            this
          );
        },
        clamp: function (t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            this
          );
        },
        clampScalar: function (t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            this
          );
        },
        clampLength: function (t, e) {
          var n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        },
        floor: function () {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        },
        ceil: function () {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        },
        round: function () {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        },
        roundToZero: function () {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            this
          );
        },
        negate: function () {
          return (this.x = -this.x), (this.y = -this.y), this;
        },
        dot: function (t) {
          return this.x * t.x + this.y * t.y;
        },
        cross: function (t) {
          return this.x * t.y - this.y * t.x;
        },
        lengthSq: function () {
          return this.x * this.x + this.y * this.y;
        },
        length: function () {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        manhattanLength: function () {
          return Math.abs(this.x) + Math.abs(this.y);
        },
        normalize: function () {
          return this.divideScalar(this.length() || 1);
        },
        angle: function () {
          var t = Math.atan2(this.y, this.x);
          return t < 0 && (t += 2 * Math.PI), t;
        },
        distanceTo: function (t) {
          return Math.sqrt(this.distanceToSquared(t));
        },
        distanceToSquared: function (t) {
          var e = this.x - t.x,
            n = this.y - t.y;
          return e * e + n * n;
        },
        manhattanDistanceTo: function (t) {
          return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
        },
        setLength: function (t) {
          return this.normalize().multiplyScalar(t);
        },
        lerp: function (t, e) {
          return (
            (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
          );
        },
        lerpVectors: function (t, e, n) {
          return this.subVectors(e, t).multiplyScalar(n).add(t);
        },
        equals: function (t) {
          return t.x === this.x && t.y === this.y;
        },
        fromArray: function (t, e) {
          return (
            void 0 === e && (e = 0), (this.x = t[e]), (this.y = t[e + 1]), this
          );
        },
        toArray: function (t, e) {
          return (
            void 0 === t && (t = []),
            void 0 === e && (e = 0),
            (t[e] = this.x),
            (t[e + 1] = this.y),
            t
          );
        },
        fromBufferAttribute: function (t, e, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            this
          );
        },
        rotateAround: function (t, e) {
          var n = Math.cos(e),
            r = Math.sin(e),
            i = this.x - t.x,
            o = this.y - t.y;
          return (
            (this.x = i * n - o * r + t.x), (this.y = i * r + o * n + t.y), this
          );
        },
      }),
      Object.assign(We, {
        slerp: function (t, e, n, r) {
          return n.copy(t).slerp(e, r);
        },
        slerpFlat: function (t, e, n, r, i, o, a) {
          var s = n[r + 0],
            c = n[r + 1],
            u = n[r + 2],
            l = n[r + 3],
            h = i[o + 0],
            p = i[o + 1],
            f = i[o + 2],
            d = i[o + 3];
          if (l !== d || s !== h || c !== p || u !== f) {
            var m = 1 - a,
              v = s * h + c * p + u * f + l * d,
              g = v >= 0 ? 1 : -1,
              y = 1 - v * v;
            if (y > Number.EPSILON) {
              var x = Math.sqrt(y),
                b = Math.atan2(x, v * g);
              (m = Math.sin(m * b) / x), (a = Math.sin(a * b) / x);
            }
            var w = a * g;
            if (
              ((s = s * m + h * w),
              (c = c * m + p * w),
              (u = u * m + f * w),
              (l = l * m + d * w),
              m === 1 - a)
            ) {
              var _ = 1 / Math.sqrt(s * s + c * c + u * u + l * l);
              (s *= _), (c *= _), (u *= _), (l *= _);
            }
          }
          (t[e] = s), (t[e + 1] = c), (t[e + 2] = u), (t[e + 3] = l);
        },
      }),
      Object.defineProperties(We.prototype, {
        x: {
          get: function () {
            return this._x;
          },
          set: function (t) {
            (this._x = t), this._onChangeCallback();
          },
        },
        y: {
          get: function () {
            return this._y;
          },
          set: function (t) {
            (this._y = t), this._onChangeCallback();
          },
        },
        z: {
          get: function () {
            return this._z;
          },
          set: function (t) {
            (this._z = t), this._onChangeCallback();
          },
        },
        w: {
          get: function () {
            return this._w;
          },
          set: function (t) {
            (this._w = t), this._onChangeCallback();
          },
        },
      }),
      Object.assign(We.prototype, {
        isQuaternion: !0,
        set: function (t, e, n, r) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._w = r),
            this._onChangeCallback(),
            this
          );
        },
        clone: function () {
          return new this.constructor(this._x, this._y, this._z, this._w);
        },
        copy: function (t) {
          return (
            (this._x = t.x),
            (this._y = t.y),
            (this._z = t.z),
            (this._w = t.w),
            this._onChangeCallback(),
            this
          );
        },
        setFromEuler: function (t, e) {
          if (!t || !t.isEuler)
            throw new Error(
              "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
            );
          var n = t._x,
            r = t._y,
            i = t._z,
            o = t.order,
            a = Math.cos,
            s = Math.sin,
            c = a(n / 2),
            u = a(r / 2),
            l = a(i / 2),
            h = s(n / 2),
            p = s(r / 2),
            f = s(i / 2);
          return (
            "XYZ" === o
              ? ((this._x = h * u * l + c * p * f),
                (this._y = c * p * l - h * u * f),
                (this._z = c * u * f + h * p * l),
                (this._w = c * u * l - h * p * f))
              : "YXZ" === o
              ? ((this._x = h * u * l + c * p * f),
                (this._y = c * p * l - h * u * f),
                (this._z = c * u * f - h * p * l),
                (this._w = c * u * l + h * p * f))
              : "ZXY" === o
              ? ((this._x = h * u * l - c * p * f),
                (this._y = c * p * l + h * u * f),
                (this._z = c * u * f + h * p * l),
                (this._w = c * u * l - h * p * f))
              : "ZYX" === o
              ? ((this._x = h * u * l - c * p * f),
                (this._y = c * p * l + h * u * f),
                (this._z = c * u * f - h * p * l),
                (this._w = c * u * l + h * p * f))
              : "YZX" === o
              ? ((this._x = h * u * l + c * p * f),
                (this._y = c * p * l + h * u * f),
                (this._z = c * u * f - h * p * l),
                (this._w = c * u * l - h * p * f))
              : "XZY" === o &&
                ((this._x = h * u * l - c * p * f),
                (this._y = c * p * l - h * u * f),
                (this._z = c * u * f + h * p * l),
                (this._w = c * u * l + h * p * f)),
            !1 !== e && this._onChangeCallback(),
            this
          );
        },
        setFromAxisAngle: function (t, e) {
          var n = e / 2,
            r = Math.sin(n);
          return (
            (this._x = t.x * r),
            (this._y = t.y * r),
            (this._z = t.z * r),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
          );
        },
        setFromRotationMatrix: function (t) {
          var e,
            n = t.elements,
            r = n[0],
            i = n[4],
            o = n[8],
            a = n[1],
            s = n[5],
            c = n[9],
            u = n[2],
            l = n[6],
            h = n[10],
            p = r + s + h;
          return (
            p > 0
              ? ((e = 0.5 / Math.sqrt(p + 1)),
                (this._w = 0.25 / e),
                (this._x = (l - c) * e),
                (this._y = (o - u) * e),
                (this._z = (a - i) * e))
              : r > s && r > h
              ? ((e = 2 * Math.sqrt(1 + r - s - h)),
                (this._w = (l - c) / e),
                (this._x = 0.25 * e),
                (this._y = (i + a) / e),
                (this._z = (o + u) / e))
              : s > h
              ? ((e = 2 * Math.sqrt(1 + s - r - h)),
                (this._w = (o - u) / e),
                (this._x = (i + a) / e),
                (this._y = 0.25 * e),
                (this._z = (c + l) / e))
              : ((e = 2 * Math.sqrt(1 + h - r - s)),
                (this._w = (a - i) / e),
                (this._x = (o + u) / e),
                (this._y = (c + l) / e),
                (this._z = 0.25 * e)),
            this._onChangeCallback(),
            this
          );
        },
        setFromUnitVectors: function (t, e) {
          var n = t.dot(e) + 1;
          return (
            n < 1e-6
              ? ((n = 0),
                Math.abs(t.x) > Math.abs(t.z)
                  ? ((this._x = -t.y),
                    (this._y = t.x),
                    (this._z = 0),
                    (this._w = n))
                  : ((this._x = 0),
                    (this._y = -t.z),
                    (this._z = t.y),
                    (this._w = n)))
              : ((this._x = t.y * e.z - t.z * e.y),
                (this._y = t.z * e.x - t.x * e.z),
                (this._z = t.x * e.y - t.y * e.x),
                (this._w = n)),
            this.normalize()
          );
        },
        angleTo: function (t) {
          return 2 * Math.acos(Math.abs(He.clamp(this.dot(t), -1, 1)));
        },
        rotateTowards: function (t, e) {
          var n = this.angleTo(t);
          if (0 === n) return this;
          var r = Math.min(1, e / n);
          return this.slerp(t, r), this;
        },
        inverse: function () {
          return this.conjugate();
        },
        conjugate: function () {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        },
        dot: function (t) {
          return (
            this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
          );
        },
        lengthSq: function () {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        },
        length: function () {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        },
        normalize: function () {
          var t = this.length();
          return (
            0 === t
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((t = 1 / t),
                (this._x = this._x * t),
                (this._y = this._y * t),
                (this._z = this._z * t),
                (this._w = this._w * t)),
            this._onChangeCallback(),
            this
          );
        },
        multiply: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
              ),
              this.multiplyQuaternions(t, e))
            : this.multiplyQuaternions(this, t);
        },
        premultiply: function (t) {
          return this.multiplyQuaternions(t, this);
        },
        multiplyQuaternions: function (t, e) {
          var n = t._x,
            r = t._y,
            i = t._z,
            o = t._w,
            a = e._x,
            s = e._y,
            c = e._z,
            u = e._w;
          return (
            (this._x = n * u + o * a + r * c - i * s),
            (this._y = r * u + o * s + i * a - n * c),
            (this._z = i * u + o * c + n * s - r * a),
            (this._w = o * u - n * a - r * s - i * c),
            this._onChangeCallback(),
            this
          );
        },
        slerp: function (t, e) {
          if (0 === e) return this;
          if (1 === e) return this.copy(t);
          var n = this._x,
            r = this._y,
            i = this._z,
            o = this._w,
            a = o * t._w + n * t._x + r * t._y + i * t._z;
          if (
            (a < 0
              ? ((this._w = -t._w),
                (this._x = -t._x),
                (this._y = -t._y),
                (this._z = -t._z),
                (a = -a))
              : this.copy(t),
            a >= 1)
          )
            return (
              (this._w = o), (this._x = n), (this._y = r), (this._z = i), this
            );
          var s = 1 - a * a;
          if (s <= Number.EPSILON) {
            var c = 1 - e;
            return (
              (this._w = c * o + e * this._w),
              (this._x = c * n + e * this._x),
              (this._y = c * r + e * this._y),
              (this._z = c * i + e * this._z),
              this.normalize(),
              this._onChangeCallback(),
              this
            );
          }
          var u = Math.sqrt(s),
            l = Math.atan2(u, a),
            h = Math.sin((1 - e) * l) / u,
            p = Math.sin(e * l) / u;
          return (
            (this._w = o * h + this._w * p),
            (this._x = n * h + this._x * p),
            (this._y = r * h + this._y * p),
            (this._z = i * h + this._z * p),
            this._onChangeCallback(),
            this
          );
        },
        equals: function (t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._w === this._w
          );
        },
        fromArray: function (t, e) {
          return (
            void 0 === e && (e = 0),
            (this._x = t[e]),
            (this._y = t[e + 1]),
            (this._z = t[e + 2]),
            (this._w = t[e + 3]),
            this._onChangeCallback(),
            this
          );
        },
        toArray: function (t, e) {
          return (
            void 0 === t && (t = []),
            void 0 === e && (e = 0),
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._w),
            t
          );
        },
        _onChange: function (t) {
          return (this._onChangeCallback = t), this;
        },
        _onChangeCallback: function () {},
      });
    var qe = new Ye(),
      Xe = new We();
    function Ye(t, e, n) {
      (this.x = t || 0), (this.y = e || 0), (this.z = n || 0);
    }
    Object.assign(Ye.prototype, {
      isVector3: !0,
      set: function (t, e, n) {
        return (this.x = t), (this.y = e), (this.z = n), this;
      },
      setScalar: function (t) {
        return (this.x = t), (this.y = t), (this.z = t), this;
      },
      setX: function (t) {
        return (this.x = t), this;
      },
      setY: function (t) {
        return (this.y = t), this;
      },
      setZ: function (t) {
        return (this.z = t), this;
      },
      setComponent: function (t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          default:
            throw new Error("index is out of range: " + t);
        }
        return this;
      },
      getComponent: function (t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + t);
        }
      },
      clone: function () {
        return new this.constructor(this.x, this.y, this.z);
      },
      copy: function (t) {
        return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
      },
      add: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
            ),
            this.addVectors(t, e))
          : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
      },
      addScalar: function (t) {
        return (this.x += t), (this.y += t), (this.z += t), this;
      },
      addVectors: function (t, e) {
        return (
          (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
        );
      },
      addScaledVector: function (t, e) {
        return (
          (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
        );
      },
      sub: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
            ),
            this.subVectors(t, e))
          : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
      },
      subScalar: function (t) {
        return (this.x -= t), (this.y -= t), (this.z -= t), this;
      },
      subVectors: function (t, e) {
        return (
          (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
        );
      },
      multiply: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
            ),
            this.multiplyVectors(t, e))
          : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
      },
      multiplyScalar: function (t) {
        return (this.x *= t), (this.y *= t), (this.z *= t), this;
      },
      multiplyVectors: function (t, e) {
        return (
          (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
        );
      },
      applyEuler: function (t) {
        return (
          (t && t.isEuler) ||
            console.error(
              "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
            ),
          this.applyQuaternion(Xe.setFromEuler(t))
        );
      },
      applyAxisAngle: function (t, e) {
        return this.applyQuaternion(Xe.setFromAxisAngle(t, e));
      },
      applyMatrix3: function (t) {
        var e = this.x,
          n = this.y,
          r = this.z,
          i = t.elements;
        return (
          (this.x = i[0] * e + i[3] * n + i[6] * r),
          (this.y = i[1] * e + i[4] * n + i[7] * r),
          (this.z = i[2] * e + i[5] * n + i[8] * r),
          this
        );
      },
      applyMatrix4: function (t) {
        var e = this.x,
          n = this.y,
          r = this.z,
          i = t.elements,
          o = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]);
        return (
          (this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * o),
          (this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * o),
          (this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * o),
          this
        );
      },
      applyQuaternion: function (t) {
        var e = this.x,
          n = this.y,
          r = this.z,
          i = t.x,
          o = t.y,
          a = t.z,
          s = t.w,
          c = s * e + o * r - a * n,
          u = s * n + a * e - i * r,
          l = s * r + i * n - o * e,
          h = -i * e - o * n - a * r;
        return (
          (this.x = c * s + h * -i + u * -a - l * -o),
          (this.y = u * s + h * -o + l * -i - c * -a),
          (this.z = l * s + h * -a + c * -o - u * -i),
          this
        );
      },
      project: function (t) {
        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
          t.projectionMatrix
        );
      },
      unproject: function (t) {
        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
          t.matrixWorld
        );
      },
      transformDirection: function (t) {
        var e = this.x,
          n = this.y,
          r = this.z,
          i = t.elements;
        return (
          (this.x = i[0] * e + i[4] * n + i[8] * r),
          (this.y = i[1] * e + i[5] * n + i[9] * r),
          (this.z = i[2] * e + i[6] * n + i[10] * r),
          this.normalize()
        );
      },
      divide: function (t) {
        return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
      },
      divideScalar: function (t) {
        return this.multiplyScalar(1 / t);
      },
      min: function (t) {
        return (
          (this.x = Math.min(this.x, t.x)),
          (this.y = Math.min(this.y, t.y)),
          (this.z = Math.min(this.z, t.z)),
          this
        );
      },
      max: function (t) {
        return (
          (this.x = Math.max(this.x, t.x)),
          (this.y = Math.max(this.y, t.y)),
          (this.z = Math.max(this.z, t.z)),
          this
        );
      },
      clamp: function (t, e) {
        return (
          (this.x = Math.max(t.x, Math.min(e.x, this.x))),
          (this.y = Math.max(t.y, Math.min(e.y, this.y))),
          (this.z = Math.max(t.z, Math.min(e.z, this.z))),
          this
        );
      },
      clampScalar: function (t, e) {
        return (
          (this.x = Math.max(t, Math.min(e, this.x))),
          (this.y = Math.max(t, Math.min(e, this.y))),
          (this.z = Math.max(t, Math.min(e, this.z))),
          this
        );
      },
      clampLength: function (t, e) {
        var n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(t, Math.min(e, n))
        );
      },
      floor: function () {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          this
        );
      },
      ceil: function () {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          this
        );
      },
      round: function () {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          this
        );
      },
      roundToZero: function () {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          this
        );
      },
      negate: function () {
        return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
      },
      dot: function (t) {
        return this.x * t.x + this.y * t.y + this.z * t.z;
      },
      lengthSq: function () {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      },
      length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      },
      manhattanLength: function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      },
      normalize: function () {
        return this.divideScalar(this.length() || 1);
      },
      setLength: function (t) {
        return this.normalize().multiplyScalar(t);
      },
      lerp: function (t, e) {
        return (
          (this.x += (t.x - this.x) * e),
          (this.y += (t.y - this.y) * e),
          (this.z += (t.z - this.z) * e),
          this
        );
      },
      lerpVectors: function (t, e, n) {
        return this.subVectors(e, t).multiplyScalar(n).add(t);
      },
      cross: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
            ),
            this.crossVectors(t, e))
          : this.crossVectors(this, t);
      },
      crossVectors: function (t, e) {
        var n = t.x,
          r = t.y,
          i = t.z,
          o = e.x,
          a = e.y,
          s = e.z;
        return (
          (this.x = r * s - i * a),
          (this.y = i * o - n * s),
          (this.z = n * a - r * o),
          this
        );
      },
      projectOnVector: function (t) {
        var e = t.dot(this) / t.lengthSq();
        return this.copy(t).multiplyScalar(e);
      },
      projectOnPlane: function (t) {
        return qe.copy(this).projectOnVector(t), this.sub(qe);
      },
      reflect: function (t) {
        return this.sub(qe.copy(t).multiplyScalar(2 * this.dot(t)));
      },
      angleTo: function (t) {
        var e = Math.sqrt(this.lengthSq() * t.lengthSq());
        0 === e &&
          console.error(
            "THREE.Vector3: angleTo() can't handle zero length vectors."
          );
        var n = this.dot(t) / e;
        return Math.acos(He.clamp(n, -1, 1));
      },
      distanceTo: function (t) {
        return Math.sqrt(this.distanceToSquared(t));
      },
      distanceToSquared: function (t) {
        var e = this.x - t.x,
          n = this.y - t.y,
          r = this.z - t.z;
        return e * e + n * n + r * r;
      },
      manhattanDistanceTo: function (t) {
        return (
          Math.abs(this.x - t.x) +
          Math.abs(this.y - t.y) +
          Math.abs(this.z - t.z)
        );
      },
      setFromSpherical: function (t) {
        return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
      },
      setFromSphericalCoords: function (t, e, n) {
        var r = Math.sin(e) * t;
        return (
          (this.x = r * Math.sin(n)),
          (this.y = Math.cos(e) * t),
          (this.z = r * Math.cos(n)),
          this
        );
      },
      setFromCylindrical: function (t) {
        return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
      },
      setFromCylindricalCoords: function (t, e, n) {
        return (
          (this.x = t * Math.sin(e)),
          (this.y = n),
          (this.z = t * Math.cos(e)),
          this
        );
      },
      setFromMatrixPosition: function (t) {
        var e = t.elements;
        return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
      },
      setFromMatrixScale: function (t) {
        var e = this.setFromMatrixColumn(t, 0).length(),
          n = this.setFromMatrixColumn(t, 1).length(),
          r = this.setFromMatrixColumn(t, 2).length();
        return (this.x = e), (this.y = n), (this.z = r), this;
      },
      setFromMatrixColumn: function (t, e) {
        return this.fromArray(t.elements, 4 * e);
      },
      equals: function (t) {
        return t.x === this.x && t.y === this.y && t.z === this.z;
      },
      fromArray: function (t, e) {
        return (
          void 0 === e && (e = 0),
          (this.x = t[e]),
          (this.y = t[e + 1]),
          (this.z = t[e + 2]),
          this
        );
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this.x),
          (t[e + 1] = this.y),
          (t[e + 2] = this.z),
          t
        );
      },
      fromBufferAttribute: function (t, e, n) {
        return (
          void 0 !== n &&
            console.warn(
              "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
            ),
          (this.x = t.getX(e)),
          (this.y = t.getY(e)),
          (this.z = t.getZ(e)),
          this
        );
      },
    });
    var Je,
      Ze = new Ye();
    function Qe() {
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        arguments.length > 0 &&
          console.error(
            "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
          );
    }
    Object.assign(Qe.prototype, {
      isMatrix3: !0,
      set: function (t, e, n, r, i, o, a, s, c) {
        var u = this.elements;
        return (
          (u[0] = t),
          (u[1] = r),
          (u[2] = a),
          (u[3] = e),
          (u[4] = i),
          (u[5] = s),
          (u[6] = n),
          (u[7] = o),
          (u[8] = c),
          this
        );
      },
      identity: function () {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
      },
      clone: function () {
        return new this.constructor().fromArray(this.elements);
      },
      copy: function (t) {
        var e = this.elements,
          n = t.elements;
        return (
          (e[0] = n[0]),
          (e[1] = n[1]),
          (e[2] = n[2]),
          (e[3] = n[3]),
          (e[4] = n[4]),
          (e[5] = n[5]),
          (e[6] = n[6]),
          (e[7] = n[7]),
          (e[8] = n[8]),
          this
        );
      },
      setFromMatrix4: function (t) {
        var e = t.elements;
        return (
          this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
        );
      },
      applyToBufferAttribute: function (t) {
        for (var e = 0, n = t.count; e < n; e++)
          (Ze.x = t.getX(e)),
            (Ze.y = t.getY(e)),
            (Ze.z = t.getZ(e)),
            Ze.applyMatrix3(this),
            t.setXYZ(e, Ze.x, Ze.y, Ze.z);
        return t;
      },
      multiply: function (t) {
        return this.multiplyMatrices(this, t);
      },
      premultiply: function (t) {
        return this.multiplyMatrices(t, this);
      },
      multiplyMatrices: function (t, e) {
        var n = t.elements,
          r = e.elements,
          i = this.elements,
          o = n[0],
          a = n[3],
          s = n[6],
          c = n[1],
          u = n[4],
          l = n[7],
          h = n[2],
          p = n[5],
          f = n[8],
          d = r[0],
          m = r[3],
          v = r[6],
          g = r[1],
          y = r[4],
          x = r[7],
          b = r[2],
          w = r[5],
          _ = r[8];
        return (
          (i[0] = o * d + a * g + s * b),
          (i[3] = o * m + a * y + s * w),
          (i[6] = o * v + a * x + s * _),
          (i[1] = c * d + u * g + l * b),
          (i[4] = c * m + u * y + l * w),
          (i[7] = c * v + u * x + l * _),
          (i[2] = h * d + p * g + f * b),
          (i[5] = h * m + p * y + f * w),
          (i[8] = h * v + p * x + f * _),
          this
        );
      },
      multiplyScalar: function (t) {
        var e = this.elements;
        return (
          (e[0] *= t),
          (e[3] *= t),
          (e[6] *= t),
          (e[1] *= t),
          (e[4] *= t),
          (e[7] *= t),
          (e[2] *= t),
          (e[5] *= t),
          (e[8] *= t),
          this
        );
      },
      determinant: function () {
        var t = this.elements,
          e = t[0],
          n = t[1],
          r = t[2],
          i = t[3],
          o = t[4],
          a = t[5],
          s = t[6],
          c = t[7],
          u = t[8];
        return (
          e * o * u - e * a * c - n * i * u + n * a * s + r * i * c - r * o * s
        );
      },
      getInverse: function (t, e) {
        t &&
          t.isMatrix4 &&
          console.error(
            "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument."
          );
        var n = t.elements,
          r = this.elements,
          i = n[0],
          o = n[1],
          a = n[2],
          s = n[3],
          c = n[4],
          u = n[5],
          l = n[6],
          h = n[7],
          p = n[8],
          f = p * c - u * h,
          d = u * l - p * s,
          m = h * s - c * l,
          v = i * f + o * d + a * m;
        if (0 === v) {
          var g =
            "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
          if (!0 === e) throw new Error(g);
          return console.warn(g), this.identity();
        }
        var y = 1 / v;
        return (
          (r[0] = f * y),
          (r[1] = (a * h - p * o) * y),
          (r[2] = (u * o - a * c) * y),
          (r[3] = d * y),
          (r[4] = (p * i - a * l) * y),
          (r[5] = (a * s - u * i) * y),
          (r[6] = m * y),
          (r[7] = (o * l - h * i) * y),
          (r[8] = (c * i - o * s) * y),
          this
        );
      },
      transpose: function () {
        var t,
          e = this.elements;
        return (
          (t = e[1]),
          (e[1] = e[3]),
          (e[3] = t),
          (t = e[2]),
          (e[2] = e[6]),
          (e[6] = t),
          (t = e[5]),
          (e[5] = e[7]),
          (e[7] = t),
          this
        );
      },
      getNormalMatrix: function (t) {
        return this.setFromMatrix4(t).getInverse(this).transpose();
      },
      transposeIntoArray: function (t) {
        var e = this.elements;
        return (
          (t[0] = e[0]),
          (t[1] = e[3]),
          (t[2] = e[6]),
          (t[3] = e[1]),
          (t[4] = e[4]),
          (t[5] = e[7]),
          (t[6] = e[2]),
          (t[7] = e[5]),
          (t[8] = e[8]),
          this
        );
      },
      setUvTransform: function (t, e, n, r, i, o, a) {
        var s = Math.cos(i),
          c = Math.sin(i);
        this.set(
          n * s,
          n * c,
          -n * (s * o + c * a) + o + t,
          -r * c,
          r * s,
          -r * (-c * o + s * a) + a + e,
          0,
          0,
          1
        );
      },
      scale: function (t, e) {
        var n = this.elements;
        return (
          (n[0] *= t),
          (n[3] *= t),
          (n[6] *= t),
          (n[1] *= e),
          (n[4] *= e),
          (n[7] *= e),
          this
        );
      },
      rotate: function (t) {
        var e = Math.cos(t),
          n = Math.sin(t),
          r = this.elements,
          i = r[0],
          o = r[3],
          a = r[6],
          s = r[1],
          c = r[4],
          u = r[7];
        return (
          (r[0] = e * i + n * s),
          (r[3] = e * o + n * c),
          (r[6] = e * a + n * u),
          (r[1] = -n * i + e * s),
          (r[4] = -n * o + e * c),
          (r[7] = -n * a + e * u),
          this
        );
      },
      translate: function (t, e) {
        var n = this.elements;
        return (
          (n[0] += t * n[2]),
          (n[3] += t * n[5]),
          (n[6] += t * n[8]),
          (n[1] += e * n[2]),
          (n[4] += e * n[5]),
          (n[7] += e * n[8]),
          this
        );
      },
      equals: function (t) {
        for (var e = this.elements, n = t.elements, r = 0; r < 9; r++)
          if (e[r] !== n[r]) return !1;
        return !0;
      },
      fromArray: function (t, e) {
        void 0 === e && (e = 0);
        for (var n = 0; n < 9; n++) this.elements[n] = t[n + e];
        return this;
      },
      toArray: function (t, e) {
        void 0 === t && (t = []), void 0 === e && (e = 0);
        var n = this.elements;
        return (
          (t[e] = n[0]),
          (t[e + 1] = n[1]),
          (t[e + 2] = n[2]),
          (t[e + 3] = n[3]),
          (t[e + 4] = n[4]),
          (t[e + 5] = n[5]),
          (t[e + 6] = n[6]),
          (t[e + 7] = n[7]),
          (t[e + 8] = n[8]),
          t
        );
      },
    });
    var Ke = {
        getDataURL: function (t) {
          var e;
          if ("undefined" == typeof HTMLCanvasElement) return t.src;
          if (t instanceof HTMLCanvasElement) e = t;
          else {
            void 0 === Je &&
              (Je = document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              )),
              (Je.width = t.width),
              (Je.height = t.height);
            var n = Je.getContext("2d");
            t instanceof ImageData
              ? n.putImageData(t, 0, 0)
              : n.drawImage(t, 0, 0, t.width, t.height),
              (e = Je);
          }
          return e.width > 2048 || e.height > 2048
            ? e.toDataURL("image/jpeg", 0.6)
            : e.toDataURL("image/png");
        },
      },
      $e = 0;
    function tn(t, e, n, r, i, o, a, s, c, u) {
      Object.defineProperty(this, "id", { value: $e++ }),
        (this.uuid = He.generateUUID()),
        (this.name = ""),
        (this.image = void 0 !== t ? t : tn.DEFAULT_IMAGE),
        (this.mipmaps = []),
        (this.mapping = void 0 !== e ? e : tn.DEFAULT_MAPPING),
        (this.wrapS = void 0 !== n ? n : St),
        (this.wrapT = void 0 !== r ? r : St),
        (this.magFilter = void 0 !== i ? i : Pt),
        (this.minFilter = void 0 !== o ? o : Ct),
        (this.anisotropy = void 0 !== c ? c : 1),
        (this.format = void 0 !== a ? a : qt),
        (this.type = void 0 !== s ? s : Ot),
        (this.offset = new ke(0, 0)),
        (this.repeat = new ke(1, 1)),
        (this.center = new ke(0, 0)),
        (this.rotation = 0),
        (this.matrixAutoUpdate = !0),
        (this.matrix = new Qe()),
        (this.generateMipmaps = !0),
        (this.premultiplyAlpha = !1),
        (this.flipY = !0),
        (this.unpackAlignment = 4),
        (this.encoding = void 0 !== u ? u : Te),
        (this.version = 0),
        (this.onUpdate = null);
    }
    function en(t, e, n, r) {
      (this.x = t || 0),
        (this.y = e || 0),
        (this.z = n || 0),
        (this.w = void 0 !== r ? r : 1);
    }
    function nn(t, e, n) {
      (this.width = t),
        (this.height = e),
        (this.scissor = new en(0, 0, t, e)),
        (this.scissorTest = !1),
        (this.viewport = new en(0, 0, t, e)),
        (n = n || {}),
        (this.texture = new tn(
          void 0,
          void 0,
          n.wrapS,
          n.wrapT,
          n.magFilter,
          n.minFilter,
          n.format,
          n.type,
          n.anisotropy,
          n.encoding
        )),
        (this.texture.image = {}),
        (this.texture.image.width = t),
        (this.texture.image.height = e),
        (this.texture.generateMipmaps =
          void 0 !== n.generateMipmaps && n.generateMipmaps),
        (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : Pt),
        (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
        (this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer),
        (this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null);
    }
    function rn(t, e, n) {
      nn.call(this, t, e, n), (this.samples = 4);
    }
    (tn.DEFAULT_IMAGE = void 0),
      (tn.DEFAULT_MAPPING = 300),
      (tn.prototype = Object.assign(Object.create(Ge.prototype), {
        constructor: tn,
        isTexture: !0,
        updateMatrix: function () {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
          );
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return (
            (this.name = t.name),
            (this.image = t.image),
            (this.mipmaps = t.mipmaps.slice(0)),
            (this.mapping = t.mapping),
            (this.wrapS = t.wrapS),
            (this.wrapT = t.wrapT),
            (this.magFilter = t.magFilter),
            (this.minFilter = t.minFilter),
            (this.anisotropy = t.anisotropy),
            (this.format = t.format),
            (this.type = t.type),
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            (this.rotation = t.rotation),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this.matrix.copy(t.matrix),
            (this.generateMipmaps = t.generateMipmaps),
            (this.premultiplyAlpha = t.premultiplyAlpha),
            (this.flipY = t.flipY),
            (this.unpackAlignment = t.unpackAlignment),
            (this.encoding = t.encoding),
            this
          );
        },
        toJSON: function (t) {
          var e = void 0 === t || "string" == typeof t;
          if (!e && void 0 !== t.textures[this.uuid])
            return t.textures[this.uuid];
          var n = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          };
          if (void 0 !== this.image) {
            var r = this.image;
            if (
              (void 0 === r.uuid && (r.uuid = He.generateUUID()),
              !e && void 0 === t.images[r.uuid])
            ) {
              var i;
              if (Array.isArray(r)) {
                i = [];
                for (var o = 0, a = r.length; o < a; o++)
                  i.push(Ke.getDataURL(r[o]));
              } else i = Ke.getDataURL(r);
              t.images[r.uuid] = { uuid: r.uuid, url: i };
            }
            n.image = r.uuid;
          }
          return e || (t.textures[this.uuid] = n), n;
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
        transformUv: function (t) {
          if (300 !== this.mapping) return t;
          if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
            switch (this.wrapS) {
              case Mt:
                t.x = t.x - Math.floor(t.x);
                break;
              case St:
                t.x = t.x < 0 ? 0 : 1;
                break;
              case Et:
                1 === Math.abs(Math.floor(t.x) % 2)
                  ? (t.x = Math.ceil(t.x) - t.x)
                  : (t.x = t.x - Math.floor(t.x));
            }
          if (t.y < 0 || t.y > 1)
            switch (this.wrapT) {
              case Mt:
                t.y = t.y - Math.floor(t.y);
                break;
              case St:
                t.y = t.y < 0 ? 0 : 1;
                break;
              case Et:
                1 === Math.abs(Math.floor(t.y) % 2)
                  ? (t.y = Math.ceil(t.y) - t.y)
                  : (t.y = t.y - Math.floor(t.y));
            }
          return this.flipY && (t.y = 1 - t.y), t;
        },
      })),
      Object.defineProperty(tn.prototype, "needsUpdate", {
        set: function (t) {
          !0 === t && this.version++;
        },
      }),
      Object.defineProperties(en.prototype, {
        width: {
          get: function () {
            return this.z;
          },
          set: function (t) {
            this.z = t;
          },
        },
        height: {
          get: function () {
            return this.w;
          },
          set: function (t) {
            this.w = t;
          },
        },
      }),
      Object.assign(en.prototype, {
        isVector4: !0,
        set: function (t, e, n, r) {
          return (this.x = t), (this.y = e), (this.z = n), (this.w = r), this;
        },
        setScalar: function (t) {
          return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
        },
        setX: function (t) {
          return (this.x = t), this;
        },
        setY: function (t) {
          return (this.y = t), this;
        },
        setZ: function (t) {
          return (this.z = t), this;
        },
        setW: function (t) {
          return (this.w = t), this;
        },
        setComponent: function (t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            case 3:
              this.w = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        },
        getComponent: function (t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + t);
          }
        },
        clone: function () {
          return new this.constructor(this.x, this.y, this.z, this.w);
        },
        copy: function (t) {
          return (
            (this.x = t.x),
            (this.y = t.y),
            (this.z = t.z),
            (this.w = void 0 !== t.w ? t.w : 1),
            this
          );
        },
        add: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(t, e))
            : ((this.x += t.x),
              (this.y += t.y),
              (this.z += t.z),
              (this.w += t.w),
              this);
        },
        addScalar: function (t) {
          return (
            (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
          );
        },
        addVectors: function (t, e) {
          return (
            (this.x = t.x + e.x),
            (this.y = t.y + e.y),
            (this.z = t.z + e.z),
            (this.w = t.w + e.w),
            this
          );
        },
        addScaledVector: function (t, e) {
          return (
            (this.x += t.x * e),
            (this.y += t.y * e),
            (this.z += t.z * e),
            (this.w += t.w * e),
            this
          );
        },
        sub: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x),
              (this.y -= t.y),
              (this.z -= t.z),
              (this.w -= t.w),
              this);
        },
        subScalar: function (t) {
          return (
            (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
          );
        },
        subVectors: function (t, e) {
          return (
            (this.x = t.x - e.x),
            (this.y = t.y - e.y),
            (this.z = t.z - e.z),
            (this.w = t.w - e.w),
            this
          );
        },
        multiplyScalar: function (t) {
          return (
            (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
          );
        },
        applyMatrix4: function (t) {
          var e = this.x,
            n = this.y,
            r = this.z,
            i = this.w,
            o = t.elements;
          return (
            (this.x = o[0] * e + o[4] * n + o[8] * r + o[12] * i),
            (this.y = o[1] * e + o[5] * n + o[9] * r + o[13] * i),
            (this.z = o[2] * e + o[6] * n + o[10] * r + o[14] * i),
            (this.w = o[3] * e + o[7] * n + o[11] * r + o[15] * i),
            this
          );
        },
        divideScalar: function (t) {
          return this.multiplyScalar(1 / t);
        },
        setAxisAngleFromQuaternion: function (t) {
          this.w = 2 * Math.acos(t.w);
          var e = Math.sqrt(1 - t.w * t.w);
          return (
            e < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
            this
          );
        },
        setAxisAngleFromRotationMatrix: function (t) {
          var e,
            n,
            r,
            i,
            o = t.elements,
            a = o[0],
            s = o[4],
            c = o[8],
            u = o[1],
            l = o[5],
            h = o[9],
            p = o[2],
            f = o[6],
            d = o[10];
          if (
            Math.abs(s - u) < 0.01 &&
            Math.abs(c - p) < 0.01 &&
            Math.abs(h - f) < 0.01
          ) {
            if (
              Math.abs(s + u) < 0.1 &&
              Math.abs(c + p) < 0.1 &&
              Math.abs(h + f) < 0.1 &&
              Math.abs(a + l + d - 3) < 0.1
            )
              return this.set(1, 0, 0, 0), this;
            e = Math.PI;
            var m = (a + 1) / 2,
              v = (l + 1) / 2,
              g = (d + 1) / 2,
              y = (s + u) / 4,
              x = (c + p) / 4,
              b = (h + f) / 4;
            return (
              m > v && m > g
                ? m < 0.01
                  ? ((n = 0), (r = 0.707106781), (i = 0.707106781))
                  : ((r = y / (n = Math.sqrt(m))), (i = x / n))
                : v > g
                ? v < 0.01
                  ? ((n = 0.707106781), (r = 0), (i = 0.707106781))
                  : ((n = y / (r = Math.sqrt(v))), (i = b / r))
                : g < 0.01
                ? ((n = 0.707106781), (r = 0.707106781), (i = 0))
                : ((n = x / (i = Math.sqrt(g))), (r = b / i)),
              this.set(n, r, i, e),
              this
            );
          }
          var w = Math.sqrt(
            (f - h) * (f - h) + (c - p) * (c - p) + (u - s) * (u - s)
          );
          return (
            Math.abs(w) < 0.001 && (w = 1),
            (this.x = (f - h) / w),
            (this.y = (c - p) / w),
            (this.z = (u - s) / w),
            (this.w = Math.acos((a + l + d - 1) / 2)),
            this
          );
        },
        min: function (t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            (this.w = Math.min(this.w, t.w)),
            this
          );
        },
        max: function (t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            (this.w = Math.max(this.w, t.w)),
            this
          );
        },
        clamp: function (t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
            (this.w = Math.max(t.w, Math.min(e.w, this.w))),
            this
          );
        },
        clampScalar: function (t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            (this.z = Math.max(t, Math.min(e, this.z))),
            (this.w = Math.max(t, Math.min(e, this.w))),
            this
          );
        },
        clampLength: function (t, e) {
          var n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        },
        floor: function () {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        },
        ceil: function () {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        },
        round: function () {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        },
        roundToZero: function () {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
          );
        },
        negate: function () {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        },
        dot: function (t) {
          return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
        },
        lengthSq: function () {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        },
        length: function () {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        },
        manhattanLength: function () {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        },
        normalize: function () {
          return this.divideScalar(this.length() || 1);
        },
        setLength: function (t) {
          return this.normalize().multiplyScalar(t);
        },
        lerp: function (t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            (this.w += (t.w - this.w) * e),
            this
          );
        },
        lerpVectors: function (t, e, n) {
          return this.subVectors(e, t).multiplyScalar(n).add(t);
        },
        equals: function (t) {
          return (
            t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
          );
        },
        fromArray: function (t, e) {
          return (
            void 0 === e && (e = 0),
            (this.x = t[e]),
            (this.y = t[e + 1]),
            (this.z = t[e + 2]),
            (this.w = t[e + 3]),
            this
          );
        },
        toArray: function (t, e) {
          return (
            void 0 === t && (t = []),
            void 0 === e && (e = 0),
            (t[e] = this.x),
            (t[e + 1] = this.y),
            (t[e + 2] = this.z),
            (t[e + 3] = this.w),
            t
          );
        },
        fromBufferAttribute: function (t, e, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            (this.z = t.getZ(e)),
            (this.w = t.getW(e)),
            this
          );
        },
      }),
      (nn.prototype = Object.assign(Object.create(Ge.prototype), {
        constructor: nn,
        isWebGLRenderTarget: !0,
        setSize: function (t, e) {
          (this.width === t && this.height === e) ||
            ((this.width = t),
            (this.height = e),
            (this.texture.image.width = t),
            (this.texture.image.height = e),
            this.dispose()),
            this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e);
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return (
            (this.width = t.width),
            (this.height = t.height),
            this.viewport.copy(t.viewport),
            (this.texture = t.texture.clone()),
            (this.depthBuffer = t.depthBuffer),
            (this.stencilBuffer = t.stencilBuffer),
            (this.depthTexture = t.depthTexture),
            this
          );
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      })),
      (rn.prototype = Object.assign(Object.create(nn.prototype), {
        constructor: rn,
        isWebGLMultisampleRenderTarget: !0,
        copy: function (t) {
          return (
            nn.prototype.copy.call(this, t), (this.samples = t.samples), this
          );
        },
      }));
    var on = new Ye(),
      an = new pn(),
      sn = new Ye(0, 0, 0),
      cn = new Ye(1, 1, 1),
      un = new Ye(),
      ln = new Ye(),
      hn = new Ye();
    function pn() {
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        arguments.length > 0 &&
          console.error(
            "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
          );
    }
    Object.assign(pn.prototype, {
      isMatrix4: !0,
      set: function (t, e, n, r, i, o, a, s, c, u, l, h, p, f, d, m) {
        var v = this.elements;
        return (
          (v[0] = t),
          (v[4] = e),
          (v[8] = n),
          (v[12] = r),
          (v[1] = i),
          (v[5] = o),
          (v[9] = a),
          (v[13] = s),
          (v[2] = c),
          (v[6] = u),
          (v[10] = l),
          (v[14] = h),
          (v[3] = p),
          (v[7] = f),
          (v[11] = d),
          (v[15] = m),
          this
        );
      },
      identity: function () {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      },
      clone: function () {
        return new pn().fromArray(this.elements);
      },
      copy: function (t) {
        var e = this.elements,
          n = t.elements;
        return (
          (e[0] = n[0]),
          (e[1] = n[1]),
          (e[2] = n[2]),
          (e[3] = n[3]),
          (e[4] = n[4]),
          (e[5] = n[5]),
          (e[6] = n[6]),
          (e[7] = n[7]),
          (e[8] = n[8]),
          (e[9] = n[9]),
          (e[10] = n[10]),
          (e[11] = n[11]),
          (e[12] = n[12]),
          (e[13] = n[13]),
          (e[14] = n[14]),
          (e[15] = n[15]),
          this
        );
      },
      copyPosition: function (t) {
        var e = this.elements,
          n = t.elements;
        return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
      },
      extractBasis: function (t, e, n) {
        return (
          t.setFromMatrixColumn(this, 0),
          e.setFromMatrixColumn(this, 1),
          n.setFromMatrixColumn(this, 2),
          this
        );
      },
      makeBasis: function (t, e, n) {
        return (
          this.set(
            t.x,
            e.x,
            n.x,
            0,
            t.y,
            e.y,
            n.y,
            0,
            t.z,
            e.z,
            n.z,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      },
      extractRotation: function (t) {
        var e = this.elements,
          n = t.elements,
          r = 1 / on.setFromMatrixColumn(t, 0).length(),
          i = 1 / on.setFromMatrixColumn(t, 1).length(),
          o = 1 / on.setFromMatrixColumn(t, 2).length();
        return (
          (e[0] = n[0] * r),
          (e[1] = n[1] * r),
          (e[2] = n[2] * r),
          (e[3] = 0),
          (e[4] = n[4] * i),
          (e[5] = n[5] * i),
          (e[6] = n[6] * i),
          (e[7] = 0),
          (e[8] = n[8] * o),
          (e[9] = n[9] * o),
          (e[10] = n[10] * o),
          (e[11] = 0),
          (e[12] = 0),
          (e[13] = 0),
          (e[14] = 0),
          (e[15] = 1),
          this
        );
      },
      makeRotationFromEuler: function (t) {
        (t && t.isEuler) ||
          console.error(
            "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
          );
        var e = this.elements,
          n = t.x,
          r = t.y,
          i = t.z,
          o = Math.cos(n),
          a = Math.sin(n),
          s = Math.cos(r),
          c = Math.sin(r),
          u = Math.cos(i),
          l = Math.sin(i);
        if ("XYZ" === t.order) {
          var h = o * u,
            p = o * l,
            f = a * u,
            d = a * l;
          (e[0] = s * u),
            (e[4] = -s * l),
            (e[8] = c),
            (e[1] = p + f * c),
            (e[5] = h - d * c),
            (e[9] = -a * s),
            (e[2] = d - h * c),
            (e[6] = f + p * c),
            (e[10] = o * s);
        } else if ("YXZ" === t.order) {
          var m = s * u,
            v = s * l,
            g = c * u,
            y = c * l;
          (e[0] = m + y * a),
            (e[4] = g * a - v),
            (e[8] = o * c),
            (e[1] = o * l),
            (e[5] = o * u),
            (e[9] = -a),
            (e[2] = v * a - g),
            (e[6] = y + m * a),
            (e[10] = o * s);
        } else if ("ZXY" === t.order) {
          (m = s * u), (v = s * l), (g = c * u), (y = c * l);
          (e[0] = m - y * a),
            (e[4] = -o * l),
            (e[8] = g + v * a),
            (e[1] = v + g * a),
            (e[5] = o * u),
            (e[9] = y - m * a),
            (e[2] = -o * c),
            (e[6] = a),
            (e[10] = o * s);
        } else if ("ZYX" === t.order) {
          (h = o * u), (p = o * l), (f = a * u), (d = a * l);
          (e[0] = s * u),
            (e[4] = f * c - p),
            (e[8] = h * c + d),
            (e[1] = s * l),
            (e[5] = d * c + h),
            (e[9] = p * c - f),
            (e[2] = -c),
            (e[6] = a * s),
            (e[10] = o * s);
        } else if ("YZX" === t.order) {
          var x = o * s,
            b = o * c,
            w = a * s,
            _ = a * c;
          (e[0] = s * u),
            (e[4] = _ - x * l),
            (e[8] = w * l + b),
            (e[1] = l),
            (e[5] = o * u),
            (e[9] = -a * u),
            (e[2] = -c * u),
            (e[6] = b * l + w),
            (e[10] = x - _ * l);
        } else if ("XZY" === t.order) {
          (x = o * s), (b = o * c), (w = a * s), (_ = a * c);
          (e[0] = s * u),
            (e[4] = -l),
            (e[8] = c * u),
            (e[1] = x * l + _),
            (e[5] = o * u),
            (e[9] = b * l - w),
            (e[2] = w * l - b),
            (e[6] = a * u),
            (e[10] = _ * l + x);
        }
        return (
          (e[3] = 0),
          (e[7] = 0),
          (e[11] = 0),
          (e[12] = 0),
          (e[13] = 0),
          (e[14] = 0),
          (e[15] = 1),
          this
        );
      },
      makeRotationFromQuaternion: function (t) {
        return this.compose(sn, t, cn);
      },
      lookAt: function (t, e, n) {
        var r = this.elements;
        return (
          hn.subVectors(t, e),
          0 === hn.lengthSq() && (hn.z = 1),
          hn.normalize(),
          un.crossVectors(n, hn),
          0 === un.lengthSq() &&
            (1 === Math.abs(n.z) ? (hn.x += 1e-4) : (hn.z += 1e-4),
            hn.normalize(),
            un.crossVectors(n, hn)),
          un.normalize(),
          ln.crossVectors(hn, un),
          (r[0] = un.x),
          (r[4] = ln.x),
          (r[8] = hn.x),
          (r[1] = un.y),
          (r[5] = ln.y),
          (r[9] = hn.y),
          (r[2] = un.z),
          (r[6] = ln.z),
          (r[10] = hn.z),
          this
        );
      },
      multiply: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
            ),
            this.multiplyMatrices(t, e))
          : this.multiplyMatrices(this, t);
      },
      premultiply: function (t) {
        return this.multiplyMatrices(t, this);
      },
      multiplyMatrices: function (t, e) {
        var n = t.elements,
          r = e.elements,
          i = this.elements,
          o = n[0],
          a = n[4],
          s = n[8],
          c = n[12],
          u = n[1],
          l = n[5],
          h = n[9],
          p = n[13],
          f = n[2],
          d = n[6],
          m = n[10],
          v = n[14],
          g = n[3],
          y = n[7],
          x = n[11],
          b = n[15],
          w = r[0],
          _ = r[4],
          M = r[8],
          S = r[12],
          E = r[1],
          T = r[5],
          A = r[9],
          L = r[13],
          P = r[2],
          R = r[6],
          C = r[10],
          O = r[14],
          I = r[3],
          N = r[7],
          D = r[11],
          z = r[15];
        return (
          (i[0] = o * w + a * E + s * P + c * I),
          (i[4] = o * _ + a * T + s * R + c * N),
          (i[8] = o * M + a * A + s * C + c * D),
          (i[12] = o * S + a * L + s * O + c * z),
          (i[1] = u * w + l * E + h * P + p * I),
          (i[5] = u * _ + l * T + h * R + p * N),
          (i[9] = u * M + l * A + h * C + p * D),
          (i[13] = u * S + l * L + h * O + p * z),
          (i[2] = f * w + d * E + m * P + v * I),
          (i[6] = f * _ + d * T + m * R + v * N),
          (i[10] = f * M + d * A + m * C + v * D),
          (i[14] = f * S + d * L + m * O + v * z),
          (i[3] = g * w + y * E + x * P + b * I),
          (i[7] = g * _ + y * T + x * R + b * N),
          (i[11] = g * M + y * A + x * C + b * D),
          (i[15] = g * S + y * L + x * O + b * z),
          this
        );
      },
      multiplyScalar: function (t) {
        var e = this.elements;
        return (
          (e[0] *= t),
          (e[4] *= t),
          (e[8] *= t),
          (e[12] *= t),
          (e[1] *= t),
          (e[5] *= t),
          (e[9] *= t),
          (e[13] *= t),
          (e[2] *= t),
          (e[6] *= t),
          (e[10] *= t),
          (e[14] *= t),
          (e[3] *= t),
          (e[7] *= t),
          (e[11] *= t),
          (e[15] *= t),
          this
        );
      },
      applyToBufferAttribute: function (t) {
        for (var e = 0, n = t.count; e < n; e++)
          (on.x = t.getX(e)),
            (on.y = t.getY(e)),
            (on.z = t.getZ(e)),
            on.applyMatrix4(this),
            t.setXYZ(e, on.x, on.y, on.z);
        return t;
      },
      determinant: function () {
        var t = this.elements,
          e = t[0],
          n = t[4],
          r = t[8],
          i = t[12],
          o = t[1],
          a = t[5],
          s = t[9],
          c = t[13],
          u = t[2],
          l = t[6],
          h = t[10],
          p = t[14];
        return (
          t[3] *
            (+i * s * l -
              r * c * l -
              i * a * h +
              n * c * h +
              r * a * p -
              n * s * p) +
          t[7] *
            (+e * s * p -
              e * c * h +
              i * o * h -
              r * o * p +
              r * c * u -
              i * s * u) +
          t[11] *
            (+e * c * l -
              e * a * p -
              i * o * l +
              n * o * p +
              i * a * u -
              n * c * u) +
          t[15] *
            (-r * a * u -
              e * s * l +
              e * a * h +
              r * o * l -
              n * o * h +
              n * s * u)
        );
      },
      transpose: function () {
        var t,
          e = this.elements;
        return (
          (t = e[1]),
          (e[1] = e[4]),
          (e[4] = t),
          (t = e[2]),
          (e[2] = e[8]),
          (e[8] = t),
          (t = e[6]),
          (e[6] = e[9]),
          (e[9] = t),
          (t = e[3]),
          (e[3] = e[12]),
          (e[12] = t),
          (t = e[7]),
          (e[7] = e[13]),
          (e[13] = t),
          (t = e[11]),
          (e[11] = e[14]),
          (e[14] = t),
          this
        );
      },
      setPosition: function (t, e, n) {
        var r = this.elements;
        return (
          t.isVector3
            ? ((r[12] = t.x), (r[13] = t.y), (r[14] = t.z))
            : ((r[12] = t), (r[13] = e), (r[14] = n)),
          this
        );
      },
      getInverse: function (t, e) {
        var n = this.elements,
          r = t.elements,
          i = r[0],
          o = r[1],
          a = r[2],
          s = r[3],
          c = r[4],
          u = r[5],
          l = r[6],
          h = r[7],
          p = r[8],
          f = r[9],
          d = r[10],
          m = r[11],
          v = r[12],
          g = r[13],
          y = r[14],
          x = r[15],
          b =
            f * y * h -
            g * d * h +
            g * l * m -
            u * y * m -
            f * l * x +
            u * d * x,
          w =
            v * d * h -
            p * y * h -
            v * l * m +
            c * y * m +
            p * l * x -
            c * d * x,
          _ =
            p * g * h -
            v * f * h +
            v * u * m -
            c * g * m -
            p * u * x +
            c * f * x,
          M =
            v * f * l -
            p * g * l -
            v * u * d +
            c * g * d +
            p * u * y -
            c * f * y,
          S = i * b + o * w + a * _ + s * M;
        if (0 === S) {
          var E =
            "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
          if (!0 === e) throw new Error(E);
          return console.warn(E), this.identity();
        }
        var T = 1 / S;
        return (
          (n[0] = b * T),
          (n[1] =
            (g * d * s -
              f * y * s -
              g * a * m +
              o * y * m +
              f * a * x -
              o * d * x) *
            T),
          (n[2] =
            (u * y * s -
              g * l * s +
              g * a * h -
              o * y * h -
              u * a * x +
              o * l * x) *
            T),
          (n[3] =
            (f * l * s -
              u * d * s -
              f * a * h +
              o * d * h +
              u * a * m -
              o * l * m) *
            T),
          (n[4] = w * T),
          (n[5] =
            (p * y * s -
              v * d * s +
              v * a * m -
              i * y * m -
              p * a * x +
              i * d * x) *
            T),
          (n[6] =
            (v * l * s -
              c * y * s -
              v * a * h +
              i * y * h +
              c * a * x -
              i * l * x) *
            T),
          (n[7] =
            (c * d * s -
              p * l * s +
              p * a * h -
              i * d * h -
              c * a * m +
              i * l * m) *
            T),
          (n[8] = _ * T),
          (n[9] =
            (v * f * s -
              p * g * s -
              v * o * m +
              i * g * m +
              p * o * x -
              i * f * x) *
            T),
          (n[10] =
            (c * g * s -
              v * u * s +
              v * o * h -
              i * g * h -
              c * o * x +
              i * u * x) *
            T),
          (n[11] =
            (p * u * s -
              c * f * s -
              p * o * h +
              i * f * h +
              c * o * m -
              i * u * m) *
            T),
          (n[12] = M * T),
          (n[13] =
            (p * g * a -
              v * f * a +
              v * o * d -
              i * g * d -
              p * o * y +
              i * f * y) *
            T),
          (n[14] =
            (v * u * a -
              c * g * a -
              v * o * l +
              i * g * l +
              c * o * y -
              i * u * y) *
            T),
          (n[15] =
            (c * f * a -
              p * u * a +
              p * o * l -
              i * f * l -
              c * o * d +
              i * u * d) *
            T),
          this
        );
      },
      scale: function (t) {
        var e = this.elements,
          n = t.x,
          r = t.y,
          i = t.z;
        return (
          (e[0] *= n),
          (e[4] *= r),
          (e[8] *= i),
          (e[1] *= n),
          (e[5] *= r),
          (e[9] *= i),
          (e[2] *= n),
          (e[6] *= r),
          (e[10] *= i),
          (e[3] *= n),
          (e[7] *= r),
          (e[11] *= i),
          this
        );
      },
      getMaxScaleOnAxis: function () {
        var t = this.elements,
          e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
          n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
          r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
        return Math.sqrt(Math.max(e, n, r));
      },
      makeTranslation: function (t, e, n) {
        return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
      },
      makeRotationX: function (t) {
        var e = Math.cos(t),
          n = Math.sin(t);
        return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
      },
      makeRotationY: function (t) {
        var e = Math.cos(t),
          n = Math.sin(t);
        return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
      },
      makeRotationZ: function (t) {
        var e = Math.cos(t),
          n = Math.sin(t);
        return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      },
      makeRotationAxis: function (t, e) {
        var n = Math.cos(e),
          r = Math.sin(e),
          i = 1 - n,
          o = t.x,
          a = t.y,
          s = t.z,
          c = i * o,
          u = i * a;
        return (
          this.set(
            c * o + n,
            c * a - r * s,
            c * s + r * a,
            0,
            c * a + r * s,
            u * a + n,
            u * s - r * o,
            0,
            c * s - r * a,
            u * s + r * o,
            i * s * s + n,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      },
      makeScale: function (t, e, n) {
        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
      },
      makeShear: function (t, e, n) {
        return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this;
      },
      compose: function (t, e, n) {
        var r = this.elements,
          i = e._x,
          o = e._y,
          a = e._z,
          s = e._w,
          c = i + i,
          u = o + o,
          l = a + a,
          h = i * c,
          p = i * u,
          f = i * l,
          d = o * u,
          m = o * l,
          v = a * l,
          g = s * c,
          y = s * u,
          x = s * l,
          b = n.x,
          w = n.y,
          _ = n.z;
        return (
          (r[0] = (1 - (d + v)) * b),
          (r[1] = (p + x) * b),
          (r[2] = (f - y) * b),
          (r[3] = 0),
          (r[4] = (p - x) * w),
          (r[5] = (1 - (h + v)) * w),
          (r[6] = (m + g) * w),
          (r[7] = 0),
          (r[8] = (f + y) * _),
          (r[9] = (m - g) * _),
          (r[10] = (1 - (h + d)) * _),
          (r[11] = 0),
          (r[12] = t.x),
          (r[13] = t.y),
          (r[14] = t.z),
          (r[15] = 1),
          this
        );
      },
      decompose: function (t, e, n) {
        var r = this.elements,
          i = on.set(r[0], r[1], r[2]).length(),
          o = on.set(r[4], r[5], r[6]).length(),
          a = on.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (i = -i),
          (t.x = r[12]),
          (t.y = r[13]),
          (t.z = r[14]),
          an.copy(this);
        var s = 1 / i,
          c = 1 / o,
          u = 1 / a;
        return (
          (an.elements[0] *= s),
          (an.elements[1] *= s),
          (an.elements[2] *= s),
          (an.elements[4] *= c),
          (an.elements[5] *= c),
          (an.elements[6] *= c),
          (an.elements[8] *= u),
          (an.elements[9] *= u),
          (an.elements[10] *= u),
          e.setFromRotationMatrix(an),
          (n.x = i),
          (n.y = o),
          (n.z = a),
          this
        );
      },
      makePerspective: function (t, e, n, r, i, o) {
        void 0 === o &&
          console.warn(
            "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
          );
        var a = this.elements,
          s = (2 * i) / (e - t),
          c = (2 * i) / (n - r),
          u = (e + t) / (e - t),
          l = (n + r) / (n - r),
          h = -(o + i) / (o - i),
          p = (-2 * o * i) / (o - i);
        return (
          (a[0] = s),
          (a[4] = 0),
          (a[8] = u),
          (a[12] = 0),
          (a[1] = 0),
          (a[5] = c),
          (a[9] = l),
          (a[13] = 0),
          (a[2] = 0),
          (a[6] = 0),
          (a[10] = h),
          (a[14] = p),
          (a[3] = 0),
          (a[7] = 0),
          (a[11] = -1),
          (a[15] = 0),
          this
        );
      },
      makeOrthographic: function (t, e, n, r, i, o) {
        var a = this.elements,
          s = 1 / (e - t),
          c = 1 / (n - r),
          u = 1 / (o - i),
          l = (e + t) * s,
          h = (n + r) * c,
          p = (o + i) * u;
        return (
          (a[0] = 2 * s),
          (a[4] = 0),
          (a[8] = 0),
          (a[12] = -l),
          (a[1] = 0),
          (a[5] = 2 * c),
          (a[9] = 0),
          (a[13] = -h),
          (a[2] = 0),
          (a[6] = 0),
          (a[10] = -2 * u),
          (a[14] = -p),
          (a[3] = 0),
          (a[7] = 0),
          (a[11] = 0),
          (a[15] = 1),
          this
        );
      },
      equals: function (t) {
        for (var e = this.elements, n = t.elements, r = 0; r < 16; r++)
          if (e[r] !== n[r]) return !1;
        return !0;
      },
      fromArray: function (t, e) {
        void 0 === e && (e = 0);
        for (var n = 0; n < 16; n++) this.elements[n] = t[n + e];
        return this;
      },
      toArray: function (t, e) {
        void 0 === t && (t = []), void 0 === e && (e = 0);
        var n = this.elements;
        return (
          (t[e] = n[0]),
          (t[e + 1] = n[1]),
          (t[e + 2] = n[2]),
          (t[e + 3] = n[3]),
          (t[e + 4] = n[4]),
          (t[e + 5] = n[5]),
          (t[e + 6] = n[6]),
          (t[e + 7] = n[7]),
          (t[e + 8] = n[8]),
          (t[e + 9] = n[9]),
          (t[e + 10] = n[10]),
          (t[e + 11] = n[11]),
          (t[e + 12] = n[12]),
          (t[e + 13] = n[13]),
          (t[e + 14] = n[14]),
          (t[e + 15] = n[15]),
          t
        );
      },
    });
    var fn = new pn(),
      dn = new We();
    function mn(t, e, n, r) {
      (this._x = t || 0),
        (this._y = e || 0),
        (this._z = n || 0),
        (this._order = r || mn.DefaultOrder);
    }
    function vn() {
      this.mask = 1;
    }
    (mn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]),
      (mn.DefaultOrder = "XYZ"),
      Object.defineProperties(mn.prototype, {
        x: {
          get: function () {
            return this._x;
          },
          set: function (t) {
            (this._x = t), this._onChangeCallback();
          },
        },
        y: {
          get: function () {
            return this._y;
          },
          set: function (t) {
            (this._y = t), this._onChangeCallback();
          },
        },
        z: {
          get: function () {
            return this._z;
          },
          set: function (t) {
            (this._z = t), this._onChangeCallback();
          },
        },
        order: {
          get: function () {
            return this._order;
          },
          set: function (t) {
            (this._order = t), this._onChangeCallback();
          },
        },
      }),
      Object.assign(mn.prototype, {
        isEuler: !0,
        set: function (t, e, n, r) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._order = r || this._order),
            this._onChangeCallback(),
            this
          );
        },
        clone: function () {
          return new this.constructor(this._x, this._y, this._z, this._order);
        },
        copy: function (t) {
          return (
            (this._x = t._x),
            (this._y = t._y),
            (this._z = t._z),
            (this._order = t._order),
            this._onChangeCallback(),
            this
          );
        },
        setFromRotationMatrix: function (t, e, n) {
          var r = He.clamp,
            i = t.elements,
            o = i[0],
            a = i[4],
            s = i[8],
            c = i[1],
            u = i[5],
            l = i[9],
            h = i[2],
            p = i[6],
            f = i[10];
          return (
            "XYZ" === (e = e || this._order)
              ? ((this._y = Math.asin(r(s, -1, 1))),
                Math.abs(s) < 0.9999999
                  ? ((this._x = Math.atan2(-l, f)),
                    (this._z = Math.atan2(-a, o)))
                  : ((this._x = Math.atan2(p, u)), (this._z = 0)))
              : "YXZ" === e
              ? ((this._x = Math.asin(-r(l, -1, 1))),
                Math.abs(l) < 0.9999999
                  ? ((this._y = Math.atan2(s, f)), (this._z = Math.atan2(c, u)))
                  : ((this._y = Math.atan2(-h, o)), (this._z = 0)))
              : "ZXY" === e
              ? ((this._x = Math.asin(r(p, -1, 1))),
                Math.abs(p) < 0.9999999
                  ? ((this._y = Math.atan2(-h, f)),
                    (this._z = Math.atan2(-a, u)))
                  : ((this._y = 0), (this._z = Math.atan2(c, o))))
              : "ZYX" === e
              ? ((this._y = Math.asin(-r(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._x = Math.atan2(p, f)), (this._z = Math.atan2(c, o)))
                  : ((this._x = 0), (this._z = Math.atan2(-a, u))))
              : "YZX" === e
              ? ((this._z = Math.asin(r(c, -1, 1))),
                Math.abs(c) < 0.9999999
                  ? ((this._x = Math.atan2(-l, u)),
                    (this._y = Math.atan2(-h, o)))
                  : ((this._x = 0), (this._y = Math.atan2(s, f))))
              : "XZY" === e
              ? ((this._z = Math.asin(-r(a, -1, 1))),
                Math.abs(a) < 0.9999999
                  ? ((this._x = Math.atan2(p, u)), (this._y = Math.atan2(s, o)))
                  : ((this._x = Math.atan2(-l, f)), (this._y = 0)))
              : console.warn(
                  "THREE.Euler: .setFromRotationMatrix() given unsupported order: " +
                    e
                ),
            (this._order = e),
            !1 !== n && this._onChangeCallback(),
            this
          );
        },
        setFromQuaternion: function (t, e, n) {
          return (
            fn.makeRotationFromQuaternion(t),
            this.setFromRotationMatrix(fn, e, n)
          );
        },
        setFromVector3: function (t, e) {
          return this.set(t.x, t.y, t.z, e || this._order);
        },
        reorder: function (t) {
          return dn.setFromEuler(this), this.setFromQuaternion(dn, t);
        },
        equals: function (t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._order === this._order
          );
        },
        fromArray: function (t) {
          return (
            (this._x = t[0]),
            (this._y = t[1]),
            (this._z = t[2]),
            void 0 !== t[3] && (this._order = t[3]),
            this._onChangeCallback(),
            this
          );
        },
        toArray: function (t, e) {
          return (
            void 0 === t && (t = []),
            void 0 === e && (e = 0),
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._order),
            t
          );
        },
        toVector3: function (t) {
          return t
            ? t.set(this._x, this._y, this._z)
            : new Ye(this._x, this._y, this._z);
        },
        _onChange: function (t) {
          return (this._onChangeCallback = t), this;
        },
        _onChangeCallback: function () {},
      }),
      Object.assign(vn.prototype, {
        set: function (t) {
          this.mask = (1 << t) | 0;
        },
        enable: function (t) {
          this.mask |= (1 << t) | 0;
        },
        enableAll: function () {
          this.mask = -1;
        },
        toggle: function (t) {
          this.mask ^= (1 << t) | 0;
        },
        disable: function (t) {
          this.mask &= ~((1 << t) | 0);
        },
        disableAll: function () {
          this.mask = 0;
        },
        test: function (t) {
          return 0 != (this.mask & t.mask);
        },
      });
    var gn = 0,
      yn = new Ye(),
      xn = new We(),
      bn = new pn(),
      wn = new Ye(),
      _n = new Ye(),
      Mn = new Ye(),
      Sn = new We(),
      En = new Ye(1, 0, 0),
      Tn = new Ye(0, 1, 0),
      An = new Ye(0, 0, 1),
      Ln = { type: "added" },
      Pn = { type: "removed" };
    function Rn() {
      Object.defineProperty(this, "id", { value: gn++ }),
        (this.uuid = He.generateUUID()),
        (this.name = ""),
        (this.type = "Object3D"),
        (this.parent = null),
        (this.children = []),
        (this.up = Rn.DefaultUp.clone());
      var t = new Ye(),
        e = new mn(),
        n = new We(),
        r = new Ye(1, 1, 1);
      e._onChange(function () {
        n.setFromEuler(e, !1);
      }),
        n._onChange(function () {
          e.setFromQuaternion(n, void 0, !1);
        }),
        Object.defineProperties(this, {
          position: { configurable: !0, enumerable: !0, value: t },
          rotation: { configurable: !0, enumerable: !0, value: e },
          quaternion: { configurable: !0, enumerable: !0, value: n },
          scale: { configurable: !0, enumerable: !0, value: r },
          modelViewMatrix: { value: new pn() },
          normalMatrix: { value: new Qe() },
        }),
        (this.matrix = new pn()),
        (this.matrixWorld = new pn()),
        (this.matrixAutoUpdate = Rn.DefaultMatrixAutoUpdate),
        (this.matrixWorldNeedsUpdate = !1),
        (this.layers = new vn()),
        (this.visible = !0),
        (this.castShadow = !1),
        (this.receiveShadow = !1),
        (this.frustumCulled = !0),
        (this.renderOrder = 0),
        (this.userData = {});
    }
    function Cn() {
      Rn.call(this),
        (this.type = "Scene"),
        (this.background = null),
        (this.fog = null),
        (this.overrideMaterial = null),
        (this.autoUpdate = !0),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    (Rn.DefaultUp = new Ye(0, 1, 0)),
      (Rn.DefaultMatrixAutoUpdate = !0),
      (Rn.prototype = Object.assign(Object.create(Ge.prototype), {
        constructor: Rn,
        isObject3D: !0,
        onBeforeRender: function () {},
        onAfterRender: function () {},
        applyMatrix: function (t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(t),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        },
        applyQuaternion: function (t) {
          return this.quaternion.premultiply(t), this;
        },
        setRotationFromAxisAngle: function (t, e) {
          this.quaternion.setFromAxisAngle(t, e);
        },
        setRotationFromEuler: function (t) {
          this.quaternion.setFromEuler(t, !0);
        },
        setRotationFromMatrix: function (t) {
          this.quaternion.setFromRotationMatrix(t);
        },
        setRotationFromQuaternion: function (t) {
          this.quaternion.copy(t);
        },
        rotateOnAxis: function (t, e) {
          return xn.setFromAxisAngle(t, e), this.quaternion.multiply(xn), this;
        },
        rotateOnWorldAxis: function (t, e) {
          return (
            xn.setFromAxisAngle(t, e), this.quaternion.premultiply(xn), this
          );
        },
        rotateX: function (t) {
          return this.rotateOnAxis(En, t);
        },
        rotateY: function (t) {
          return this.rotateOnAxis(Tn, t);
        },
        rotateZ: function (t) {
          return this.rotateOnAxis(An, t);
        },
        translateOnAxis: function (t, e) {
          return (
            yn.copy(t).applyQuaternion(this.quaternion),
            this.position.add(yn.multiplyScalar(e)),
            this
          );
        },
        translateX: function (t) {
          return this.translateOnAxis(En, t);
        },
        translateY: function (t) {
          return this.translateOnAxis(Tn, t);
        },
        translateZ: function (t) {
          return this.translateOnAxis(An, t);
        },
        localToWorld: function (t) {
          return t.applyMatrix4(this.matrixWorld);
        },
        worldToLocal: function (t) {
          return t.applyMatrix4(bn.getInverse(this.matrixWorld));
        },
        lookAt: function (t, e, n) {
          t.isVector3 ? wn.copy(t) : wn.set(t, e, n);
          var r = this.parent;
          this.updateWorldMatrix(!0, !1),
            _n.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? bn.lookAt(_n, wn, this.up)
              : bn.lookAt(wn, _n, this.up),
            this.quaternion.setFromRotationMatrix(bn),
            r &&
              (bn.extractRotation(r.matrixWorld),
              xn.setFromRotationMatrix(bn),
              this.quaternion.premultiply(xn.inverse()));
        },
        add: function (t) {
          if (arguments.length > 1) {
            for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
            return this;
          }
          return t === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                t
              ),
              this)
            : (t && t.isObject3D
                ? (null !== t.parent && t.parent.remove(t),
                  (t.parent = this),
                  this.children.push(t),
                  t.dispatchEvent(Ln))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    t
                  ),
              this);
        },
        remove: function (t) {
          if (arguments.length > 1) {
            for (var e = 0; e < arguments.length; e++)
              this.remove(arguments[e]);
            return this;
          }
          var n = this.children.indexOf(t);
          return (
            -1 !== n &&
              ((t.parent = null),
              this.children.splice(n, 1),
              t.dispatchEvent(Pn)),
            this
          );
        },
        attach: function (t) {
          return (
            this.updateWorldMatrix(!0, !1),
            bn.getInverse(this.matrixWorld),
            null !== t.parent &&
              (t.parent.updateWorldMatrix(!0, !1),
              bn.multiply(t.parent.matrixWorld)),
            t.applyMatrix(bn),
            t.updateWorldMatrix(!1, !1),
            this.add(t),
            this
          );
        },
        getObjectById: function (t) {
          return this.getObjectByProperty("id", t);
        },
        getObjectByName: function (t) {
          return this.getObjectByProperty("name", t);
        },
        getObjectByProperty: function (t, e) {
          if (this[t] === e) return this;
          for (var n = 0, r = this.children.length; n < r; n++) {
            var i = this.children[n].getObjectByProperty(t, e);
            if (void 0 !== i) return i;
          }
        },
        getWorldPosition: function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Object3D: .getWorldPosition() target is now required"
              ),
              (t = new Ye())),
            this.updateMatrixWorld(!0),
            t.setFromMatrixPosition(this.matrixWorld)
          );
        },
        getWorldQuaternion: function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Object3D: .getWorldQuaternion() target is now required"
              ),
              (t = new We())),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(_n, t, Mn),
            t
          );
        },
        getWorldScale: function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Object3D: .getWorldScale() target is now required"
              ),
              (t = new Ye())),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(_n, Sn, t),
            t
          );
        },
        getWorldDirection: function (t) {
          void 0 === t &&
            (console.warn(
              "THREE.Object3D: .getWorldDirection() target is now required"
            ),
            (t = new Ye())),
            this.updateMatrixWorld(!0);
          var e = this.matrixWorld.elements;
          return t.set(e[8], e[9], e[10]).normalize();
        },
        raycast: function () {},
        traverse: function (t) {
          t(this);
          for (var e = this.children, n = 0, r = e.length; n < r; n++)
            e[n].traverse(t);
        },
        traverseVisible: function (t) {
          if (!1 !== this.visible) {
            t(this);
            for (var e = this.children, n = 0, r = e.length; n < r; n++)
              e[n].traverseVisible(t);
          }
        },
        traverseAncestors: function (t) {
          var e = this.parent;
          null !== e && (t(e), e.traverseAncestors(t));
        },
        updateMatrix: function () {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        },
        updateMatrixWorld: function (t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) &&
              (null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              (this.matrixWorldNeedsUpdate = !1),
              (t = !0));
          for (var e = this.children, n = 0, r = e.length; n < r; n++)
            e[n].updateMatrixWorld(t);
        },
        updateWorldMatrix: function (t, e) {
          var n = this.parent;
          if (
            (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            !0 === e)
          )
            for (var r = this.children, i = 0, o = r.length; i < o; i++)
              r[i].updateWorldMatrix(!1, !0);
        },
        toJSON: function (t) {
          var e = void 0 === t || "string" == typeof t,
            n = {};
          e &&
            ((t = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
            }),
            (n.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          var r = {};
          function i(e, n) {
            return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
          }
          if (
            ((r.uuid = this.uuid),
            (r.type = this.type),
            "" !== this.name && (r.name = this.name),
            !0 === this.castShadow && (r.castShadow = !0),
            !0 === this.receiveShadow && (r.receiveShadow = !0),
            !1 === this.visible && (r.visible = !1),
            !1 === this.frustumCulled && (r.frustumCulled = !1),
            0 !== this.renderOrder && (r.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) &&
              (r.userData = this.userData),
            (r.layers = this.layers.mask),
            (r.matrix = this.matrix.toArray()),
            !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1),
            this.isMesh && this.drawMode !== Me && (r.drawMode = this.drawMode),
            this.isMesh || this.isLine || this.isPoints)
          ) {
            r.geometry = i(t.geometries, this.geometry);
            var o = this.geometry.parameters;
            if (void 0 !== o && void 0 !== o.shapes) {
              var a = o.shapes;
              if (Array.isArray(a))
                for (var s = 0, c = a.length; s < c; s++) {
                  var u = a[s];
                  i(t.shapes, u);
                }
              else i(t.shapes, a);
            }
          }
          if (void 0 !== this.material)
            if (Array.isArray(this.material)) {
              var l = [];
              for (s = 0, c = this.material.length; s < c; s++)
                l.push(i(t.materials, this.material[s]));
              r.material = l;
            } else r.material = i(t.materials, this.material);
          if (this.children.length > 0) {
            r.children = [];
            for (s = 0; s < this.children.length; s++)
              r.children.push(this.children[s].toJSON(t).object);
          }
          if (e) {
            var h = m(t.geometries),
              p = m(t.materials),
              f = m(t.textures),
              d = m(t.images);
            a = m(t.shapes);
            h.length > 0 && (n.geometries = h),
              p.length > 0 && (n.materials = p),
              f.length > 0 && (n.textures = f),
              d.length > 0 && (n.images = d),
              a.length > 0 && (n.shapes = a);
          }
          return (n.object = r), n;
          function m(t) {
            var e = [];
            for (var n in t) {
              var r = t[n];
              delete r.metadata, e.push(r);
            }
            return e;
          }
        },
        clone: function (t) {
          return new this.constructor().copy(this, t);
        },
        copy: function (t, e) {
          if (
            (void 0 === e && (e = !0),
            (this.name = t.name),
            this.up.copy(t.up),
            this.position.copy(t.position),
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
            (this.layers.mask = t.layers.mask),
            (this.visible = t.visible),
            (this.castShadow = t.castShadow),
            (this.receiveShadow = t.receiveShadow),
            (this.frustumCulled = t.frustumCulled),
            (this.renderOrder = t.renderOrder),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            !0 === e)
          )
            for (var n = 0; n < t.children.length; n++) {
              var r = t.children[n];
              this.add(r.clone());
            }
          return this;
        },
      })),
      (Cn.prototype = Object.assign(Object.create(Rn.prototype), {
        constructor: Cn,
        isScene: !0,
        copy: function (t, e) {
          return (
            Rn.prototype.copy.call(this, t, e),
            null !== t.background && (this.background = t.background.clone()),
            null !== t.fog && (this.fog = t.fog.clone()),
            null !== t.overrideMaterial &&
              (this.overrideMaterial = t.overrideMaterial.clone()),
            (this.autoUpdate = t.autoUpdate),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this
          );
        },
        toJSON: function (t) {
          var e = Rn.prototype.toJSON.call(this, t);
          return (
            null !== this.background &&
              (e.object.background = this.background.toJSON(t)),
            null !== this.fog && (e.object.fog = this.fog.toJSON()),
            e
          );
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      }));
    var On = [
        new Ye(),
        new Ye(),
        new Ye(),
        new Ye(),
        new Ye(),
        new Ye(),
        new Ye(),
        new Ye(),
      ],
      In = new Ye(),
      Nn = new Ye(),
      Dn = new Ye(),
      zn = new Ye(),
      Fn = new Ye(),
      Un = new Ye(),
      Bn = new Ye(),
      Gn = new Ye(),
      jn = new Ye(),
      Vn = new Ye(),
      Hn = new Ye();
    function kn(t, e) {
      (this.min = void 0 !== t ? t : new Ye(1 / 0, 1 / 0, 1 / 0)),
        (this.max = void 0 !== e ? e : new Ye(-1 / 0, -1 / 0, -1 / 0));
    }
    function Wn(t, e, n, r, i) {
      var o, a;
      for (o = 0, a = t.length - 3; o <= a; o += 3) {
        Hn.fromArray(t, o);
        var s =
            i.x * Math.abs(Hn.x) + i.y * Math.abs(Hn.y) + i.z * Math.abs(Hn.z),
          c = e.dot(Hn),
          u = n.dot(Hn),
          l = r.dot(Hn);
        if (Math.max(-Math.max(c, u, l), Math.min(c, u, l)) > s) return !1;
      }
      return !0;
    }
    Object.assign(kn.prototype, {
      isBox3: !0,
      set: function (t, e) {
        return this.min.copy(t), this.max.copy(e), this;
      },
      setFromArray: function (t) {
        for (
          var e = 1 / 0,
            n = 1 / 0,
            r = 1 / 0,
            i = -1 / 0,
            o = -1 / 0,
            a = -1 / 0,
            s = 0,
            c = t.length;
          s < c;
          s += 3
        ) {
          var u = t[s],
            l = t[s + 1],
            h = t[s + 2];
          u < e && (e = u),
            l < n && (n = l),
            h < r && (r = h),
            u > i && (i = u),
            l > o && (o = l),
            h > a && (a = h);
        }
        return this.min.set(e, n, r), this.max.set(i, o, a), this;
      },
      setFromBufferAttribute: function (t) {
        for (
          var e = 1 / 0,
            n = 1 / 0,
            r = 1 / 0,
            i = -1 / 0,
            o = -1 / 0,
            a = -1 / 0,
            s = 0,
            c = t.count;
          s < c;
          s++
        ) {
          var u = t.getX(s),
            l = t.getY(s),
            h = t.getZ(s);
          u < e && (e = u),
            l < n && (n = l),
            h < r && (r = h),
            u > i && (i = u),
            l > o && (o = l),
            h > a && (a = h);
        }
        return this.min.set(e, n, r), this.max.set(i, o, a), this;
      },
      setFromPoints: function (t) {
        this.makeEmpty();
        for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
        return this;
      },
      setFromCenterAndSize: function (t, e) {
        var n = In.copy(e).multiplyScalar(0.5);
        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
      },
      setFromObject: function (t) {
        return this.makeEmpty(), this.expandByObject(t);
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.min.copy(t.min), this.max.copy(t.max), this;
      },
      makeEmpty: function () {
        return (
          (this.min.x = this.min.y = this.min.z = 1 / 0),
          (this.max.x = this.max.y = this.max.z = -1 / 0),
          this
        );
      },
      isEmpty: function () {
        return (
          this.max.x < this.min.x ||
          this.max.y < this.min.y ||
          this.max.z < this.min.z
        );
      },
      getCenter: function (t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box3: .getCenter() target is now required"),
            (t = new Ye())),
          this.isEmpty()
            ? t.set(0, 0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5)
        );
      },
      getSize: function (t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box3: .getSize() target is now required"),
            (t = new Ye())),
          this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        );
      },
      expandByPoint: function (t) {
        return this.min.min(t), this.max.max(t), this;
      },
      expandByVector: function (t) {
        return this.min.sub(t), this.max.add(t), this;
      },
      expandByScalar: function (t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this;
      },
      expandByObject: function (t) {
        var e, n;
        t.updateWorldMatrix(!1, !1);
        var r = t.geometry;
        if (void 0 !== r)
          if (r.isGeometry) {
            var i = r.vertices;
            for (e = 0, n = i.length; e < n; e++)
              In.copy(i[e]),
                In.applyMatrix4(t.matrixWorld),
                this.expandByPoint(In);
          } else if (r.isBufferGeometry) {
            var o = r.attributes.position;
            if (void 0 !== o)
              for (e = 0, n = o.count; e < n; e++)
                In.fromBufferAttribute(o, e).applyMatrix4(t.matrixWorld),
                  this.expandByPoint(In);
          }
        var a = t.children;
        for (e = 0, n = a.length; e < n; e++) this.expandByObject(a[e]);
        return this;
      },
      containsPoint: function (t) {
        return !(
          t.x < this.min.x ||
          t.x > this.max.x ||
          t.y < this.min.y ||
          t.y > this.max.y ||
          t.z < this.min.z ||
          t.z > this.max.z
        );
      },
      containsBox: function (t) {
        return (
          this.min.x <= t.min.x &&
          t.max.x <= this.max.x &&
          this.min.y <= t.min.y &&
          t.max.y <= this.max.y &&
          this.min.z <= t.min.z &&
          t.max.z <= this.max.z
        );
      },
      getParameter: function (t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Box3: .getParameter() target is now required"),
            (e = new Ye())),
          e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y),
            (t.z - this.min.z) / (this.max.z - this.min.z)
          )
        );
      },
      intersectsBox: function (t) {
        return !(
          t.max.x < this.min.x ||
          t.min.x > this.max.x ||
          t.max.y < this.min.y ||
          t.min.y > this.max.y ||
          t.max.z < this.min.z ||
          t.min.z > this.max.z
        );
      },
      intersectsSphere: function (t) {
        return (
          this.clampPoint(t.center, In),
          In.distanceToSquared(t.center) <= t.radius * t.radius
        );
      },
      intersectsPlane: function (t) {
        var e, n;
        return (
          t.normal.x > 0
            ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
            : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
          t.normal.y > 0
            ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
            : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
          t.normal.z > 0
            ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
            : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
          e <= -t.constant && n >= -t.constant
        );
      },
      intersectsTriangle: function (t) {
        if (this.isEmpty()) return !1;
        this.getCenter(Gn),
          jn.subVectors(this.max, Gn),
          Nn.subVectors(t.a, Gn),
          Dn.subVectors(t.b, Gn),
          zn.subVectors(t.c, Gn),
          Fn.subVectors(Dn, Nn),
          Un.subVectors(zn, Dn),
          Bn.subVectors(Nn, zn);
        var e = [
          0,
          -Fn.z,
          Fn.y,
          0,
          -Un.z,
          Un.y,
          0,
          -Bn.z,
          Bn.y,
          Fn.z,
          0,
          -Fn.x,
          Un.z,
          0,
          -Un.x,
          Bn.z,
          0,
          -Bn.x,
          -Fn.y,
          Fn.x,
          0,
          -Un.y,
          Un.x,
          0,
          -Bn.y,
          Bn.x,
          0,
        ];
        return (
          !!Wn(e, Nn, Dn, zn, jn) &&
          !!Wn((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]), Nn, Dn, zn, jn) &&
          (Vn.crossVectors(Fn, Un),
          Wn((e = [Vn.x, Vn.y, Vn.z]), Nn, Dn, zn, jn))
        );
      },
      clampPoint: function (t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Box3: .clampPoint() target is now required"),
            (e = new Ye())),
          e.copy(t).clamp(this.min, this.max)
        );
      },
      distanceToPoint: function (t) {
        return In.copy(t).clamp(this.min, this.max).sub(t).length();
      },
      getBoundingSphere: function (t) {
        return (
          void 0 === t &&
            console.error(
              "THREE.Box3: .getBoundingSphere() target is now required"
            ),
          this.getCenter(t.center),
          (t.radius = 0.5 * this.getSize(In).length()),
          t
        );
      },
      intersect: function (t) {
        return (
          this.min.max(t.min),
          this.max.min(t.max),
          this.isEmpty() && this.makeEmpty(),
          this
        );
      },
      union: function (t) {
        return this.min.min(t.min), this.max.max(t.max), this;
      },
      applyMatrix4: function (t) {
        return this.isEmpty()
          ? this
          : (On[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
            On[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
            On[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
            On[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
            On[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
            On[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
            On[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
            On[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
            this.setFromPoints(On),
            this);
      },
      translate: function (t) {
        return this.min.add(t), this.max.add(t), this;
      },
      equals: function (t) {
        return t.min.equals(this.min) && t.max.equals(this.max);
      },
    });
    var qn = new kn();
    function Xn(t, e) {
      (this.center = void 0 !== t ? t : new Ye()),
        (this.radius = void 0 !== e ? e : 0);
    }
    Object.assign(Xn.prototype, {
      set: function (t, e) {
        return this.center.copy(t), (this.radius = e), this;
      },
      setFromPoints: function (t, e) {
        var n = this.center;
        void 0 !== e ? n.copy(e) : qn.setFromPoints(t).getCenter(n);
        for (var r = 0, i = 0, o = t.length; i < o; i++)
          r = Math.max(r, n.distanceToSquared(t[i]));
        return (this.radius = Math.sqrt(r)), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.center.copy(t.center), (this.radius = t.radius), this;
      },
      empty: function () {
        return this.radius <= 0;
      },
      containsPoint: function (t) {
        return t.distanceToSquared(this.center) <= this.radius * this.radius;
      },
      distanceToPoint: function (t) {
        return t.distanceTo(this.center) - this.radius;
      },
      intersectsSphere: function (t) {
        var e = this.radius + t.radius;
        return t.center.distanceToSquared(this.center) <= e * e;
      },
      intersectsBox: function (t) {
        return t.intersectsSphere(this);
      },
      intersectsPlane: function (t) {
        return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
      },
      clampPoint: function (t, e) {
        var n = this.center.distanceToSquared(t);
        return (
          void 0 === e &&
            (console.warn("THREE.Sphere: .clampPoint() target is now required"),
            (e = new Ye())),
          e.copy(t),
          n > this.radius * this.radius &&
            (e.sub(this.center).normalize(),
            e.multiplyScalar(this.radius).add(this.center)),
          e
        );
      },
      getBoundingBox: function (t) {
        return (
          void 0 === t &&
            (console.warn(
              "THREE.Sphere: .getBoundingBox() target is now required"
            ),
            (t = new kn())),
          t.set(this.center, this.center),
          t.expandByScalar(this.radius),
          t
        );
      },
      applyMatrix4: function (t) {
        return (
          this.center.applyMatrix4(t),
          (this.radius = this.radius * t.getMaxScaleOnAxis()),
          this
        );
      },
      translate: function (t) {
        return this.center.add(t), this;
      },
      equals: function (t) {
        return t.center.equals(this.center) && t.radius === this.radius;
      },
    });
    var Yn = new Ye(),
      Jn = new Ye(),
      Zn = new Ye(),
      Qn = new Ye(),
      Kn = new Ye(),
      $n = new Ye(),
      tr = new Ye();
    function er(t, e) {
      (this.origin = void 0 !== t ? t : new Ye()),
        (this.direction = void 0 !== e ? e : new Ye());
    }
    Object.assign(er.prototype, {
      set: function (t, e) {
        return this.origin.copy(t), this.direction.copy(e), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (
          this.origin.copy(t.origin), this.direction.copy(t.direction), this
        );
      },
      at: function (t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Ray: .at() target is now required"),
            (e = new Ye())),
          e.copy(this.direction).multiplyScalar(t).add(this.origin)
        );
      },
      lookAt: function (t) {
        return this.direction.copy(t).sub(this.origin).normalize(), this;
      },
      recast: function (t) {
        return this.origin.copy(this.at(t, Yn)), this;
      },
      closestPointToPoint: function (t, e) {
        void 0 === e &&
          (console.warn(
            "THREE.Ray: .closestPointToPoint() target is now required"
          ),
          (e = new Ye())),
          e.subVectors(t, this.origin);
        var n = e.dot(this.direction);
        return n < 0
          ? e.copy(this.origin)
          : e.copy(this.direction).multiplyScalar(n).add(this.origin);
      },
      distanceToPoint: function (t) {
        return Math.sqrt(this.distanceSqToPoint(t));
      },
      distanceSqToPoint: function (t) {
        var e = Yn.subVectors(t, this.origin).dot(this.direction);
        return e < 0
          ? this.origin.distanceToSquared(t)
          : (Yn.copy(this.direction).multiplyScalar(e).add(this.origin),
            Yn.distanceToSquared(t));
      },
      distanceSqToSegment: function (t, e, n, r) {
        Jn.copy(t).add(e).multiplyScalar(0.5),
          Zn.copy(e).sub(t).normalize(),
          Qn.copy(this.origin).sub(Jn);
        var i,
          o,
          a,
          s,
          c = 0.5 * t.distanceTo(e),
          u = -this.direction.dot(Zn),
          l = Qn.dot(this.direction),
          h = -Qn.dot(Zn),
          p = Qn.lengthSq(),
          f = Math.abs(1 - u * u);
        if (f > 0)
          if (((o = u * l - h), (s = c * f), (i = u * h - l) >= 0))
            if (o >= -s)
              if (o <= s) {
                var d = 1 / f;
                a =
                  (i *= d) * (i + u * (o *= d) + 2 * l) +
                  o * (u * i + o + 2 * h) +
                  p;
              } else
                (o = c),
                  (a =
                    -(i = Math.max(0, -(u * o + l))) * i + o * (o + 2 * h) + p);
            else
              (o = -c),
                (a =
                  -(i = Math.max(0, -(u * o + l))) * i + o * (o + 2 * h) + p);
          else
            o <= -s
              ? (a =
                  -(i = Math.max(0, -(-u * c + l))) * i +
                  (o = i > 0 ? -c : Math.min(Math.max(-c, -h), c)) *
                    (o + 2 * h) +
                  p)
              : o <= s
              ? ((i = 0),
                (a = (o = Math.min(Math.max(-c, -h), c)) * (o + 2 * h) + p))
              : (a =
                  -(i = Math.max(0, -(u * c + l))) * i +
                  (o = i > 0 ? c : Math.min(Math.max(-c, -h), c)) *
                    (o + 2 * h) +
                  p);
        else
          (o = u > 0 ? -c : c),
            (a = -(i = Math.max(0, -(u * o + l))) * i + o * (o + 2 * h) + p);
        return (
          n && n.copy(this.direction).multiplyScalar(i).add(this.origin),
          r && r.copy(Zn).multiplyScalar(o).add(Jn),
          a
        );
      },
      intersectSphere: function (t, e) {
        Yn.subVectors(t.center, this.origin);
        var n = Yn.dot(this.direction),
          r = Yn.dot(Yn) - n * n,
          i = t.radius * t.radius;
        if (r > i) return null;
        var o = Math.sqrt(i - r),
          a = n - o,
          s = n + o;
        return a < 0 && s < 0 ? null : a < 0 ? this.at(s, e) : this.at(a, e);
      },
      intersectsSphere: function (t) {
        return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
      },
      distanceToPlane: function (t) {
        var e = t.normal.dot(this.direction);
        if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
        var n = -(this.origin.dot(t.normal) + t.constant) / e;
        return n >= 0 ? n : null;
      },
      intersectPlane: function (t, e) {
        var n = this.distanceToPlane(t);
        return null === n ? null : this.at(n, e);
      },
      intersectsPlane: function (t) {
        var e = t.distanceToPoint(this.origin);
        return 0 === e || t.normal.dot(this.direction) * e < 0;
      },
      intersectBox: function (t, e) {
        var n,
          r,
          i,
          o,
          a,
          s,
          c = 1 / this.direction.x,
          u = 1 / this.direction.y,
          l = 1 / this.direction.z,
          h = this.origin;
        return (
          c >= 0
            ? ((n = (t.min.x - h.x) * c), (r = (t.max.x - h.x) * c))
            : ((n = (t.max.x - h.x) * c), (r = (t.min.x - h.x) * c)),
          u >= 0
            ? ((i = (t.min.y - h.y) * u), (o = (t.max.y - h.y) * u))
            : ((i = (t.max.y - h.y) * u), (o = (t.min.y - h.y) * u)),
          n > o || i > r
            ? null
            : ((i > n || n != n) && (n = i),
              (o < r || r != r) && (r = o),
              l >= 0
                ? ((a = (t.min.z - h.z) * l), (s = (t.max.z - h.z) * l))
                : ((a = (t.max.z - h.z) * l), (s = (t.min.z - h.z) * l)),
              n > s || a > r
                ? null
                : ((a > n || n != n) && (n = a),
                  (s < r || r != r) && (r = s),
                  r < 0 ? null : this.at(n >= 0 ? n : r, e)))
        );
      },
      intersectsBox: function (t) {
        return null !== this.intersectBox(t, Yn);
      },
      intersectTriangle: function (t, e, n, r, i) {
        Kn.subVectors(e, t), $n.subVectors(n, t), tr.crossVectors(Kn, $n);
        var o,
          a = this.direction.dot(tr);
        if (a > 0) {
          if (r) return null;
          o = 1;
        } else {
          if (!(a < 0)) return null;
          (o = -1), (a = -a);
        }
        Qn.subVectors(this.origin, t);
        var s = o * this.direction.dot($n.crossVectors(Qn, $n));
        if (s < 0) return null;
        var c = o * this.direction.dot(Kn.cross(Qn));
        if (c < 0) return null;
        if (s + c > a) return null;
        var u = -o * Qn.dot(tr);
        return u < 0 ? null : this.at(u / a, i);
      },
      applyMatrix4: function (t) {
        return (
          this.origin.applyMatrix4(t),
          this.direction.transformDirection(t),
          this
        );
      },
      equals: function (t) {
        return (
          t.origin.equals(this.origin) && t.direction.equals(this.direction)
        );
      },
    });
    var nr = new Ye(),
      rr = new Ye(),
      ir = new Ye(),
      or = new Ye(),
      ar = new Ye(),
      sr = new Ye(),
      cr = new Ye(),
      ur = new Ye(),
      lr = new Ye(),
      hr = new Ye();
    function pr(t, e, n) {
      (this.a = void 0 !== t ? t : new Ye()),
        (this.b = void 0 !== e ? e : new Ye()),
        (this.c = void 0 !== n ? n : new Ye());
    }
    Object.assign(pr, {
      getNormal: function (t, e, n, r) {
        void 0 === r &&
          (console.warn("THREE.Triangle: .getNormal() target is now required"),
          (r = new Ye())),
          r.subVectors(n, e),
          nr.subVectors(t, e),
          r.cross(nr);
        var i = r.lengthSq();
        return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0);
      },
      getBarycoord: function (t, e, n, r, i) {
        nr.subVectors(r, e), rr.subVectors(n, e), ir.subVectors(t, e);
        var o = nr.dot(nr),
          a = nr.dot(rr),
          s = nr.dot(ir),
          c = rr.dot(rr),
          u = rr.dot(ir),
          l = o * c - a * a;
        if (
          (void 0 === i &&
            (console.warn(
              "THREE.Triangle: .getBarycoord() target is now required"
            ),
            (i = new Ye())),
          0 === l)
        )
          return i.set(-2, -1, -1);
        var h = 1 / l,
          p = (c * s - a * u) * h,
          f = (o * u - a * s) * h;
        return i.set(1 - p - f, f, p);
      },
      containsPoint: function (t, e, n, r) {
        return (
          pr.getBarycoord(t, e, n, r, or),
          or.x >= 0 && or.y >= 0 && or.x + or.y <= 1
        );
      },
      getUV: function (t, e, n, r, i, o, a, s) {
        return (
          this.getBarycoord(t, e, n, r, or),
          s.set(0, 0),
          s.addScaledVector(i, or.x),
          s.addScaledVector(o, or.y),
          s.addScaledVector(a, or.z),
          s
        );
      },
      isFrontFacing: function (t, e, n, r) {
        return (
          nr.subVectors(n, e), rr.subVectors(t, e), nr.cross(rr).dot(r) < 0
        );
      },
    }),
      Object.assign(pr.prototype, {
        set: function (t, e, n) {
          return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
        },
        setFromPointsAndIndices: function (t, e, n, r) {
          return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
        },
        getArea: function () {
          return (
            nr.subVectors(this.c, this.b),
            rr.subVectors(this.a, this.b),
            0.5 * nr.cross(rr).length()
          );
        },
        getMidpoint: function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Triangle: .getMidpoint() target is now required"
              ),
              (t = new Ye())),
            t
              .addVectors(this.a, this.b)
              .add(this.c)
              .multiplyScalar(1 / 3)
          );
        },
        getNormal: function (t) {
          return pr.getNormal(this.a, this.b, this.c, t);
        },
        getPlane: function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "THREE.Triangle: .getPlane() target is now required"
              ),
              (t = new Ye())),
            t.setFromCoplanarPoints(this.a, this.b, this.c)
          );
        },
        getBarycoord: function (t, e) {
          return pr.getBarycoord(t, this.a, this.b, this.c, e);
        },
        getUV: function (t, e, n, r, i) {
          return pr.getUV(t, this.a, this.b, this.c, e, n, r, i);
        },
        containsPoint: function (t) {
          return pr.containsPoint(t, this.a, this.b, this.c);
        },
        isFrontFacing: function (t) {
          return pr.isFrontFacing(this.a, this.b, this.c, t);
        },
        intersectsBox: function (t) {
          return t.intersectsTriangle(this);
        },
        closestPointToPoint: function (t, e) {
          void 0 === e &&
            (console.warn(
              "THREE.Triangle: .closestPointToPoint() target is now required"
            ),
            (e = new Ye()));
          var n,
            r,
            i = this.a,
            o = this.b,
            a = this.c;
          ar.subVectors(o, i), sr.subVectors(a, i), ur.subVectors(t, i);
          var s = ar.dot(ur),
            c = sr.dot(ur);
          if (s <= 0 && c <= 0) return e.copy(i);
          lr.subVectors(t, o);
          var u = ar.dot(lr),
            l = sr.dot(lr);
          if (u >= 0 && l <= u) return e.copy(o);
          var h = s * l - u * c;
          if (h <= 0 && s >= 0 && u <= 0)
            return (n = s / (s - u)), e.copy(i).addScaledVector(ar, n);
          hr.subVectors(t, a);
          var p = ar.dot(hr),
            f = sr.dot(hr);
          if (f >= 0 && p <= f) return e.copy(a);
          var d = p * c - s * f;
          if (d <= 0 && c >= 0 && f <= 0)
            return (r = c / (c - f)), e.copy(i).addScaledVector(sr, r);
          var m = u * f - p * l;
          if (m <= 0 && l - u >= 0 && p - f >= 0)
            return (
              cr.subVectors(a, o),
              (r = (l - u) / (l - u + (p - f))),
              e.copy(o).addScaledVector(cr, r)
            );
          var v = 1 / (m + d + h);
          return (
            (n = d * v),
            (r = h * v),
            e.copy(i).addScaledVector(ar, n).addScaledVector(sr, r)
          );
        },
        equals: function (t) {
          return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
        },
      });
    var fr = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074,
      },
      dr = { h: 0, s: 0, l: 0 },
      mr = { h: 0, s: 0, l: 0 };
    function vr(t, e, n) {
      return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n);
    }
    function gr(t, e, n) {
      return (
        n < 0 && (n += 1),
        n > 1 && (n -= 1),
        n < 1 / 6
          ? t + 6 * (e - t) * n
          : n < 0.5
          ? e
          : n < 2 / 3
          ? t + 6 * (e - t) * (2 / 3 - n)
          : t
      );
    }
    function yr(t) {
      return t < 0.04045
        ? 0.0773993808 * t
        : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
    }
    function xr(t) {
      return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
    }
    function br(t, e, n, r, i, o) {
      (this.a = t),
        (this.b = e),
        (this.c = n),
        (this.normal = r && r.isVector3 ? r : new Ye()),
        (this.vertexNormals = Array.isArray(r) ? r : []),
        (this.color = i && i.isColor ? i : new vr()),
        (this.vertexColors = Array.isArray(i) ? i : []),
        (this.materialIndex = void 0 !== o ? o : 0);
    }
    Object.assign(vr.prototype, {
      isColor: !0,
      r: 1,
      g: 1,
      b: 1,
      set: function (t) {
        return (
          t && t.isColor
            ? this.copy(t)
            : "number" == typeof t
            ? this.setHex(t)
            : "string" == typeof t && this.setStyle(t),
          this
        );
      },
      setScalar: function (t) {
        return (this.r = t), (this.g = t), (this.b = t), this;
      },
      setHex: function (t) {
        return (
          (t = Math.floor(t)),
          (this.r = ((t >> 16) & 255) / 255),
          (this.g = ((t >> 8) & 255) / 255),
          (this.b = (255 & t) / 255),
          this
        );
      },
      setRGB: function (t, e, n) {
        return (this.r = t), (this.g = e), (this.b = n), this;
      },
      setHSL: function (t, e, n) {
        if (
          ((t = He.euclideanModulo(t, 1)),
          (e = He.clamp(e, 0, 1)),
          (n = He.clamp(n, 0, 1)),
          0 === e)
        )
          this.r = this.g = this.b = n;
        else {
          var r = n <= 0.5 ? n * (1 + e) : n + e - n * e,
            i = 2 * n - r;
          (this.r = gr(i, r, t + 1 / 3)),
            (this.g = gr(i, r, t)),
            (this.b = gr(i, r, t - 1 / 3));
        }
        return this;
      },
      setStyle: function (t) {
        function e(e) {
          void 0 !== e &&
            parseFloat(e) < 1 &&
            console.warn(
              "THREE.Color: Alpha component of " + t + " will be ignored."
            );
        }
        var n;
        if ((n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t))) {
          var r,
            i = n[1],
            o = n[2];
          switch (i) {
            case "rgb":
            case "rgba":
              if (
                (r =
                  /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                    o
                  ))
              )
                return (
                  (this.r = Math.min(255, parseInt(r[1], 10)) / 255),
                  (this.g = Math.min(255, parseInt(r[2], 10)) / 255),
                  (this.b = Math.min(255, parseInt(r[3], 10)) / 255),
                  e(r[5]),
                  this
                );
              if (
                (r =
                  /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                    o
                  ))
              )
                return (
                  (this.r = Math.min(100, parseInt(r[1], 10)) / 100),
                  (this.g = Math.min(100, parseInt(r[2], 10)) / 100),
                  (this.b = Math.min(100, parseInt(r[3], 10)) / 100),
                  e(r[5]),
                  this
                );
              break;
            case "hsl":
            case "hsla":
              if (
                (r =
                  /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                    o
                  ))
              ) {
                var a = parseFloat(r[1]) / 360,
                  s = parseInt(r[2], 10) / 100,
                  c = parseInt(r[3], 10) / 100;
                return e(r[5]), this.setHSL(a, s, c);
              }
          }
        } else if ((n = /^\#([A-Fa-f0-9]+)$/.exec(t))) {
          var u,
            l = (u = n[1]).length;
          if (3 === l)
            return (
              (this.r = parseInt(u.charAt(0) + u.charAt(0), 16) / 255),
              (this.g = parseInt(u.charAt(1) + u.charAt(1), 16) / 255),
              (this.b = parseInt(u.charAt(2) + u.charAt(2), 16) / 255),
              this
            );
          if (6 === l)
            return (
              (this.r = parseInt(u.charAt(0) + u.charAt(1), 16) / 255),
              (this.g = parseInt(u.charAt(2) + u.charAt(3), 16) / 255),
              (this.b = parseInt(u.charAt(4) + u.charAt(5), 16) / 255),
              this
            );
        }
        t &&
          t.length > 0 &&
          (void 0 !== (u = fr[t])
            ? this.setHex(u)
            : console.warn("THREE.Color: Unknown color " + t));
        return this;
      },
      clone: function () {
        return new this.constructor(this.r, this.g, this.b);
      },
      copy: function (t) {
        return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
      },
      copyGammaToLinear: function (t, e) {
        return (
          void 0 === e && (e = 2),
          (this.r = Math.pow(t.r, e)),
          (this.g = Math.pow(t.g, e)),
          (this.b = Math.pow(t.b, e)),
          this
        );
      },
      copyLinearToGamma: function (t, e) {
        void 0 === e && (e = 2);
        var n = e > 0 ? 1 / e : 1;
        return (
          (this.r = Math.pow(t.r, n)),
          (this.g = Math.pow(t.g, n)),
          (this.b = Math.pow(t.b, n)),
          this
        );
      },
      convertGammaToLinear: function (t) {
        return this.copyGammaToLinear(this, t), this;
      },
      convertLinearToGamma: function (t) {
        return this.copyLinearToGamma(this, t), this;
      },
      copySRGBToLinear: function (t) {
        return (this.r = yr(t.r)), (this.g = yr(t.g)), (this.b = yr(t.b)), this;
      },
      copyLinearToSRGB: function (t) {
        return (this.r = xr(t.r)), (this.g = xr(t.g)), (this.b = xr(t.b)), this;
      },
      convertSRGBToLinear: function () {
        return this.copySRGBToLinear(this), this;
      },
      convertLinearToSRGB: function () {
        return this.copyLinearToSRGB(this), this;
      },
      getHex: function () {
        return (
          ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
        );
      },
      getHexString: function () {
        return ("000000" + this.getHex().toString(16)).slice(-6);
      },
      getHSL: function (t) {
        void 0 === t &&
          (console.warn("THREE.Color: .getHSL() target is now required"),
          (t = { h: 0, s: 0, l: 0 }));
        var e,
          n,
          r = this.r,
          i = this.g,
          o = this.b,
          a = Math.max(r, i, o),
          s = Math.min(r, i, o),
          c = (s + a) / 2;
        if (s === a) (e = 0), (n = 0);
        else {
          var u = a - s;
          switch (((n = c <= 0.5 ? u / (a + s) : u / (2 - a - s)), a)) {
            case r:
              e = (i - o) / u + (i < o ? 6 : 0);
              break;
            case i:
              e = (o - r) / u + 2;
              break;
            case o:
              e = (r - i) / u + 4;
          }
          e /= 6;
        }
        return (t.h = e), (t.s = n), (t.l = c), t;
      },
      getStyle: function () {
        return (
          "rgb(" +
          ((255 * this.r) | 0) +
          "," +
          ((255 * this.g) | 0) +
          "," +
          ((255 * this.b) | 0) +
          ")"
        );
      },
      offsetHSL: function (t, e, n) {
        return (
          this.getHSL(dr),
          (dr.h += t),
          (dr.s += e),
          (dr.l += n),
          this.setHSL(dr.h, dr.s, dr.l),
          this
        );
      },
      add: function (t) {
        return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
      },
      addColors: function (t, e) {
        return (
          (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
        );
      },
      addScalar: function (t) {
        return (this.r += t), (this.g += t), (this.b += t), this;
      },
      sub: function (t) {
        return (
          (this.r = Math.max(0, this.r - t.r)),
          (this.g = Math.max(0, this.g - t.g)),
          (this.b = Math.max(0, this.b - t.b)),
          this
        );
      },
      multiply: function (t) {
        return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
      },
      multiplyScalar: function (t) {
        return (this.r *= t), (this.g *= t), (this.b *= t), this;
      },
      lerp: function (t, e) {
        return (
          (this.r += (t.r - this.r) * e),
          (this.g += (t.g - this.g) * e),
          (this.b += (t.b - this.b) * e),
          this
        );
      },
      lerpHSL: function (t, e) {
        this.getHSL(dr), t.getHSL(mr);
        var n = He.lerp(dr.h, mr.h, e),
          r = He.lerp(dr.s, mr.s, e),
          i = He.lerp(dr.l, mr.l, e);
        return this.setHSL(n, r, i), this;
      },
      equals: function (t) {
        return t.r === this.r && t.g === this.g && t.b === this.b;
      },
      fromArray: function (t, e) {
        return (
          void 0 === e && (e = 0),
          (this.r = t[e]),
          (this.g = t[e + 1]),
          (this.b = t[e + 2]),
          this
        );
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this.r),
          (t[e + 1] = this.g),
          (t[e + 2] = this.b),
          t
        );
      },
      toJSON: function () {
        return this.getHex();
      },
    }),
      Object.assign(br.prototype, {
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          (this.a = t.a),
            (this.b = t.b),
            (this.c = t.c),
            this.normal.copy(t.normal),
            this.color.copy(t.color),
            (this.materialIndex = t.materialIndex);
          for (var e = 0, n = t.vertexNormals.length; e < n; e++)
            this.vertexNormals[e] = t.vertexNormals[e].clone();
          for (e = 0, n = t.vertexColors.length; e < n; e++)
            this.vertexColors[e] = t.vertexColors[e].clone();
          return this;
        },
      });
    var wr = 0;
    function _r() {
      Object.defineProperty(this, "id", { value: wr++ }),
        (this.uuid = He.generateUUID()),
        (this.name = ""),
        (this.type = "Material"),
        (this.fog = !0),
        (this.blending = O),
        (this.side = E),
        (this.flatShading = !1),
        (this.vertexTangents = !1),
        (this.vertexColors = L),
        (this.opacity = 1),
        (this.transparent = !1),
        (this.blendSrc = q),
        (this.blendDst = X),
        (this.blendEquation = F),
        (this.blendSrcAlpha = null),
        (this.blendDstAlpha = null),
        (this.blendEquationAlpha = null),
        (this.depthFunc = nt),
        (this.depthTest = !0),
        (this.depthWrite = !0),
        (this.stencilWriteMask = 255),
        (this.stencilFunc = Be),
        (this.stencilRef = 0),
        (this.stencilFuncMask = 255),
        (this.stencilFail = Ue),
        (this.stencilZFail = Ue),
        (this.stencilZPass = Ue),
        (this.stencilWrite = !1),
        (this.clippingPlanes = null),
        (this.clipIntersection = !1),
        (this.clipShadows = !1),
        (this.shadowSide = null),
        (this.colorWrite = !0),
        (this.precision = null),
        (this.polygonOffset = !1),
        (this.polygonOffsetFactor = 0),
        (this.polygonOffsetUnits = 0),
        (this.dithering = !1),
        (this.alphaTest = 0),
        (this.premultipliedAlpha = !1),
        (this.visible = !0),
        (this.toneMapped = !0),
        (this.userData = {}),
        (this.needsUpdate = !0);
    }
    function Mr(t) {
      _r.call(this),
        (this.type = "MeshBasicMaterial"),
        (this.color = new vr(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = st),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.skinning = !1),
        (this.morphTargets = !1),
        this.setValues(t);
    }
    function Sr(t, e, n) {
      if (Array.isArray(t))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array."
        );
      (this.name = ""),
        (this.array = t),
        (this.itemSize = e),
        (this.count = void 0 !== t ? t.length / e : 0),
        (this.normalized = !0 === n),
        (this.dynamic = !1),
        (this.updateRange = { offset: 0, count: -1 }),
        (this.version = 0);
    }
    function Er(t, e, n) {
      Sr.call(this, new Int8Array(t), e, n);
    }
    function Tr(t, e, n) {
      Sr.call(this, new Uint8Array(t), e, n);
    }
    function Ar(t, e, n) {
      Sr.call(this, new Uint8ClampedArray(t), e, n);
    }
    function Lr(t, e, n) {
      Sr.call(this, new Int16Array(t), e, n);
    }
    function Pr(t, e, n) {
      Sr.call(this, new Uint16Array(t), e, n);
    }
    function Rr(t, e, n) {
      Sr.call(this, new Int32Array(t), e, n);
    }
    function Cr(t, e, n) {
      Sr.call(this, new Uint32Array(t), e, n);
    }
    function Or(t, e, n) {
      Sr.call(this, new Float32Array(t), e, n);
    }
    function Ir(t, e, n) {
      Sr.call(this, new Float64Array(t), e, n);
    }
    function Nr() {
      (this.vertices = []),
        (this.normals = []),
        (this.colors = []),
        (this.uvs = []),
        (this.uvs2 = []),
        (this.groups = []),
        (this.morphTargets = {}),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.verticesNeedUpdate = !1),
        (this.normalsNeedUpdate = !1),
        (this.colorsNeedUpdate = !1),
        (this.uvsNeedUpdate = !1),
        (this.groupsNeedUpdate = !1);
    }
    function Dr(t) {
      if (0 === t.length) return -1 / 0;
      for (var e = t[0], n = 1, r = t.length; n < r; ++n)
        t[n] > e && (e = t[n]);
      return e;
    }
    (_r.prototype = Object.assign(Object.create(Ge.prototype), {
      constructor: _r,
      isMaterial: !0,
      onBeforeCompile: function () {},
      setValues: function (t) {
        if (void 0 !== t)
          for (var e in t) {
            var n = t[e];
            if (void 0 !== n)
              if ("shading" !== e) {
                var r = this[e];
                void 0 !== r
                  ? r && r.isColor
                    ? r.set(n)
                    : r && r.isVector3 && n && n.isVector3
                    ? r.copy(n)
                    : (this[e] = n)
                  : console.warn(
                      "THREE." +
                        this.type +
                        ": '" +
                        e +
                        "' is not a property of this material."
                    );
              } else
                console.warn(
                  "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
                ),
                  (this.flatShading = 1 === n);
            else
              console.warn(
                "THREE.Material: '" + e + "' parameter is undefined."
              );
          }
      },
      toJSON: function (t) {
        var e = void 0 === t || "string" == typeof t;
        e && (t = { textures: {}, images: {} });
        var n = {
          metadata: {
            version: 4.5,
            type: "Material",
            generator: "Material.toJSON",
          },
        };
        function r(t) {
          var e = [];
          for (var n in t) {
            var r = t[n];
            delete r.metadata, e.push(r);
          }
          return e;
        }
        if (
          ((n.uuid = this.uuid),
          (n.type = this.type),
          "" !== this.name && (n.name = this.name),
          this.color && this.color.isColor && (n.color = this.color.getHex()),
          void 0 !== this.roughness && (n.roughness = this.roughness),
          void 0 !== this.metalness && (n.metalness = this.metalness),
          this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
          this.emissive &&
            this.emissive.isColor &&
            (n.emissive = this.emissive.getHex()),
          this.emissiveIntensity &&
            1 !== this.emissiveIntensity &&
            (n.emissiveIntensity = this.emissiveIntensity),
          this.specular &&
            this.specular.isColor &&
            (n.specular = this.specular.getHex()),
          void 0 !== this.shininess && (n.shininess = this.shininess),
          void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
          void 0 !== this.clearcoatRoughness &&
            (n.clearcoatRoughness = this.clearcoatRoughness),
          this.clearcoatNormalMap &&
            this.clearcoatNormalMap.isTexture &&
            ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
            (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
          this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
          this.matcap &&
            this.matcap.isTexture &&
            (n.matcap = this.matcap.toJSON(t).uuid),
          this.alphaMap &&
            this.alphaMap.isTexture &&
            (n.alphaMap = this.alphaMap.toJSON(t).uuid),
          this.lightMap &&
            this.lightMap.isTexture &&
            (n.lightMap = this.lightMap.toJSON(t).uuid),
          this.aoMap &&
            this.aoMap.isTexture &&
            ((n.aoMap = this.aoMap.toJSON(t).uuid),
            (n.aoMapIntensity = this.aoMapIntensity)),
          this.bumpMap &&
            this.bumpMap.isTexture &&
            ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
            (n.bumpScale = this.bumpScale)),
          this.normalMap &&
            this.normalMap.isTexture &&
            ((n.normalMap = this.normalMap.toJSON(t).uuid),
            (n.normalMapType = this.normalMapType),
            (n.normalScale = this.normalScale.toArray())),
          this.displacementMap &&
            this.displacementMap.isTexture &&
            ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
            (n.displacementScale = this.displacementScale),
            (n.displacementBias = this.displacementBias)),
          this.roughnessMap &&
            this.roughnessMap.isTexture &&
            (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
          this.metalnessMap &&
            this.metalnessMap.isTexture &&
            (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
          this.emissiveMap &&
            this.emissiveMap.isTexture &&
            (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
          this.specularMap &&
            this.specularMap.isTexture &&
            (n.specularMap = this.specularMap.toJSON(t).uuid),
          this.envMap &&
            this.envMap.isTexture &&
            ((n.envMap = this.envMap.toJSON(t).uuid),
            (n.reflectivity = this.reflectivity),
            (n.refractionRatio = this.refractionRatio),
            void 0 !== this.combine && (n.combine = this.combine),
            void 0 !== this.envMapIntensity &&
              (n.envMapIntensity = this.envMapIntensity)),
          this.gradientMap &&
            this.gradientMap.isTexture &&
            (n.gradientMap = this.gradientMap.toJSON(t).uuid),
          void 0 !== this.size && (n.size = this.size),
          void 0 !== this.sizeAttenuation &&
            (n.sizeAttenuation = this.sizeAttenuation),
          this.blending !== O && (n.blending = this.blending),
          !0 === this.flatShading && (n.flatShading = this.flatShading),
          this.side !== E && (n.side = this.side),
          this.vertexColors !== L && (n.vertexColors = this.vertexColors),
          this.opacity < 1 && (n.opacity = this.opacity),
          !0 === this.transparent && (n.transparent = this.transparent),
          (n.depthFunc = this.depthFunc),
          (n.depthTest = this.depthTest),
          (n.depthWrite = this.depthWrite),
          (n.stencilWrite = this.stencilWrite),
          (n.stencilWriteMask = this.stencilWriteMask),
          (n.stencilFunc = this.stencilFunc),
          (n.stencilRef = this.stencilRef),
          (n.stencilFuncMask = this.stencilFuncMask),
          (n.stencilFail = this.stencilFail),
          (n.stencilZFail = this.stencilZFail),
          (n.stencilZPass = this.stencilZPass),
          this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
          !0 === this.polygonOffset && (n.polygonOffset = !0),
          0 !== this.polygonOffsetFactor &&
            (n.polygonOffsetFactor = this.polygonOffsetFactor),
          0 !== this.polygonOffsetUnits &&
            (n.polygonOffsetUnits = this.polygonOffsetUnits),
          this.linewidth &&
            1 !== this.linewidth &&
            (n.linewidth = this.linewidth),
          void 0 !== this.dashSize && (n.dashSize = this.dashSize),
          void 0 !== this.gapSize && (n.gapSize = this.gapSize),
          void 0 !== this.scale && (n.scale = this.scale),
          !0 === this.dithering && (n.dithering = !0),
          this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
          !0 === this.premultipliedAlpha &&
            (n.premultipliedAlpha = this.premultipliedAlpha),
          !0 === this.wireframe && (n.wireframe = this.wireframe),
          this.wireframeLinewidth > 1 &&
            (n.wireframeLinewidth = this.wireframeLinewidth),
          "round" !== this.wireframeLinecap &&
            (n.wireframeLinecap = this.wireframeLinecap),
          "round" !== this.wireframeLinejoin &&
            (n.wireframeLinejoin = this.wireframeLinejoin),
          !0 === this.morphTargets && (n.morphTargets = !0),
          !0 === this.morphNormals && (n.morphNormals = !0),
          !0 === this.skinning && (n.skinning = !0),
          !1 === this.visible && (n.visible = !1),
          !1 === this.toneMapped && (n.toneMapped = !1),
          "{}" !== JSON.stringify(this.userData) &&
            (n.userData = this.userData),
          e)
        ) {
          var i = r(t.textures),
            o = r(t.images);
          i.length > 0 && (n.textures = i), o.length > 0 && (n.images = o);
        }
        return n;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        (this.name = t.name),
          (this.fog = t.fog),
          (this.blending = t.blending),
          (this.side = t.side),
          (this.flatShading = t.flatShading),
          (this.vertexColors = t.vertexColors),
          (this.opacity = t.opacity),
          (this.transparent = t.transparent),
          (this.blendSrc = t.blendSrc),
          (this.blendDst = t.blendDst),
          (this.blendEquation = t.blendEquation),
          (this.blendSrcAlpha = t.blendSrcAlpha),
          (this.blendDstAlpha = t.blendDstAlpha),
          (this.blendEquationAlpha = t.blendEquationAlpha),
          (this.depthFunc = t.depthFunc),
          (this.depthTest = t.depthTest),
          (this.depthWrite = t.depthWrite),
          (this.stencilWrite = t.stencilWrite),
          (this.stencilWriteMask = t.stencilWriteMask),
          (this.stencilFunc = t.stencilFunc),
          (this.stencilRef = t.stencilRef),
          (this.stencilFuncMask = t.stencilFuncMask),
          (this.stencilFail = t.stencilFail),
          (this.stencilZFail = t.stencilZFail),
          (this.stencilZPass = t.stencilZPass),
          (this.colorWrite = t.colorWrite),
          (this.precision = t.precision),
          (this.polygonOffset = t.polygonOffset),
          (this.polygonOffsetFactor = t.polygonOffsetFactor),
          (this.polygonOffsetUnits = t.polygonOffsetUnits),
          (this.dithering = t.dithering),
          (this.alphaTest = t.alphaTest),
          (this.premultipliedAlpha = t.premultipliedAlpha),
          (this.visible = t.visible),
          (this.toneMapped = t.toneMapped),
          (this.userData = JSON.parse(JSON.stringify(t.userData))),
          (this.clipShadows = t.clipShadows),
          (this.clipIntersection = t.clipIntersection);
        var e = t.clippingPlanes,
          n = null;
        if (null !== e) {
          var r = e.length;
          n = new Array(r);
          for (var i = 0; i !== r; ++i) n[i] = e[i].clone();
        }
        return (
          (this.clippingPlanes = n), (this.shadowSide = t.shadowSide), this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: "dispose" });
      },
    })),
      (Mr.prototype = Object.create(_r.prototype)),
      (Mr.prototype.constructor = Mr),
      (Mr.prototype.isMeshBasicMaterial = !0),
      (Mr.prototype.copy = function (t) {
        return (
          _r.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          (this.specularMap = t.specularMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.combine = t.combine),
          (this.reflectivity = t.reflectivity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          this
        );
      }),
      Object.defineProperty(Sr.prototype, "needsUpdate", {
        set: function (t) {
          !0 === t && this.version++;
        },
      }),
      Object.assign(Sr.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function () {},
        setDynamic: function (t) {
          return (this.dynamic = t), this;
        },
        copy: function (t) {
          return (
            (this.name = t.name),
            (this.array = new t.array.constructor(t.array)),
            (this.itemSize = t.itemSize),
            (this.count = t.count),
            (this.normalized = t.normalized),
            (this.dynamic = t.dynamic),
            this
          );
        },
        copyAt: function (t, e, n) {
          (t *= this.itemSize), (n *= e.itemSize);
          for (var r = 0, i = this.itemSize; r < i; r++)
            this.array[t + r] = e.array[n + r];
          return this;
        },
        copyArray: function (t) {
          return this.array.set(t), this;
        },
        copyColorsArray: function (t) {
          for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
            var o = t[r];
            void 0 === o &&
              (console.warn(
                "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                r
              ),
              (o = new vr())),
              (e[n++] = o.r),
              (e[n++] = o.g),
              (e[n++] = o.b);
          }
          return this;
        },
        copyVector2sArray: function (t) {
          for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
            var o = t[r];
            void 0 === o &&
              (console.warn(
                "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                r
              ),
              (o = new ke())),
              (e[n++] = o.x),
              (e[n++] = o.y);
          }
          return this;
        },
        copyVector3sArray: function (t) {
          for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
            var o = t[r];
            void 0 === o &&
              (console.warn(
                "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                r
              ),
              (o = new Ye())),
              (e[n++] = o.x),
              (e[n++] = o.y),
              (e[n++] = o.z);
          }
          return this;
        },
        copyVector4sArray: function (t) {
          for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
            var o = t[r];
            void 0 === o &&
              (console.warn(
                "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                r
              ),
              (o = new en())),
              (e[n++] = o.x),
              (e[n++] = o.y),
              (e[n++] = o.z),
              (e[n++] = o.w);
          }
          return this;
        },
        set: function (t, e) {
          return void 0 === e && (e = 0), this.array.set(t, e), this;
        },
        getX: function (t) {
          return this.array[t * this.itemSize];
        },
        setX: function (t, e) {
          return (this.array[t * this.itemSize] = e), this;
        },
        getY: function (t) {
          return this.array[t * this.itemSize + 1];
        },
        setY: function (t, e) {
          return (this.array[t * this.itemSize + 1] = e), this;
        },
        getZ: function (t) {
          return this.array[t * this.itemSize + 2];
        },
        setZ: function (t, e) {
          return (this.array[t * this.itemSize + 2] = e), this;
        },
        getW: function (t) {
          return this.array[t * this.itemSize + 3];
        },
        setW: function (t, e) {
          return (this.array[t * this.itemSize + 3] = e), this;
        },
        setXY: function (t, e, n) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            this
          );
        },
        setXYZ: function (t, e, n, r) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            (this.array[t + 2] = r),
            this
          );
        },
        setXYZW: function (t, e, n, r, i) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            (this.array[t + 2] = r),
            (this.array[t + 3] = i),
            this
          );
        },
        onUpload: function (t) {
          return (this.onUploadCallback = t), this;
        },
        clone: function () {
          return new this.constructor(this.array, this.itemSize).copy(this);
        },
        toJSON: function () {
          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized,
          };
        },
      }),
      (Er.prototype = Object.create(Sr.prototype)),
      (Er.prototype.constructor = Er),
      (Tr.prototype = Object.create(Sr.prototype)),
      (Tr.prototype.constructor = Tr),
      (Ar.prototype = Object.create(Sr.prototype)),
      (Ar.prototype.constructor = Ar),
      (Lr.prototype = Object.create(Sr.prototype)),
      (Lr.prototype.constructor = Lr),
      (Pr.prototype = Object.create(Sr.prototype)),
      (Pr.prototype.constructor = Pr),
      (Rr.prototype = Object.create(Sr.prototype)),
      (Rr.prototype.constructor = Rr),
      (Cr.prototype = Object.create(Sr.prototype)),
      (Cr.prototype.constructor = Cr),
      (Or.prototype = Object.create(Sr.prototype)),
      (Or.prototype.constructor = Or),
      (Ir.prototype = Object.create(Sr.prototype)),
      (Ir.prototype.constructor = Ir),
      Object.assign(Nr.prototype, {
        computeGroups: function (t) {
          for (
            var e, n = [], r = void 0, i = t.faces, o = 0;
            o < i.length;
            o++
          ) {
            var a = i[o];
            a.materialIndex !== r &&
              ((r = a.materialIndex),
              void 0 !== e && ((e.count = 3 * o - e.start), n.push(e)),
              (e = { start: 3 * o, materialIndex: r }));
          }
          void 0 !== e && ((e.count = 3 * o - e.start), n.push(e)),
            (this.groups = n);
        },
        fromGeometry: function (t) {
          var e,
            n = t.faces,
            r = t.vertices,
            i = t.faceVertexUvs,
            o = i[0] && i[0].length > 0,
            a = i[1] && i[1].length > 0,
            s = t.morphTargets,
            c = s.length;
          if (c > 0) {
            e = [];
            for (var u = 0; u < c; u++) e[u] = { name: s[u].name, data: [] };
            this.morphTargets.position = e;
          }
          var l,
            h = t.morphNormals,
            p = h.length;
          if (p > 0) {
            l = [];
            for (u = 0; u < p; u++) l[u] = { name: h[u].name, data: [] };
            this.morphTargets.normal = l;
          }
          var f = t.skinIndices,
            d = t.skinWeights,
            m = f.length === r.length,
            v = d.length === r.length;
          r.length > 0 &&
            0 === n.length &&
            console.error(
              "THREE.DirectGeometry: Faceless geometries are not supported."
            );
          for (u = 0; u < n.length; u++) {
            var g = n[u];
            this.vertices.push(r[g.a], r[g.b], r[g.c]);
            var y = g.vertexNormals;
            if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
            else {
              var x = g.normal;
              this.normals.push(x, x, x);
            }
            var b,
              w = g.vertexColors;
            if (3 === w.length) this.colors.push(w[0], w[1], w[2]);
            else {
              var _ = g.color;
              this.colors.push(_, _, _);
            }
            if (!0 === o)
              void 0 !== (b = i[0][u])
                ? this.uvs.push(b[0], b[1], b[2])
                : (console.warn(
                    "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
                    u
                  ),
                  this.uvs.push(new ke(), new ke(), new ke()));
            if (!0 === a)
              void 0 !== (b = i[1][u])
                ? this.uvs2.push(b[0], b[1], b[2])
                : (console.warn(
                    "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
                    u
                  ),
                  this.uvs2.push(new ke(), new ke(), new ke()));
            for (var M = 0; M < c; M++) {
              var S = s[M].vertices;
              e[M].data.push(S[g.a], S[g.b], S[g.c]);
            }
            for (M = 0; M < p; M++) {
              var E = h[M].vertexNormals[u];
              l[M].data.push(E.a, E.b, E.c);
            }
            m && this.skinIndices.push(f[g.a], f[g.b], f[g.c]),
              v && this.skinWeights.push(d[g.a], d[g.b], d[g.c]);
          }
          return (
            this.computeGroups(t),
            (this.verticesNeedUpdate = t.verticesNeedUpdate),
            (this.normalsNeedUpdate = t.normalsNeedUpdate),
            (this.colorsNeedUpdate = t.colorsNeedUpdate),
            (this.uvsNeedUpdate = t.uvsNeedUpdate),
            (this.groupsNeedUpdate = t.groupsNeedUpdate),
            null !== t.boundingSphere &&
              (this.boundingSphere = t.boundingSphere.clone()),
            null !== t.boundingBox &&
              (this.boundingBox = t.boundingBox.clone()),
            this
          );
        },
      });
    var zr = 1,
      Fr = new pn(),
      Ur = new Rn(),
      Br = new Ye(),
      Gr = new kn(),
      jr = new kn(),
      Vr = new Ye();
    function Hr() {
      Object.defineProperty(this, "id", { value: (zr += 2) }),
        (this.uuid = He.generateUUID()),
        (this.name = ""),
        (this.type = "BufferGeometry"),
        (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.drawRange = { start: 0, count: 1 / 0 }),
        (this.userData = {});
    }
    Hr.prototype = Object.assign(Object.create(Ge.prototype), {
      constructor: Hr,
      isBufferGeometry: !0,
      getIndex: function () {
        return this.index;
      },
      setIndex: function (t) {
        Array.isArray(t)
          ? (this.index = new (Dr(t) > 65535 ? Cr : Pr)(t, 1))
          : (this.index = t);
      },
      addAttribute: function (t, e) {
        return (e && e.isBufferAttribute) ||
          (e && e.isInterleavedBufferAttribute)
          ? "index" === t
            ? (console.warn(
                "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
              ),
              this.setIndex(e),
              this)
            : this.setAttribute(t, e)
          : (console.warn(
              "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
            ),
            this.addAttribute(t, new Sr(arguments[1], arguments[2])));
      },
      getAttribute: function (t) {
        return this.attributes[t];
      },
      setAttribute: function (t, e) {
        return (this.attributes[t] = e), this;
      },
      removeAttribute: function (t) {
        return delete this.attributes[t], this;
      },
      addGroup: function (t, e, n) {
        this.groups.push({
          start: t,
          count: e,
          materialIndex: void 0 !== n ? n : 0,
        });
      },
      clearGroups: function () {
        this.groups = [];
      },
      setDrawRange: function (t, e) {
        (this.drawRange.start = t), (this.drawRange.count = e);
      },
      applyMatrix: function (t) {
        var e = this.attributes.position;
        void 0 !== e && (t.applyToBufferAttribute(e), (e.needsUpdate = !0));
        var n = this.attributes.normal;
        void 0 !== n &&
          (new Qe().getNormalMatrix(t).applyToBufferAttribute(n),
          (n.needsUpdate = !0));
        var r = this.attributes.tangent;
        void 0 !== r &&
          (new Qe().getNormalMatrix(t).applyToBufferAttribute(r),
          (r.needsUpdate = !0));
        return (
          null !== this.boundingBox && this.computeBoundingBox(),
          null !== this.boundingSphere && this.computeBoundingSphere(),
          this
        );
      },
      rotateX: function (t) {
        return Fr.makeRotationX(t), this.applyMatrix(Fr), this;
      },
      rotateY: function (t) {
        return Fr.makeRotationY(t), this.applyMatrix(Fr), this;
      },
      rotateZ: function (t) {
        return Fr.makeRotationZ(t), this.applyMatrix(Fr), this;
      },
      translate: function (t, e, n) {
        return Fr.makeTranslation(t, e, n), this.applyMatrix(Fr), this;
      },
      scale: function (t, e, n) {
        return Fr.makeScale(t, e, n), this.applyMatrix(Fr), this;
      },
      lookAt: function (t) {
        return (
          Ur.lookAt(t), Ur.updateMatrix(), this.applyMatrix(Ur.matrix), this
        );
      },
      center: function () {
        return (
          this.computeBoundingBox(),
          this.boundingBox.getCenter(Br).negate(),
          this.translate(Br.x, Br.y, Br.z),
          this
        );
      },
      setFromObject: function (t) {
        var e = t.geometry;
        if (t.isPoints || t.isLine) {
          var n = new Or(3 * e.vertices.length, 3),
            r = new Or(3 * e.colors.length, 3);
          if (
            (this.addAttribute("position", n.copyVector3sArray(e.vertices)),
            this.addAttribute("color", r.copyColorsArray(e.colors)),
            e.lineDistances && e.lineDistances.length === e.vertices.length)
          ) {
            var i = new Or(e.lineDistances.length, 1);
            this.addAttribute("lineDistance", i.copyArray(e.lineDistances));
          }
          null !== e.boundingSphere &&
            (this.boundingSphere = e.boundingSphere.clone()),
            null !== e.boundingBox &&
              (this.boundingBox = e.boundingBox.clone());
        } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
        return this;
      },
      setFromPoints: function (t) {
        for (var e = [], n = 0, r = t.length; n < r; n++) {
          var i = t[n];
          e.push(i.x, i.y, i.z || 0);
        }
        return this.addAttribute("position", new Or(e, 3)), this;
      },
      updateFromObject: function (t) {
        var e,
          n = t.geometry;
        if (t.isMesh) {
          var r = n.__directGeometry;
          if (
            (!0 === n.elementsNeedUpdate &&
              ((r = void 0), (n.elementsNeedUpdate = !1)),
            void 0 === r)
          )
            return this.fromGeometry(n);
          (r.verticesNeedUpdate = n.verticesNeedUpdate),
            (r.normalsNeedUpdate = n.normalsNeedUpdate),
            (r.colorsNeedUpdate = n.colorsNeedUpdate),
            (r.uvsNeedUpdate = n.uvsNeedUpdate),
            (r.groupsNeedUpdate = n.groupsNeedUpdate),
            (n.verticesNeedUpdate = !1),
            (n.normalsNeedUpdate = !1),
            (n.colorsNeedUpdate = !1),
            (n.uvsNeedUpdate = !1),
            (n.groupsNeedUpdate = !1),
            (n = r);
        }
        return (
          !0 === n.verticesNeedUpdate &&
            (void 0 !== (e = this.attributes.position) &&
              (e.copyVector3sArray(n.vertices), (e.needsUpdate = !0)),
            (n.verticesNeedUpdate = !1)),
          !0 === n.normalsNeedUpdate &&
            (void 0 !== (e = this.attributes.normal) &&
              (e.copyVector3sArray(n.normals), (e.needsUpdate = !0)),
            (n.normalsNeedUpdate = !1)),
          !0 === n.colorsNeedUpdate &&
            (void 0 !== (e = this.attributes.color) &&
              (e.copyColorsArray(n.colors), (e.needsUpdate = !0)),
            (n.colorsNeedUpdate = !1)),
          n.uvsNeedUpdate &&
            (void 0 !== (e = this.attributes.uv) &&
              (e.copyVector2sArray(n.uvs), (e.needsUpdate = !0)),
            (n.uvsNeedUpdate = !1)),
          n.lineDistancesNeedUpdate &&
            (void 0 !== (e = this.attributes.lineDistance) &&
              (e.copyArray(n.lineDistances), (e.needsUpdate = !0)),
            (n.lineDistancesNeedUpdate = !1)),
          n.groupsNeedUpdate &&
            (n.computeGroups(t.geometry),
            (this.groups = n.groups),
            (n.groupsNeedUpdate = !1)),
          this
        );
      },
      fromGeometry: function (t) {
        return (
          (t.__directGeometry = new Nr().fromGeometry(t)),
          this.fromDirectGeometry(t.__directGeometry)
        );
      },
      fromDirectGeometry: function (t) {
        var e = new Float32Array(3 * t.vertices.length);
        if (
          (this.addAttribute(
            "position",
            new Sr(e, 3).copyVector3sArray(t.vertices)
          ),
          t.normals.length > 0)
        ) {
          var n = new Float32Array(3 * t.normals.length);
          this.addAttribute(
            "normal",
            new Sr(n, 3).copyVector3sArray(t.normals)
          );
        }
        if (t.colors.length > 0) {
          var r = new Float32Array(3 * t.colors.length);
          this.addAttribute("color", new Sr(r, 3).copyColorsArray(t.colors));
        }
        if (t.uvs.length > 0) {
          var i = new Float32Array(2 * t.uvs.length);
          this.addAttribute("uv", new Sr(i, 2).copyVector2sArray(t.uvs));
        }
        if (t.uvs2.length > 0) {
          var o = new Float32Array(2 * t.uvs2.length);
          this.addAttribute("uv2", new Sr(o, 2).copyVector2sArray(t.uvs2));
        }
        for (var a in ((this.groups = t.groups), t.morphTargets)) {
          for (
            var s = [], c = t.morphTargets[a], u = 0, l = c.length;
            u < l;
            u++
          ) {
            var h = c[u],
              p = new Or(3 * h.data.length, 3);
            (p.name = h.name), s.push(p.copyVector3sArray(h.data));
          }
          this.morphAttributes[a] = s;
        }
        if (t.skinIndices.length > 0) {
          var f = new Or(4 * t.skinIndices.length, 4);
          this.addAttribute("skinIndex", f.copyVector4sArray(t.skinIndices));
        }
        if (t.skinWeights.length > 0) {
          var d = new Or(4 * t.skinWeights.length, 4);
          this.addAttribute("skinWeight", d.copyVector4sArray(t.skinWeights));
        }
        return (
          null !== t.boundingSphere &&
            (this.boundingSphere = t.boundingSphere.clone()),
          null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
          this
        );
      },
      computeBoundingBox: function () {
        null === this.boundingBox && (this.boundingBox = new kn());
        var t = this.attributes.position,
          e = this.morphAttributes.position;
        if (void 0 !== t) {
          if ((this.boundingBox.setFromBufferAttribute(t), e))
            for (var n = 0, r = e.length; n < r; n++) {
              var i = e[n];
              Gr.setFromBufferAttribute(i),
                this.boundingBox.expandByPoint(Gr.min),
                this.boundingBox.expandByPoint(Gr.max);
            }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) ||
          isNaN(this.boundingBox.min.y) ||
          isNaN(this.boundingBox.min.z)) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
            this
          );
      },
      computeBoundingSphere: function () {
        null === this.boundingSphere && (this.boundingSphere = new Xn());
        var t = this.attributes.position,
          e = this.morphAttributes.position;
        if (t) {
          var n = this.boundingSphere.center;
          if ((Gr.setFromBufferAttribute(t), e))
            for (var r = 0, i = e.length; r < i; r++) {
              var o = e[r];
              jr.setFromBufferAttribute(o),
                Gr.expandByPoint(jr.min),
                Gr.expandByPoint(jr.max);
            }
          Gr.getCenter(n);
          var a = 0;
          for (r = 0, i = t.count; r < i; r++)
            Vr.fromBufferAttribute(t, r),
              (a = Math.max(a, n.distanceToSquared(Vr)));
          if (e)
            for (r = 0, i = e.length; r < i; r++)
              for (var s = 0, c = (o = e[r]).count; s < c; s++)
                Vr.fromBufferAttribute(o, s),
                  (a = Math.max(a, n.distanceToSquared(Vr)));
          (this.boundingSphere.radius = Math.sqrt(a)),
            isNaN(this.boundingSphere.radius) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                this
              );
        }
      },
      computeFaceNormals: function () {},
      computeVertexNormals: function () {
        var t = this.index,
          e = this.attributes;
        if (e.position) {
          var n = e.position.array;
          if (void 0 === e.normal)
            this.addAttribute("normal", new Sr(new Float32Array(n.length), 3));
          else
            for (var r = e.normal.array, i = 0, o = r.length; i < o; i++)
              r[i] = 0;
          var a,
            s,
            c,
            u = e.normal.array,
            l = new Ye(),
            h = new Ye(),
            p = new Ye(),
            f = new Ye(),
            d = new Ye();
          if (t) {
            var m = t.array;
            for (i = 0, o = t.count; i < o; i += 3)
              (a = 3 * m[i + 0]),
                (s = 3 * m[i + 1]),
                (c = 3 * m[i + 2]),
                l.fromArray(n, a),
                h.fromArray(n, s),
                p.fromArray(n, c),
                f.subVectors(p, h),
                d.subVectors(l, h),
                f.cross(d),
                (u[a] += f.x),
                (u[a + 1] += f.y),
                (u[a + 2] += f.z),
                (u[s] += f.x),
                (u[s + 1] += f.y),
                (u[s + 2] += f.z),
                (u[c] += f.x),
                (u[c + 1] += f.y),
                (u[c + 2] += f.z);
          } else
            for (i = 0, o = n.length; i < o; i += 9)
              l.fromArray(n, i),
                h.fromArray(n, i + 3),
                p.fromArray(n, i + 6),
                f.subVectors(p, h),
                d.subVectors(l, h),
                f.cross(d),
                (u[i] = f.x),
                (u[i + 1] = f.y),
                (u[i + 2] = f.z),
                (u[i + 3] = f.x),
                (u[i + 4] = f.y),
                (u[i + 5] = f.z),
                (u[i + 6] = f.x),
                (u[i + 7] = f.y),
                (u[i + 8] = f.z);
          this.normalizeNormals(), (e.normal.needsUpdate = !0);
        }
      },
      merge: function (t, e) {
        if (t && t.isBufferGeometry) {
          void 0 === e &&
            ((e = 0),
            console.warn(
              "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
            ));
          var n = this.attributes;
          for (var r in n)
            if (void 0 !== t.attributes[r])
              for (
                var i = n[r].array,
                  o = t.attributes[r],
                  a = o.array,
                  s = o.itemSize * e,
                  c = Math.min(a.length, i.length - s),
                  u = 0,
                  l = s;
                u < c;
                u++, l++
              )
                i[l] = a[u];
          return this;
        }
        console.error(
          "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
          t
        );
      },
      normalizeNormals: function () {
        for (var t = this.attributes.normal, e = 0, n = t.count; e < n; e++)
          (Vr.x = t.getX(e)),
            (Vr.y = t.getY(e)),
            (Vr.z = t.getZ(e)),
            Vr.normalize(),
            t.setXYZ(e, Vr.x, Vr.y, Vr.z);
      },
      toNonIndexed: function () {
        function t(t, e) {
          for (
            var n = t.array,
              r = t.itemSize,
              i = new n.constructor(e.length * r),
              o = 0,
              a = 0,
              s = 0,
              c = e.length;
            s < c;
            s++
          ) {
            o = e[s] * r;
            for (var u = 0; u < r; u++) i[a++] = n[o++];
          }
          return new Sr(i, r);
        }
        if (null === this.index)
          return (
            console.warn(
              "THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
            ),
            this
          );
        var e = new Hr(),
          n = this.index.array,
          r = this.attributes;
        for (var i in r) {
          var o = t(r[i], n);
          e.addAttribute(i, o);
        }
        var a = this.morphAttributes;
        for (i in a) {
          for (var s = [], c = a[i], u = 0, l = c.length; u < l; u++) {
            o = t(c[u], n);
            s.push(o);
          }
          e.morphAttributes[i] = s;
        }
        for (var h = this.groups, p = ((u = 0), h.length); u < p; u++) {
          var f = h[u];
          e.addGroup(f.start, f.count, f.materialIndex);
        }
        return e;
      },
      toJSON: function () {
        var t = {
          metadata: {
            version: 4.5,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON",
          },
        };
        if (
          ((t.uuid = this.uuid),
          (t.type = this.type),
          "" !== this.name && (t.name = this.name),
          Object.keys(this.userData).length > 0 && (t.userData = this.userData),
          void 0 !== this.parameters)
        ) {
          var e = this.parameters;
          for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
          return t;
        }
        t.data = { attributes: {} };
        var r = this.index;
        null !== r &&
          (t.data.index = {
            type: r.array.constructor.name,
            array: Array.prototype.slice.call(r.array),
          });
        var i = this.attributes;
        for (var n in i) {
          var o = (p = i[n]).toJSON();
          "" !== p.name && (o.name = p.name), (t.data.attributes[n] = o);
        }
        var a = {},
          s = !1;
        for (var n in this.morphAttributes) {
          for (
            var c = this.morphAttributes[n], u = [], l = 0, h = c.length;
            l < h;
            l++
          ) {
            var p;
            o = (p = c[l]).toJSON();
            "" !== p.name && (o.name = p.name), u.push(o);
          }
          u.length > 0 && ((a[n] = u), (s = !0));
        }
        s && (t.data.morphAttributes = a);
        var f = this.groups;
        f.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(f)));
        var d = this.boundingSphere;
        return (
          null !== d &&
            (t.data.boundingSphere = {
              center: d.center.toArray(),
              radius: d.radius,
            }),
          t
        );
      },
      clone: function () {
        return new Hr().copy(this);
      },
      copy: function (t) {
        var e, n, r;
        (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.name = t.name);
        var i = t.index;
        null !== i && this.setIndex(i.clone());
        var o = t.attributes;
        for (e in o) {
          var a = o[e];
          this.addAttribute(e, a.clone());
        }
        var s = t.morphAttributes;
        for (e in s) {
          var c = [],
            u = s[e];
          for (n = 0, r = u.length; n < r; n++) c.push(u[n].clone());
          this.morphAttributes[e] = c;
        }
        var l = t.groups;
        for (n = 0, r = l.length; n < r; n++) {
          var h = l[n];
          this.addGroup(h.start, h.count, h.materialIndex);
        }
        var p = t.boundingBox;
        null !== p && (this.boundingBox = p.clone());
        var f = t.boundingSphere;
        return (
          null !== f && (this.boundingSphere = f.clone()),
          (this.drawRange.start = t.drawRange.start),
          (this.drawRange.count = t.drawRange.count),
          (this.userData = t.userData),
          this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: "dispose" });
      },
    });
    var kr = new pn(),
      Wr = new er(),
      qr = new Xn(),
      Xr = new Ye(),
      Yr = new Ye(),
      Jr = new Ye(),
      Zr = new Ye(),
      Qr = new Ye(),
      Kr = new Ye(),
      $r = new Ye(),
      ti = new Ye(),
      ei = new Ye(),
      ni = new ke(),
      ri = new ke(),
      ii = new ke(),
      oi = new Ye(),
      ai = new Ye();
    function si(t, e) {
      Rn.call(this),
        (this.type = "Mesh"),
        (this.geometry = void 0 !== t ? t : new Hr()),
        (this.material =
          void 0 !== e ? e : new Mr({ color: 16777215 * Math.random() })),
        (this.drawMode = Me),
        this.updateMorphTargets();
    }
    function ci(t, e, n, r, i, o, a, s) {
      if (
        null ===
        (e.side === T
          ? r.intersectTriangle(a, o, i, !0, s)
          : r.intersectTriangle(i, o, a, e.side !== A, s))
      )
        return null;
      ai.copy(s), ai.applyMatrix4(t.matrixWorld);
      var c = n.ray.origin.distanceTo(ai);
      return c < n.near || c > n.far
        ? null
        : { distance: c, point: ai.clone(), object: t };
    }
    function ui(t, e, n, r, i, o, a, s, c, u, l) {
      Xr.fromBufferAttribute(i, c),
        Yr.fromBufferAttribute(i, u),
        Jr.fromBufferAttribute(i, l);
      var h = t.morphTargetInfluences;
      if (e.morphTargets && o && h) {
        $r.set(0, 0, 0), ti.set(0, 0, 0), ei.set(0, 0, 0);
        for (var p = 0, f = o.length; p < f; p++) {
          var d = h[p],
            m = o[p];
          0 !== d &&
            (Zr.fromBufferAttribute(m, c),
            Qr.fromBufferAttribute(m, u),
            Kr.fromBufferAttribute(m, l),
            $r.addScaledVector(Zr.sub(Xr), d),
            ti.addScaledVector(Qr.sub(Yr), d),
            ei.addScaledVector(Kr.sub(Jr), d));
        }
        Xr.add($r), Yr.add(ti), Jr.add(ei);
      }
      var v = ci(t, e, n, r, Xr, Yr, Jr, oi);
      if (v) {
        a &&
          (ni.fromBufferAttribute(a, c),
          ri.fromBufferAttribute(a, u),
          ii.fromBufferAttribute(a, l),
          (v.uv = pr.getUV(oi, Xr, Yr, Jr, ni, ri, ii, new ke()))),
          s &&
            (ni.fromBufferAttribute(s, c),
            ri.fromBufferAttribute(s, u),
            ii.fromBufferAttribute(s, l),
            (v.uv2 = pr.getUV(oi, Xr, Yr, Jr, ni, ri, ii, new ke())));
        var g = new br(c, u, l);
        pr.getNormal(Xr, Yr, Jr, g.normal), (v.face = g);
      }
      return v;
    }
    si.prototype = Object.assign(Object.create(Rn.prototype), {
      constructor: si,
      isMesh: !0,
      setDrawMode: function (t) {
        this.drawMode = t;
      },
      copy: function (t) {
        return (
          Rn.prototype.copy.call(this, t),
          (this.drawMode = t.drawMode),
          void 0 !== t.morphTargetInfluences &&
            (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
          void 0 !== t.morphTargetDictionary &&
            (this.morphTargetDictionary = Object.assign(
              {},
              t.morphTargetDictionary
            )),
          this
        );
      },
      updateMorphTargets: function () {
        var t,
          e,
          n,
          r = this.geometry;
        if (r.isBufferGeometry) {
          var i = r.morphAttributes,
            o = Object.keys(i);
          if (o.length > 0) {
            var a = i[o[0]];
            if (void 0 !== a)
              for (
                this.morphTargetInfluences = [],
                  this.morphTargetDictionary = {},
                  t = 0,
                  e = a.length;
                t < e;
                t++
              )
                (n = a[t].name || String(t)),
                  this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = t);
          }
        } else {
          var s = r.morphTargets;
          void 0 !== s &&
            s.length > 0 &&
            console.error(
              "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
      },
      raycast: function (t, e) {
        var n,
          r = this.geometry,
          i = this.material,
          o = this.matrixWorld;
        if (
          void 0 !== i &&
          (null === r.boundingSphere && r.computeBoundingSphere(),
          qr.copy(r.boundingSphere),
          qr.applyMatrix4(o),
          !1 !== t.ray.intersectsSphere(qr) &&
            (kr.getInverse(o),
            Wr.copy(t.ray).applyMatrix4(kr),
            null === r.boundingBox || !1 !== Wr.intersectsBox(r.boundingBox)))
        )
          if (r.isBufferGeometry) {
            var a,
              s,
              c,
              u,
              l,
              h,
              p,
              f,
              d,
              m = r.index,
              v = r.attributes.position,
              g = r.morphAttributes.position,
              y = r.attributes.uv,
              x = r.attributes.uv2,
              b = r.groups,
              w = r.drawRange;
            if (null !== m)
              if (Array.isArray(i))
                for (u = 0, h = b.length; u < h; u++)
                  for (
                    d = i[(f = b[u]).materialIndex],
                      l = Math.max(f.start, w.start),
                      p = Math.min(f.start + f.count, w.start + w.count);
                    l < p;
                    l += 3
                  )
                    (a = m.getX(l)),
                      (s = m.getX(l + 1)),
                      (c = m.getX(l + 2)),
                      (n = ui(this, d, t, Wr, v, g, y, x, a, s, c)) &&
                        ((n.faceIndex = Math.floor(l / 3)),
                        (n.face.materialIndex = f.materialIndex),
                        e.push(n));
              else
                for (
                  u = Math.max(0, w.start),
                    h = Math.min(m.count, w.start + w.count);
                  u < h;
                  u += 3
                )
                  (a = m.getX(u)),
                    (s = m.getX(u + 1)),
                    (c = m.getX(u + 2)),
                    (n = ui(this, i, t, Wr, v, g, y, x, a, s, c)) &&
                      ((n.faceIndex = Math.floor(u / 3)), e.push(n));
            else if (void 0 !== v)
              if (Array.isArray(i))
                for (u = 0, h = b.length; u < h; u++)
                  for (
                    d = i[(f = b[u]).materialIndex],
                      l = Math.max(f.start, w.start),
                      p = Math.min(f.start + f.count, w.start + w.count);
                    l < p;
                    l += 3
                  )
                    (n = ui(
                      this,
                      d,
                      t,
                      Wr,
                      v,
                      g,
                      y,
                      x,
                      (a = l),
                      (s = l + 1),
                      (c = l + 2)
                    )) &&
                      ((n.faceIndex = Math.floor(l / 3)),
                      (n.face.materialIndex = f.materialIndex),
                      e.push(n));
              else
                for (
                  u = Math.max(0, w.start),
                    h = Math.min(v.count, w.start + w.count);
                  u < h;
                  u += 3
                )
                  (n = ui(
                    this,
                    i,
                    t,
                    Wr,
                    v,
                    g,
                    y,
                    x,
                    (a = u),
                    (s = u + 1),
                    (c = u + 2)
                  )) && ((n.faceIndex = Math.floor(u / 3)), e.push(n));
          } else if (r.isGeometry) {
            var _,
              M,
              S,
              E,
              T = Array.isArray(i),
              A = r.vertices,
              L = r.faces,
              P = r.faceVertexUvs[0];
            P.length > 0 && (E = P);
            for (var R = 0, C = L.length; R < C; R++) {
              var O = L[R],
                I = T ? i[O.materialIndex] : i;
              if (
                void 0 !== I &&
                ((_ = A[O.a]),
                (M = A[O.b]),
                (S = A[O.c]),
                (n = ci(this, I, t, Wr, _, M, S, oi)))
              ) {
                if (E && E[R]) {
                  var N = E[R];
                  ni.copy(N[0]),
                    ri.copy(N[1]),
                    ii.copy(N[2]),
                    (n.uv = pr.getUV(oi, _, M, S, ni, ri, ii, new ke()));
                }
                (n.face = O), (n.faceIndex = R), e.push(n);
              }
            }
          }
      },
      clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      },
    });
    var li = 0,
      hi = new pn(),
      pi = new Rn(),
      fi = new Ye();
    function di() {
      Object.defineProperty(this, "id", { value: (li += 2) }),
        (this.uuid = He.generateUUID()),
        (this.name = ""),
        (this.type = "Geometry"),
        (this.vertices = []),
        (this.colors = []),
        (this.faces = []),
        (this.faceVertexUvs = [[]]),
        (this.morphTargets = []),
        (this.morphNormals = []),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.lineDistances = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.elementsNeedUpdate = !1),
        (this.verticesNeedUpdate = !1),
        (this.uvsNeedUpdate = !1),
        (this.normalsNeedUpdate = !1),
        (this.colorsNeedUpdate = !1),
        (this.lineDistancesNeedUpdate = !1),
        (this.groupsNeedUpdate = !1);
    }
    di.prototype = Object.assign(Object.create(Ge.prototype), {
      constructor: di,
      isGeometry: !0,
      applyMatrix: function (t) {
        for (
          var e = new Qe().getNormalMatrix(t), n = 0, r = this.vertices.length;
          n < r;
          n++
        ) {
          this.vertices[n].applyMatrix4(t);
        }
        for (n = 0, r = this.faces.length; n < r; n++) {
          var i = this.faces[n];
          i.normal.applyMatrix3(e).normalize();
          for (var o = 0, a = i.vertexNormals.length; o < a; o++)
            i.vertexNormals[o].applyMatrix3(e).normalize();
        }
        return (
          null !== this.boundingBox && this.computeBoundingBox(),
          null !== this.boundingSphere && this.computeBoundingSphere(),
          (this.verticesNeedUpdate = !0),
          (this.normalsNeedUpdate = !0),
          this
        );
      },
      rotateX: function (t) {
        return hi.makeRotationX(t), this.applyMatrix(hi), this;
      },
      rotateY: function (t) {
        return hi.makeRotationY(t), this.applyMatrix(hi), this;
      },
      rotateZ: function (t) {
        return hi.makeRotationZ(t), this.applyMatrix(hi), this;
      },
      translate: function (t, e, n) {
        return hi.makeTranslation(t, e, n), this.applyMatrix(hi), this;
      },
      scale: function (t, e, n) {
        return hi.makeScale(t, e, n), this.applyMatrix(hi), this;
      },
      lookAt: function (t) {
        return (
          pi.lookAt(t), pi.updateMatrix(), this.applyMatrix(pi.matrix), this
        );
      },
      fromBufferGeometry: function (t) {
        var e = this,
          n = null !== t.index ? t.index.array : void 0,
          r = t.attributes;
        if (void 0 === r.position)
          return (
            console.error(
              "THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."
            ),
            this
          );
        var i = r.position.array,
          o = void 0 !== r.normal ? r.normal.array : void 0,
          a = void 0 !== r.color ? r.color.array : void 0,
          s = void 0 !== r.uv ? r.uv.array : void 0,
          c = void 0 !== r.uv2 ? r.uv2.array : void 0;
        void 0 !== c && (this.faceVertexUvs[1] = []);
        for (var u = 0; u < i.length; u += 3)
          e.vertices.push(new Ye().fromArray(i, u)),
            void 0 !== a && e.colors.push(new vr().fromArray(a, u));
        function l(t, n, r, i) {
          var u =
              void 0 === a
                ? []
                : [
                    e.colors[t].clone(),
                    e.colors[n].clone(),
                    e.colors[r].clone(),
                  ],
            l = new br(
              t,
              n,
              r,
              void 0 === o
                ? []
                : [
                    new Ye().fromArray(o, 3 * t),
                    new Ye().fromArray(o, 3 * n),
                    new Ye().fromArray(o, 3 * r),
                  ],
              u,
              i
            );
          e.faces.push(l),
            void 0 !== s &&
              e.faceVertexUvs[0].push([
                new ke().fromArray(s, 2 * t),
                new ke().fromArray(s, 2 * n),
                new ke().fromArray(s, 2 * r),
              ]),
            void 0 !== c &&
              e.faceVertexUvs[1].push([
                new ke().fromArray(c, 2 * t),
                new ke().fromArray(c, 2 * n),
                new ke().fromArray(c, 2 * r),
              ]);
        }
        var h = t.groups;
        if (h.length > 0)
          for (u = 0; u < h.length; u++)
            for (
              var p = h[u], f = p.start, d = f, m = f + p.count;
              d < m;
              d += 3
            )
              void 0 !== n
                ? l(n[d], n[d + 1], n[d + 2], p.materialIndex)
                : l(d, d + 1, d + 2, p.materialIndex);
        else if (void 0 !== n)
          for (u = 0; u < n.length; u += 3) l(n[u], n[u + 1], n[u + 2]);
        else for (u = 0; u < i.length / 3; u += 3) l(u, u + 1, u + 2);
        return (
          this.computeFaceNormals(),
          null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
          null !== t.boundingSphere &&
            (this.boundingSphere = t.boundingSphere.clone()),
          this
        );
      },
      center: function () {
        return (
          this.computeBoundingBox(),
          this.boundingBox.getCenter(fi).negate(),
          this.translate(fi.x, fi.y, fi.z),
          this
        );
      },
      normalize: function () {
        this.computeBoundingSphere();
        var t = this.boundingSphere.center,
          e = this.boundingSphere.radius,
          n = 0 === e ? 1 : 1 / e,
          r = new pn();
        return (
          r.set(
            n,
            0,
            0,
            -n * t.x,
            0,
            n,
            0,
            -n * t.y,
            0,
            0,
            n,
            -n * t.z,
            0,
            0,
            0,
            1
          ),
          this.applyMatrix(r),
          this
        );
      },
      computeFaceNormals: function () {
        for (
          var t = new Ye(), e = new Ye(), n = 0, r = this.faces.length;
          n < r;
          n++
        ) {
          var i = this.faces[n],
            o = this.vertices[i.a],
            a = this.vertices[i.b],
            s = this.vertices[i.c];
          t.subVectors(s, a),
            e.subVectors(o, a),
            t.cross(e),
            t.normalize(),
            i.normal.copy(t);
        }
      },
      computeVertexNormals: function (t) {
        var e, n, r, i, o, a;
        for (
          void 0 === t && (t = !0),
            a = new Array(this.vertices.length),
            e = 0,
            n = this.vertices.length;
          e < n;
          e++
        )
          a[e] = new Ye();
        if (t) {
          var s,
            c,
            u,
            l = new Ye(),
            h = new Ye();
          for (r = 0, i = this.faces.length; r < i; r++)
            (o = this.faces[r]),
              (s = this.vertices[o.a]),
              (c = this.vertices[o.b]),
              (u = this.vertices[o.c]),
              l.subVectors(u, c),
              h.subVectors(s, c),
              l.cross(h),
              a[o.a].add(l),
              a[o.b].add(l),
              a[o.c].add(l);
        } else
          for (
            this.computeFaceNormals(), r = 0, i = this.faces.length;
            r < i;
            r++
          )
            a[(o = this.faces[r]).a].add(o.normal),
              a[o.b].add(o.normal),
              a[o.c].add(o.normal);
        for (e = 0, n = this.vertices.length; e < n; e++) a[e].normalize();
        for (r = 0, i = this.faces.length; r < i; r++) {
          var p = (o = this.faces[r]).vertexNormals;
          3 === p.length
            ? (p[0].copy(a[o.a]), p[1].copy(a[o.b]), p[2].copy(a[o.c]))
            : ((p[0] = a[o.a].clone()),
              (p[1] = a[o.b].clone()),
              (p[2] = a[o.c].clone()));
        }
        this.faces.length > 0 && (this.normalsNeedUpdate = !0);
      },
      computeFlatVertexNormals: function () {
        var t, e, n;
        for (
          this.computeFaceNormals(), t = 0, e = this.faces.length;
          t < e;
          t++
        ) {
          var r = (n = this.faces[t]).vertexNormals;
          3 === r.length
            ? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal))
            : ((r[0] = n.normal.clone()),
              (r[1] = n.normal.clone()),
              (r[2] = n.normal.clone()));
        }
        this.faces.length > 0 && (this.normalsNeedUpdate = !0);
      },
      computeMorphNormals: function () {
        var t, e, n, r, i;
        for (n = 0, r = this.faces.length; n < r; n++)
          for (
            (i = this.faces[n]).__originalFaceNormal
              ? i.__originalFaceNormal.copy(i.normal)
              : (i.__originalFaceNormal = i.normal.clone()),
              i.__originalVertexNormals || (i.__originalVertexNormals = []),
              t = 0,
              e = i.vertexNormals.length;
            t < e;
            t++
          )
            i.__originalVertexNormals[t]
              ? i.__originalVertexNormals[t].copy(i.vertexNormals[t])
              : (i.__originalVertexNormals[t] = i.vertexNormals[t].clone());
        var o = new di();
        for (
          o.faces = this.faces, t = 0, e = this.morphTargets.length;
          t < e;
          t++
        ) {
          if (!this.morphNormals[t]) {
            (this.morphNormals[t] = {}),
              (this.morphNormals[t].faceNormals = []),
              (this.morphNormals[t].vertexNormals = []);
            var a = this.morphNormals[t].faceNormals,
              s = this.morphNormals[t].vertexNormals;
            for (n = 0, r = this.faces.length; n < r; n++)
              (c = new Ye()),
                (u = { a: new Ye(), b: new Ye(), c: new Ye() }),
                a.push(c),
                s.push(u);
          }
          var c,
            u,
            l = this.morphNormals[t];
          for (
            o.vertices = this.morphTargets[t].vertices,
              o.computeFaceNormals(),
              o.computeVertexNormals(),
              n = 0,
              r = this.faces.length;
            n < r;
            n++
          )
            (i = this.faces[n]),
              (c = l.faceNormals[n]),
              (u = l.vertexNormals[n]),
              c.copy(i.normal),
              u.a.copy(i.vertexNormals[0]),
              u.b.copy(i.vertexNormals[1]),
              u.c.copy(i.vertexNormals[2]);
        }
        for (n = 0, r = this.faces.length; n < r; n++)
          ((i = this.faces[n]).normal = i.__originalFaceNormal),
            (i.vertexNormals = i.__originalVertexNormals);
      },
      computeBoundingBox: function () {
        null === this.boundingBox && (this.boundingBox = new kn()),
          this.boundingBox.setFromPoints(this.vertices);
      },
      computeBoundingSphere: function () {
        null === this.boundingSphere && (this.boundingSphere = new Xn()),
          this.boundingSphere.setFromPoints(this.vertices);
      },
      merge: function (t, e, n) {
        if (t && t.isGeometry) {
          var r,
            i = this.vertices.length,
            o = this.vertices,
            a = t.vertices,
            s = this.faces,
            c = t.faces,
            u = this.colors,
            l = t.colors;
          void 0 === n && (n = 0),
            void 0 !== e && (r = new Qe().getNormalMatrix(e));
          for (var h = 0, p = a.length; h < p; h++) {
            var f = a[h].clone();
            void 0 !== e && f.applyMatrix4(e), o.push(f);
          }
          for (h = 0, p = l.length; h < p; h++) u.push(l[h].clone());
          for (h = 0, p = c.length; h < p; h++) {
            var d,
              m,
              v,
              g = c[h],
              y = g.vertexNormals,
              x = g.vertexColors;
            (d = new br(g.a + i, g.b + i, g.c + i)).normal.copy(g.normal),
              void 0 !== r && d.normal.applyMatrix3(r).normalize();
            for (var b = 0, w = y.length; b < w; b++)
              (m = y[b].clone()),
                void 0 !== r && m.applyMatrix3(r).normalize(),
                d.vertexNormals.push(m);
            d.color.copy(g.color);
            for (b = 0, w = x.length; b < w; b++)
              (v = x[b]), d.vertexColors.push(v.clone());
            (d.materialIndex = g.materialIndex + n), s.push(d);
          }
          for (h = 0, p = t.faceVertexUvs.length; h < p; h++) {
            var _ = t.faceVertexUvs[h];
            void 0 === this.faceVertexUvs[h] && (this.faceVertexUvs[h] = []);
            for (b = 0, w = _.length; b < w; b++) {
              for (var M = _[b], S = [], E = 0, T = M.length; E < T; E++)
                S.push(M[E].clone());
              this.faceVertexUvs[h].push(S);
            }
          }
        } else
          console.error(
            "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
            t
          );
      },
      mergeMesh: function (t) {
        t && t.isMesh
          ? (t.matrixAutoUpdate && t.updateMatrix(),
            this.merge(t.geometry, t.matrix))
          : console.error(
              "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
              t
            );
      },
      mergeVertices: function () {
        var t,
          e,
          n,
          r,
          i,
          o,
          a,
          s,
          c = {},
          u = [],
          l = [],
          h = Math.pow(10, 4);
        for (n = 0, r = this.vertices.length; n < r; n++)
          (t = this.vertices[n]),
            void 0 ===
            c[
              (e =
                Math.round(t.x * h) +
                "_" +
                Math.round(t.y * h) +
                "_" +
                Math.round(t.z * h))
            ]
              ? ((c[e] = n), u.push(this.vertices[n]), (l[n] = u.length - 1))
              : (l[n] = l[c[e]]);
        var p = [];
        for (n = 0, r = this.faces.length; n < r; n++) {
          ((i = this.faces[n]).a = l[i.a]),
            (i.b = l[i.b]),
            (i.c = l[i.c]),
            (o = [i.a, i.b, i.c]);
          for (var f = 0; f < 3; f++)
            if (o[f] === o[(f + 1) % 3]) {
              p.push(n);
              break;
            }
        }
        for (n = p.length - 1; n >= 0; n--) {
          var d = p[n];
          for (
            this.faces.splice(d, 1), a = 0, s = this.faceVertexUvs.length;
            a < s;
            a++
          )
            this.faceVertexUvs[a].splice(d, 1);
        }
        var m = this.vertices.length - u.length;
        return (this.vertices = u), m;
      },
      setFromPoints: function (t) {
        this.vertices = [];
        for (var e = 0, n = t.length; e < n; e++) {
          var r = t[e];
          this.vertices.push(new Ye(r.x, r.y, r.z || 0));
        }
        return this;
      },
      sortFacesByMaterialIndex: function () {
        for (var t = this.faces, e = t.length, n = 0; n < e; n++) t[n]._id = n;
        t.sort(function (t, e) {
          return t.materialIndex - e.materialIndex;
        });
        var r,
          i,
          o = this.faceVertexUvs[0],
          a = this.faceVertexUvs[1];
        o && o.length === e && (r = []), a && a.length === e && (i = []);
        for (n = 0; n < e; n++) {
          var s = t[n]._id;
          r && r.push(o[s]), i && i.push(a[s]);
        }
        r && (this.faceVertexUvs[0] = r), i && (this.faceVertexUvs[1] = i);
      },
      toJSON: function () {
        var t = {
          metadata: {
            version: 4.5,
            type: "Geometry",
            generator: "Geometry.toJSON",
          },
        };
        if (
          ((t.uuid = this.uuid),
          (t.type = this.type),
          "" !== this.name && (t.name = this.name),
          void 0 !== this.parameters)
        ) {
          var e = this.parameters;
          for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
          return t;
        }
        for (var r = [], i = 0; i < this.vertices.length; i++) {
          var o = this.vertices[i];
          r.push(o.x, o.y, o.z);
        }
        var a = [],
          s = [],
          c = {},
          u = [],
          l = {},
          h = [],
          p = {};
        for (i = 0; i < this.faces.length; i++) {
          var f = this.faces[i],
            d = void 0 !== this.faceVertexUvs[0][i],
            m = f.normal.length() > 0,
            v = f.vertexNormals.length > 0,
            g = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b,
            y = f.vertexColors.length > 0,
            x = 0;
          if (
            ((x = M(x, 0, 0)),
            (x = M(x, 1, !0)),
            (x = M(x, 2, !1)),
            (x = M(x, 3, d)),
            (x = M(x, 4, m)),
            (x = M(x, 5, v)),
            (x = M(x, 6, g)),
            (x = M(x, 7, y)),
            a.push(x),
            a.push(f.a, f.b, f.c),
            a.push(f.materialIndex),
            d)
          ) {
            var b = this.faceVertexUvs[0][i];
            a.push(T(b[0]), T(b[1]), T(b[2]));
          }
          if ((m && a.push(S(f.normal)), v)) {
            var w = f.vertexNormals;
            a.push(S(w[0]), S(w[1]), S(w[2]));
          }
          if ((g && a.push(E(f.color)), y)) {
            var _ = f.vertexColors;
            a.push(E(_[0]), E(_[1]), E(_[2]));
          }
        }
        function M(t, e, n) {
          return n ? t | (1 << e) : t & ~(1 << e);
        }
        function S(t) {
          var e = t.x.toString() + t.y.toString() + t.z.toString();
          return void 0 !== c[e]
            ? c[e]
            : ((c[e] = s.length / 3), s.push(t.x, t.y, t.z), c[e]);
        }
        function E(t) {
          var e = t.r.toString() + t.g.toString() + t.b.toString();
          return void 0 !== l[e]
            ? l[e]
            : ((l[e] = u.length), u.push(t.getHex()), l[e]);
        }
        function T(t) {
          var e = t.x.toString() + t.y.toString();
          return void 0 !== p[e]
            ? p[e]
            : ((p[e] = h.length / 2), h.push(t.x, t.y), p[e]);
        }
        return (
          (t.data = {}),
          (t.data.vertices = r),
          (t.data.normals = s),
          u.length > 0 && (t.data.colors = u),
          h.length > 0 && (t.data.uvs = [h]),
          (t.data.faces = a),
          t
        );
      },
      clone: function () {
        return new di().copy(this);
      },
      copy: function (t) {
        var e, n, r, i, o, a;
        (this.vertices = []),
          (this.colors = []),
          (this.faces = []),
          (this.faceVertexUvs = [[]]),
          (this.morphTargets = []),
          (this.morphNormals = []),
          (this.skinWeights = []),
          (this.skinIndices = []),
          (this.lineDistances = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.name = t.name);
        var s = t.vertices;
        for (e = 0, n = s.length; e < n; e++) this.vertices.push(s[e].clone());
        var c = t.colors;
        for (e = 0, n = c.length; e < n; e++) this.colors.push(c[e].clone());
        var u = t.faces;
        for (e = 0, n = u.length; e < n; e++) this.faces.push(u[e].clone());
        for (e = 0, n = t.faceVertexUvs.length; e < n; e++) {
          var l = t.faceVertexUvs[e];
          for (
            void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []),
              r = 0,
              i = l.length;
            r < i;
            r++
          ) {
            var h = l[r],
              p = [];
            for (o = 0, a = h.length; o < a; o++) {
              var f = h[o];
              p.push(f.clone());
            }
            this.faceVertexUvs[e].push(p);
          }
        }
        var d = t.morphTargets;
        for (e = 0, n = d.length; e < n; e++) {
          var m = {};
          if (((m.name = d[e].name), void 0 !== d[e].vertices))
            for (m.vertices = [], r = 0, i = d[e].vertices.length; r < i; r++)
              m.vertices.push(d[e].vertices[r].clone());
          if (void 0 !== d[e].normals)
            for (m.normals = [], r = 0, i = d[e].normals.length; r < i; r++)
              m.normals.push(d[e].normals[r].clone());
          this.morphTargets.push(m);
        }
        var v = t.morphNormals;
        for (e = 0, n = v.length; e < n; e++) {
          var g = {};
          if (void 0 !== v[e].vertexNormals)
            for (
              g.vertexNormals = [], r = 0, i = v[e].vertexNormals.length;
              r < i;
              r++
            ) {
              var y = v[e].vertexNormals[r],
                x = {};
              (x.a = y.a.clone()),
                (x.b = y.b.clone()),
                (x.c = y.c.clone()),
                g.vertexNormals.push(x);
            }
          if (void 0 !== v[e].faceNormals)
            for (
              g.faceNormals = [], r = 0, i = v[e].faceNormals.length;
              r < i;
              r++
            )
              g.faceNormals.push(v[e].faceNormals[r].clone());
          this.morphNormals.push(g);
        }
        var b = t.skinWeights;
        for (e = 0, n = b.length; e < n; e++)
          this.skinWeights.push(b[e].clone());
        var w = t.skinIndices;
        for (e = 0, n = w.length; e < n; e++)
          this.skinIndices.push(w[e].clone());
        var _ = t.lineDistances;
        for (e = 0, n = _.length; e < n; e++) this.lineDistances.push(_[e]);
        var M = t.boundingBox;
        null !== M && (this.boundingBox = M.clone());
        var S = t.boundingSphere;
        return (
          null !== S && (this.boundingSphere = S.clone()),
          (this.elementsNeedUpdate = t.elementsNeedUpdate),
          (this.verticesNeedUpdate = t.verticesNeedUpdate),
          (this.uvsNeedUpdate = t.uvsNeedUpdate),
          (this.normalsNeedUpdate = t.normalsNeedUpdate),
          (this.colorsNeedUpdate = t.colorsNeedUpdate),
          (this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate),
          (this.groupsNeedUpdate = t.groupsNeedUpdate),
          this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: "dispose" });
      },
    });
    class mi extends Hr {
      constructor(t, e, n, r, i, o) {
        super(),
          (this.type = "BoxBufferGeometry"),
          (this.parameters = {
            width: t,
            height: e,
            depth: n,
            widthSegments: r,
            heightSegments: i,
            depthSegments: o,
          });
        var a = this;
        (t = t || 1),
          (e = e || 1),
          (n = n || 1),
          (r = Math.floor(r) || 1),
          (i = Math.floor(i) || 1),
          (o = Math.floor(o) || 1);
        var s = [],
          c = [],
          u = [],
          l = [],
          h = 0,
          p = 0;
        function f(t, e, n, r, i, o, f, d, m, v, g) {
          var y,
            x,
            b = o / m,
            w = f / v,
            _ = o / 2,
            M = f / 2,
            S = d / 2,
            E = m + 1,
            T = v + 1,
            A = 0,
            L = 0,
            P = new Ye();
          for (x = 0; x < T; x++) {
            var R = x * w - M;
            for (y = 0; y < E; y++) {
              var C = y * b - _;
              (P[t] = C * r),
                (P[e] = R * i),
                (P[n] = S),
                c.push(P.x, P.y, P.z),
                (P[t] = 0),
                (P[e] = 0),
                (P[n] = d > 0 ? 1 : -1),
                u.push(P.x, P.y, P.z),
                l.push(y / m),
                l.push(1 - x / v),
                (A += 1);
            }
          }
          for (x = 0; x < v; x++)
            for (y = 0; y < m; y++) {
              var O = h + y + E * x,
                I = h + y + E * (x + 1),
                N = h + (y + 1) + E * (x + 1),
                D = h + (y + 1) + E * x;
              s.push(O, I, D), s.push(I, N, D), (L += 6);
            }
          a.addGroup(p, L, g), (p += L), (h += A);
        }
        f("z", "y", "x", -1, -1, n, e, t, o, i, 0),
          f("z", "y", "x", 1, -1, n, e, -t, o, i, 1),
          f("x", "z", "y", 1, 1, t, n, e, r, o, 2),
          f("x", "z", "y", 1, -1, t, n, -e, r, o, 3),
          f("x", "y", "z", 1, -1, t, e, n, r, i, 4),
          f("x", "y", "z", -1, -1, t, e, -n, r, i, 5),
          this.setIndex(s),
          this.addAttribute("position", new Or(c, 3)),
          this.addAttribute("normal", new Or(u, 3)),
          this.addAttribute("uv", new Or(l, 2));
      }
    }
    function vi(t) {
      var e = {};
      for (var n in t)
        for (var r in ((e[n] = {}), t[n])) {
          var i = t[n][r];
          i &&
          (i.isColor ||
            i.isMatrix3 ||
            i.isMatrix4 ||
            i.isVector2 ||
            i.isVector3 ||
            i.isVector4 ||
            i.isTexture)
            ? (e[n][r] = i.clone())
            : Array.isArray(i)
            ? (e[n][r] = i.slice())
            : (e[n][r] = i);
        }
      return e;
    }
    function gi(t) {
      for (var e = {}, n = 0; n < t.length; n++) {
        var r = vi(t[n]);
        for (var i in r) e[i] = r[i];
      }
      return e;
    }
    var yi =
        "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
      xi = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    function bi(t) {
      _r.call(this),
        (this.type = "ShaderMaterial"),
        (this.defines = {}),
        (this.uniforms = {}),
        (this.vertexShader = yi),
        (this.fragmentShader = xi),
        (this.linewidth = 1),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        (this.lights = !1),
        (this.clipping = !1),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        (this.extensions = {
          derivatives: !1,
          fragDepth: !1,
          drawBuffers: !1,
          shaderTextureLOD: !1,
        }),
        (this.defaultAttributeValues = {
          color: [1, 1, 1],
          uv: [0, 0],
          uv2: [0, 0],
        }),
        (this.index0AttributeName = void 0),
        (this.uniformsNeedUpdate = !1),
        void 0 !== t &&
          (void 0 !== t.attributes &&
            console.error(
              "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
            ),
          this.setValues(t));
    }
    function wi() {
      Rn.call(this),
        (this.type = "Camera"),
        (this.matrixWorldInverse = new pn()),
        (this.projectionMatrix = new pn()),
        (this.projectionMatrixInverse = new pn());
    }
    function _i(t, e, n, r) {
      wi.call(this),
        (this.type = "PerspectiveCamera"),
        (this.fov = void 0 !== t ? t : 50),
        (this.zoom = 1),
        (this.near = void 0 !== n ? n : 0.1),
        (this.far = void 0 !== r ? r : 2e3),
        (this.focus = 10),
        (this.aspect = void 0 !== e ? e : 1),
        (this.view = null),
        (this.filmGauge = 35),
        (this.filmOffset = 0),
        this.updateProjectionMatrix();
    }
    (bi.prototype = Object.create(_r.prototype)),
      (bi.prototype.constructor = bi),
      (bi.prototype.isShaderMaterial = !0),
      (bi.prototype.copy = function (t) {
        return (
          _r.prototype.copy.call(this, t),
          (this.fragmentShader = t.fragmentShader),
          (this.vertexShader = t.vertexShader),
          (this.uniforms = vi(t.uniforms)),
          (this.defines = Object.assign({}, t.defines)),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.lights = t.lights),
          (this.clipping = t.clipping),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          (this.extensions = t.extensions),
          this
        );
      }),
      (bi.prototype.toJSON = function (t) {
        var e = _r.prototype.toJSON.call(this, t);
        for (var n in ((e.uniforms = {}), this.uniforms)) {
          var r = this.uniforms[n].value;
          r && r.isTexture
            ? (e.uniforms[n] = { type: "t", value: r.toJSON(t).uuid })
            : r && r.isColor
            ? (e.uniforms[n] = { type: "c", value: r.getHex() })
            : r && r.isVector2
            ? (e.uniforms[n] = { type: "v2", value: r.toArray() })
            : r && r.isVector3
            ? (e.uniforms[n] = { type: "v3", value: r.toArray() })
            : r && r.isVector4
            ? (e.uniforms[n] = { type: "v4", value: r.toArray() })
            : r && r.isMatrix3
            ? (e.uniforms[n] = { type: "m3", value: r.toArray() })
            : r && r.isMatrix4
            ? (e.uniforms[n] = { type: "m4", value: r.toArray() })
            : (e.uniforms[n] = { value: r });
        }
        Object.keys(this.defines).length > 0 && (e.defines = this.defines),
          (e.vertexShader = this.vertexShader),
          (e.fragmentShader = this.fragmentShader);
        var i = {};
        for (var o in this.extensions) !0 === this.extensions[o] && (i[o] = !0);
        return Object.keys(i).length > 0 && (e.extensions = i), e;
      }),
      (wi.prototype = Object.assign(Object.create(Rn.prototype), {
        constructor: wi,
        isCamera: !0,
        copy: function (t, e) {
          return (
            Rn.prototype.copy.call(this, t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
            this
          );
        },
        getWorldDirection: function (t) {
          void 0 === t &&
            (console.warn(
              "THREE.Camera: .getWorldDirection() target is now required"
            ),
            (t = new Ye())),
            this.updateMatrixWorld(!0);
          var e = this.matrixWorld.elements;
          return t.set(-e[8], -e[9], -e[10]).normalize();
        },
        updateMatrixWorld: function (t) {
          Rn.prototype.updateMatrixWorld.call(this, t),
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
      })),
      (_i.prototype = Object.assign(Object.create(wi.prototype), {
        constructor: _i,
        isPerspectiveCamera: !0,
        copy: function (t, e) {
          return (
            wi.prototype.copy.call(this, t, e),
            (this.fov = t.fov),
            (this.zoom = t.zoom),
            (this.near = t.near),
            (this.far = t.far),
            (this.focus = t.focus),
            (this.aspect = t.aspect),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            (this.filmGauge = t.filmGauge),
            (this.filmOffset = t.filmOffset),
            this
          );
        },
        setFocalLength: function (t) {
          var e = (0.5 * this.getFilmHeight()) / t;
          (this.fov = 2 * He.RAD2DEG * Math.atan(e)),
            this.updateProjectionMatrix();
        },
        getFocalLength: function () {
          var t = Math.tan(0.5 * He.DEG2RAD * this.fov);
          return (0.5 * this.getFilmHeight()) / t;
        },
        getEffectiveFOV: function () {
          return (
            2 *
            He.RAD2DEG *
            Math.atan(Math.tan(0.5 * He.DEG2RAD * this.fov) / this.zoom)
          );
        },
        getFilmWidth: function () {
          return this.filmGauge * Math.min(this.aspect, 1);
        },
        getFilmHeight: function () {
          return this.filmGauge / Math.max(this.aspect, 1);
        },
        setViewOffset: function (t, e, n, r, i, o) {
          (this.aspect = t / e),
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = n),
            (this.view.offsetY = r),
            (this.view.width = i),
            (this.view.height = o),
            this.updateProjectionMatrix();
        },
        clearViewOffset: function () {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function () {
          var t = this.near,
            e = (t * Math.tan(0.5 * He.DEG2RAD * this.fov)) / this.zoom,
            n = 2 * e,
            r = this.aspect * n,
            i = -0.5 * r,
            o = this.view;
          if (null !== this.view && this.view.enabled) {
            var a = o.fullWidth,
              s = o.fullHeight;
            (i += (o.offsetX * r) / a),
              (e -= (o.offsetY * n) / s),
              (r *= o.width / a),
              (n *= o.height / s);
          }
          var c = this.filmOffset;
          0 !== c && (i += (t * c) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              i,
              i + r,
              e,
              e - n,
              t,
              this.far
            ),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix);
        },
        toJSON: function (t) {
          var e = Rn.prototype.toJSON.call(this, t);
          return (
            (e.object.fov = this.fov),
            (e.object.zoom = this.zoom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            (e.object.focus = this.focus),
            (e.object.aspect = this.aspect),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            (e.object.filmGauge = this.filmGauge),
            (e.object.filmOffset = this.filmOffset),
            e
          );
        },
      }));
    var Mi = 90,
      Si = 1;
    function Ei(t, e, n, r) {
      Rn.call(this), (this.type = "CubeCamera");
      var i = new _i(Mi, Si, t, e);
      i.up.set(0, -1, 0), i.lookAt(new Ye(1, 0, 0)), this.add(i);
      var o = new _i(Mi, Si, t, e);
      o.up.set(0, -1, 0), o.lookAt(new Ye(-1, 0, 0)), this.add(o);
      var a = new _i(Mi, Si, t, e);
      a.up.set(0, 0, 1), a.lookAt(new Ye(0, 1, 0)), this.add(a);
      var s = new _i(Mi, Si, t, e);
      s.up.set(0, 0, -1), s.lookAt(new Ye(0, -1, 0)), this.add(s);
      var c = new _i(Mi, Si, t, e);
      c.up.set(0, -1, 0), c.lookAt(new Ye(0, 0, 1)), this.add(c);
      var u = new _i(Mi, Si, t, e);
      u.up.set(0, -1, 0),
        u.lookAt(new Ye(0, 0, -1)),
        this.add(u),
        (r = r || { format: Wt, magFilter: Pt, minFilter: Pt }),
        (this.renderTarget = new Ti(n, n, r)),
        (this.renderTarget.texture.name = "CubeCamera"),
        (this.update = function (t, e) {
          null === this.parent && this.updateMatrixWorld();
          var n = t.getRenderTarget(),
            r = this.renderTarget,
            l = r.texture.generateMipmaps;
          (r.texture.generateMipmaps = !1),
            t.setRenderTarget(r, 0),
            t.render(e, i),
            t.setRenderTarget(r, 1),
            t.render(e, o),
            t.setRenderTarget(r, 2),
            t.render(e, a),
            t.setRenderTarget(r, 3),
            t.render(e, s),
            t.setRenderTarget(r, 4),
            t.render(e, c),
            (r.texture.generateMipmaps = l),
            t.setRenderTarget(r, 5),
            t.render(e, u),
            t.setRenderTarget(n);
        }),
        (this.clear = function (t, e, n, r) {
          for (
            var i = t.getRenderTarget(), o = this.renderTarget, a = 0;
            a < 6;
            a++
          )
            t.setRenderTarget(o, a), t.clear(e, n, r);
          t.setRenderTarget(i);
        });
    }
    function Ti(t, e, n) {
      nn.call(this, t, e, n);
    }
    function Ai(t, e, n, r, i, o, a, s, c, u, l, h) {
      tn.call(this, null, o, a, s, c, u, r, i, l, h),
        (this.image = { data: t || null, width: e || 1, height: n || 1 }),
        (this.magFilter = void 0 !== c ? c : Tt),
        (this.minFilter = void 0 !== u ? u : Tt),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1),
        (this.needsUpdate = !0);
    }
    (Ei.prototype = Object.create(Rn.prototype)),
      (Ei.prototype.constructor = Ei),
      (Ti.prototype = Object.create(nn.prototype)),
      (Ti.prototype.constructor = Ti),
      (Ti.prototype.isWebGLRenderTargetCube = !0),
      (Ti.prototype.fromEquirectangularTexture = function (t, e) {
        (this.texture.type = e.type),
          (this.texture.format = e.format),
          (this.texture.encoding = e.encoding);
        var n = new Cn(),
          r = {
            uniforms: { tEquirect: { value: null } },
            vertexShader: [
              "varying vec3 vWorldDirection;",
              "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {",
              "\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );",
              "}",
              "void main() {",
              "\tvWorldDirection = transformDirection( position, modelMatrix );",
              "\t#include <begin_vertex>",
              "\t#include <project_vertex>",
              "}",
            ].join("\n"),
            fragmentShader: [
              "uniform sampler2D tEquirect;",
              "varying vec3 vWorldDirection;",
              "#define RECIPROCAL_PI 0.31830988618",
              "#define RECIPROCAL_PI2 0.15915494",
              "void main() {",
              "\tvec3 direction = normalize( vWorldDirection );",
              "\tvec2 sampleUV;",
              "\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;",
              "\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
              "\tgl_FragColor = texture2D( tEquirect, sampleUV );",
              "}",
            ].join("\n"),
          },
          i = new bi({
            type: "CubemapFromEquirect",
            uniforms: vi(r.uniforms),
            vertexShader: r.vertexShader,
            fragmentShader: r.fragmentShader,
            side: T,
            blending: C,
          });
        i.uniforms.tEquirect.value = e;
        var o = new si(new mi(5, 5, 5), i);
        n.add(o);
        var a = new Ei(1, 10, 1);
        return (
          (a.renderTarget = this),
          (a.renderTarget.texture.name = "CubeCameraTexture"),
          a.update(t, n),
          o.geometry.dispose(),
          o.material.dispose(),
          this
        );
      }),
      (Ai.prototype = Object.create(tn.prototype)),
      (Ai.prototype.constructor = Ai),
      (Ai.prototype.isDataTexture = !0);
    var Li = new Ye(),
      Pi = new Ye(),
      Ri = new Qe();
    function Ci(t, e) {
      (this.normal = void 0 !== t ? t : new Ye(1, 0, 0)),
        (this.constant = void 0 !== e ? e : 0);
    }
    Object.assign(Ci.prototype, {
      isPlane: !0,
      set: function (t, e) {
        return this.normal.copy(t), (this.constant = e), this;
      },
      setComponents: function (t, e, n, r) {
        return this.normal.set(t, e, n), (this.constant = r), this;
      },
      setFromNormalAndCoplanarPoint: function (t, e) {
        return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
      },
      setFromCoplanarPoints: function (t, e, n) {
        var r = Li.subVectors(n, e).cross(Pi.subVectors(t, e)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, t), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.normal.copy(t.normal), (this.constant = t.constant), this;
      },
      normalize: function () {
        var t = 1 / this.normal.length();
        return this.normal.multiplyScalar(t), (this.constant *= t), this;
      },
      negate: function () {
        return (this.constant *= -1), this.normal.negate(), this;
      },
      distanceToPoint: function (t) {
        return this.normal.dot(t) + this.constant;
      },
      distanceToSphere: function (t) {
        return this.distanceToPoint(t.center) - t.radius;
      },
      projectPoint: function (t, e) {
        return (
          void 0 === e &&
            (console.warn(
              "THREE.Plane: .projectPoint() target is now required"
            ),
            (e = new Ye())),
          e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        );
      },
      intersectLine: function (t, e) {
        void 0 === e &&
          (console.warn("THREE.Plane: .intersectLine() target is now required"),
          (e = new Ye()));
        var n = t.delta(Li),
          r = this.normal.dot(n);
        if (0 === r)
          return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
        var i = -(t.start.dot(this.normal) + this.constant) / r;
        return i < 0 || i > 1
          ? void 0
          : e.copy(n).multiplyScalar(i).add(t.start);
      },
      intersectsLine: function (t) {
        var e = this.distanceToPoint(t.start),
          n = this.distanceToPoint(t.end);
        return (e < 0 && n > 0) || (n < 0 && e > 0);
      },
      intersectsBox: function (t) {
        return t.intersectsPlane(this);
      },
      intersectsSphere: function (t) {
        return t.intersectsPlane(this);
      },
      coplanarPoint: function (t) {
        return (
          void 0 === t &&
            (console.warn(
              "THREE.Plane: .coplanarPoint() target is now required"
            ),
            (t = new Ye())),
          t.copy(this.normal).multiplyScalar(-this.constant)
        );
      },
      applyMatrix4: function (t, e) {
        var n = e || Ri.getNormalMatrix(t),
          r = this.coplanarPoint(Li).applyMatrix4(t),
          i = this.normal.applyMatrix3(n).normalize();
        return (this.constant = -r.dot(i)), this;
      },
      translate: function (t) {
        return (this.constant -= t.dot(this.normal)), this;
      },
      equals: function (t) {
        return t.normal.equals(this.normal) && t.constant === this.constant;
      },
    });
    var Oi = new Xn(),
      Ii = new Ye();
    function Ni(t, e, n, r, i, o) {
      this.planes = [
        void 0 !== t ? t : new Ci(),
        void 0 !== e ? e : new Ci(),
        void 0 !== n ? n : new Ci(),
        void 0 !== r ? r : new Ci(),
        void 0 !== i ? i : new Ci(),
        void 0 !== o ? o : new Ci(),
      ];
    }
    Object.assign(Ni.prototype, {
      set: function (t, e, n, r, i, o) {
        var a = this.planes;
        return (
          a[0].copy(t),
          a[1].copy(e),
          a[2].copy(n),
          a[3].copy(r),
          a[4].copy(i),
          a[5].copy(o),
          this
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        for (var e = this.planes, n = 0; n < 6; n++) e[n].copy(t.planes[n]);
        return this;
      },
      setFromMatrix: function (t) {
        var e = this.planes,
          n = t.elements,
          r = n[0],
          i = n[1],
          o = n[2],
          a = n[3],
          s = n[4],
          c = n[5],
          u = n[6],
          l = n[7],
          h = n[8],
          p = n[9],
          f = n[10],
          d = n[11],
          m = n[12],
          v = n[13],
          g = n[14],
          y = n[15];
        return (
          e[0].setComponents(a - r, l - s, d - h, y - m).normalize(),
          e[1].setComponents(a + r, l + s, d + h, y + m).normalize(),
          e[2].setComponents(a + i, l + c, d + p, y + v).normalize(),
          e[3].setComponents(a - i, l - c, d - p, y - v).normalize(),
          e[4].setComponents(a - o, l - u, d - f, y - g).normalize(),
          e[5].setComponents(a + o, l + u, d + f, y + g).normalize(),
          this
        );
      },
      intersectsObject: function (t) {
        var e = t.geometry;
        return (
          null === e.boundingSphere && e.computeBoundingSphere(),
          Oi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
          this.intersectsSphere(Oi)
        );
      },
      intersectsSprite: function (t) {
        return (
          Oi.center.set(0, 0, 0),
          (Oi.radius = 0.7071067811865476),
          Oi.applyMatrix4(t.matrixWorld),
          this.intersectsSphere(Oi)
        );
      },
      intersectsSphere: function (t) {
        for (
          var e = this.planes, n = t.center, r = -t.radius, i = 0;
          i < 6;
          i++
        ) {
          if (e[i].distanceToPoint(n) < r) return !1;
        }
        return !0;
      },
      intersectsBox: function (t) {
        for (var e = this.planes, n = 0; n < 6; n++) {
          var r = e[n];
          if (
            ((Ii.x = r.normal.x > 0 ? t.max.x : t.min.x),
            (Ii.y = r.normal.y > 0 ? t.max.y : t.min.y),
            (Ii.z = r.normal.z > 0 ? t.max.z : t.min.z),
            r.distanceToPoint(Ii) < 0)
          )
            return !1;
        }
        return !0;
      },
      containsPoint: function (t) {
        for (var e = this.planes, n = 0; n < 6; n++)
          if (e[n].distanceToPoint(t) < 0) return !1;
        return !0;
      },
    });
    var Di = {
        alphamap_fragment:
          "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment:
          "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment:
          "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
        aomap_fragment:
          "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
        aomap_pars_fragment:
          "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex:
          "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs:
          "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
        bumpmap_pars_fragment:
          "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment:
          "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment:
          "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex:
          "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
        clipping_planes_vertex:
          "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
        color_fragment:
          "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        common:
          "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}",
        cube_uv_reflection_fragment:
          "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
        defaultnormal_vertex:
          "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\ttransformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex:
          "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex:
          "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment:
          "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment:
          "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment:
          "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment:
          "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment:
          "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_common_pars_fragment:
          "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
        envmap_pars_fragment:
          "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex:
          "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment:
          "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
        envmap_vertex:
          "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
        fog_fragment:
          "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment:
          "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment:
          "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
        lightmap_fragment:
          "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
        lightmap_pars_fragment:
          "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex:
          "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
        lights_pars_begin:
          "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
        lights_phong_fragment:
          "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment:
          "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment:
          "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = clamp( clearcoatRoughness, 0.04, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
        lights_physical_pars_fragment:
          "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin:
          "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps:
          "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
        lights_fragment_end:
          "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment:
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 1.0 ? log2( vFragDepth ) * logDepthBufFC * 0.5 : gl_FragCoord.z;\n#endif",
        logdepthbuf_pars_fragment:
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex:
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex:
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
        map_fragment:
          "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment:
          "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
        map_particle_pars_fragment:
          "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
        metalnessmap_fragment:
          "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment:
          "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex:
          "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
        morphtarget_pars_vertex:
          "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex:
          "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
        normal_fragment_begin:
          "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
        normal_fragment_maps:
          "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, normalScale, normalMap );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
        normalmap_pars_fragment:
          "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 normalScale, in sampler2D normalMap ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy *= normalScale;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tbool frontFacing = dot( cross( S, T ), N ) > 0.0;\n\t\t\tmapN.xy *= ( float( frontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
        clearcoat_normal_fragment_begin:
          "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
        clearcoat_normal_fragment_maps:
          "#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = clearcoatNormalScale * mapN.xy;\n\t\tclearcoatNormal = normalize( vTBN * mapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatNormalScale, clearcoatNormalMap );\n\t#endif\n#endif",
        clearcoat_normalmap_pars_fragment:
          "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
        packing:
          "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 encodeHalfRGBA ( vec2 v ) {\n\tvec4 encoded = vec4( 0.0 );\n\tconst vec2 offset = vec2( 1.0 / 255.0, 0.0 );\n\tencoded.xy = vec2( v.x, fract( v.x * 255.0 ) );\n\tencoded.xy = encoded.xy - ( encoded.yy * offset );\n\tencoded.zw = vec2( v.y, fract( v.y * 255.0 ) );\n\tencoded.zw = encoded.zw - ( encoded.ww * offset );\n\treturn encoded;\n}\nvec2 decodeHalfRGBA( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment:
          "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex:
          "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment:
          "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment:
          "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment:
          "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment:
          "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn decodeHalfRGBA( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        shadowmap_vertex:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
        shadowmask_pars_fragment:
          "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex:
          "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex:
          "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex:
          "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex:
          "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment:
          "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment:
          "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment:
          "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment:
          "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
        uv_pars_fragment: "#ifdef USE_UV\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex:
          "#ifdef USE_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex:
          "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
        uv2_vertex:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
        worldpos_vertex:
          "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
        background_frag:
          "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        background_vert:
          "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        cube_frag:
          "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert:
          "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        depth_frag:
          "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
        depth_vert:
          "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
        distanceRGBA_frag:
          "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        distanceRGBA_vert:
          "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        equirect_frag:
          "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        equirect_vert:
          "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        linedashed_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        linedashed_vert:
          "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        meshbasic_vert:
          "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag:
          "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert:
          "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshmatcap_frag:
          "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        meshmatcap_vert:
          "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshphong_frag:
          "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphong_vert:
          "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphysical_frag:
          "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert:
          "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        normal_frag:
          "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        normal_vert:
          "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        points_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        points_vert:
          "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag:
          "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
        shadow_vert:
          "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert:
          "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      },
      zi = {
        common: {
          diffuse: { value: new vr(15658734) },
          opacity: { value: 1 },
          map: { value: null },
          uvTransform: { value: new Qe() },
          alphaMap: { value: null },
        },
        specularmap: { specularMap: { value: null } },
        envmap: {
          envMap: { value: null },
          flipEnvMap: { value: -1 },
          reflectivity: { value: 1 },
          refractionRatio: { value: 0.98 },
          maxMipLevel: { value: 0 },
        },
        aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
        lightmap: {
          lightMap: { value: null },
          lightMapIntensity: { value: 1 },
        },
        emissivemap: { emissiveMap: { value: null } },
        bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
        normalmap: {
          normalMap: { value: null },
          normalScale: { value: new ke(1, 1) },
        },
        displacementmap: {
          displacementMap: { value: null },
          displacementScale: { value: 1 },
          displacementBias: { value: 0 },
        },
        roughnessmap: { roughnessMap: { value: null } },
        metalnessmap: { metalnessMap: { value: null } },
        gradientmap: { gradientMap: { value: null } },
        fog: {
          fogDensity: { value: 25e-5 },
          fogNear: { value: 1 },
          fogFar: { value: 2e3 },
          fogColor: { value: new vr(16777215) },
        },
        lights: {
          ambientLightColor: { value: [] },
          lightProbe: { value: [] },
          directionalLights: {
            value: [],
            properties: {
              direction: {},
              color: {},
              shadow: {},
              shadowBias: {},
              shadowRadius: {},
              shadowMapSize: {},
            },
          },
          directionalShadowMap: { value: [] },
          directionalShadowMatrix: { value: [] },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {},
              shadow: {},
              shadowBias: {},
              shadowRadius: {},
              shadowMapSize: {},
            },
          },
          spotShadowMap: { value: [] },
          spotShadowMatrix: { value: [] },
          pointLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              decay: {},
              distance: {},
              shadow: {},
              shadowBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {},
            },
          },
          pointShadowMap: { value: [] },
          pointShadowMatrix: { value: [] },
          hemisphereLights: {
            value: [],
            properties: { direction: {}, skyColor: {}, groundColor: {} },
          },
          rectAreaLights: {
            value: [],
            properties: { color: {}, position: {}, width: {}, height: {} },
          },
        },
        points: {
          diffuse: { value: new vr(15658734) },
          opacity: { value: 1 },
          size: { value: 1 },
          scale: { value: 1 },
          map: { value: null },
          uvTransform: { value: new Qe() },
        },
        sprite: {
          diffuse: { value: new vr(15658734) },
          opacity: { value: 1 },
          center: { value: new ke(0.5, 0.5) },
          rotation: { value: 0 },
          map: { value: null },
          uvTransform: { value: new Qe() },
        },
      },
      Fi = {
        basic: {
          uniforms: gi([
            zi.common,
            zi.specularmap,
            zi.envmap,
            zi.aomap,
            zi.lightmap,
            zi.fog,
          ]),
          vertexShader: Di.meshbasic_vert,
          fragmentShader: Di.meshbasic_frag,
        },
        lambert: {
          uniforms: gi([
            zi.common,
            zi.specularmap,
            zi.envmap,
            zi.aomap,
            zi.lightmap,
            zi.emissivemap,
            zi.fog,
            zi.lights,
            { emissive: { value: new vr(0) } },
          ]),
          vertexShader: Di.meshlambert_vert,
          fragmentShader: Di.meshlambert_frag,
        },
        phong: {
          uniforms: gi([
            zi.common,
            zi.specularmap,
            zi.envmap,
            zi.aomap,
            zi.lightmap,
            zi.emissivemap,
            zi.bumpmap,
            zi.normalmap,
            zi.displacementmap,
            zi.gradientmap,
            zi.fog,
            zi.lights,
            {
              emissive: { value: new vr(0) },
              specular: { value: new vr(1118481) },
              shininess: { value: 30 },
            },
          ]),
          vertexShader: Di.meshphong_vert,
          fragmentShader: Di.meshphong_frag,
        },
        standard: {
          uniforms: gi([
            zi.common,
            zi.envmap,
            zi.aomap,
            zi.lightmap,
            zi.emissivemap,
            zi.bumpmap,
            zi.normalmap,
            zi.displacementmap,
            zi.roughnessmap,
            zi.metalnessmap,
            zi.fog,
            zi.lights,
            {
              emissive: { value: new vr(0) },
              roughness: { value: 0.5 },
              metalness: { value: 0.5 },
              envMapIntensity: { value: 1 },
            },
          ]),
          vertexShader: Di.meshphysical_vert,
          fragmentShader: Di.meshphysical_frag,
        },
        matcap: {
          uniforms: gi([
            zi.common,
            zi.bumpmap,
            zi.normalmap,
            zi.displacementmap,
            zi.fog,
            { matcap: { value: null } },
          ]),
          vertexShader: Di.meshmatcap_vert,
          fragmentShader: Di.meshmatcap_frag,
        },
        points: {
          uniforms: gi([zi.points, zi.fog]),
          vertexShader: Di.points_vert,
          fragmentShader: Di.points_frag,
        },
        dashed: {
          uniforms: gi([
            zi.common,
            zi.fog,
            {
              scale: { value: 1 },
              dashSize: { value: 1 },
              totalSize: { value: 2 },
            },
          ]),
          vertexShader: Di.linedashed_vert,
          fragmentShader: Di.linedashed_frag,
        },
        depth: {
          uniforms: gi([zi.common, zi.displacementmap]),
          vertexShader: Di.depth_vert,
          fragmentShader: Di.depth_frag,
        },
        normal: {
          uniforms: gi([
            zi.common,
            zi.bumpmap,
            zi.normalmap,
            zi.displacementmap,
            { opacity: { value: 1 } },
          ]),
          vertexShader: Di.normal_vert,
          fragmentShader: Di.normal_frag,
        },
        sprite: {
          uniforms: gi([zi.sprite, zi.fog]),
          vertexShader: Di.sprite_vert,
          fragmentShader: Di.sprite_frag,
        },
        background: {
          uniforms: { uvTransform: { value: new Qe() }, t2D: { value: null } },
          vertexShader: Di.background_vert,
          fragmentShader: Di.background_frag,
        },
        cube: {
          uniforms: {
            tCube: { value: null },
            tFlip: { value: -1 },
            opacity: { value: 1 },
          },
          vertexShader: Di.cube_vert,
          fragmentShader: Di.cube_frag,
        },
        equirect: {
          uniforms: { tEquirect: { value: null } },
          vertexShader: Di.equirect_vert,
          fragmentShader: Di.equirect_frag,
        },
        distanceRGBA: {
          uniforms: gi([
            zi.common,
            zi.displacementmap,
            {
              referencePosition: { value: new Ye() },
              nearDistance: { value: 1 },
              farDistance: { value: 1e3 },
            },
          ]),
          vertexShader: Di.distanceRGBA_vert,
          fragmentShader: Di.distanceRGBA_frag,
        },
        shadow: {
          uniforms: gi([
            zi.lights,
            zi.fog,
            { color: { value: new vr(0) }, opacity: { value: 1 } },
          ]),
          vertexShader: Di.shadow_vert,
          fragmentShader: Di.shadow_frag,
        },
      };
    function Ui() {
      var t = null,
        e = !1,
        n = null;
      function r(i, o) {
        !1 !== e && (n(i, o), t.requestAnimationFrame(r));
      }
      return {
        start: function () {
          !0 !== e && null !== n && (t.requestAnimationFrame(r), (e = !0));
        },
        stop: function () {
          e = !1;
        },
        setAnimationLoop: function (t) {
          n = t;
        },
        setContext: function (e) {
          t = e;
        },
      };
    }
    function Bi(t) {
      var e = new WeakMap();
      return {
        get: function (t) {
          return t.isInterleavedBufferAttribute && (t = t.data), e.get(t);
        },
        remove: function (n) {
          n.isInterleavedBufferAttribute && (n = n.data);
          var r = e.get(n);
          r && (t.deleteBuffer(r.buffer), e.delete(n));
        },
        update: function (n, r) {
          n.isInterleavedBufferAttribute && (n = n.data);
          var i = e.get(n);
          void 0 === i
            ? e.set(
                n,
                (function (e, n) {
                  var r = e.array,
                    i = e.dynamic ? 35048 : 35044,
                    o = t.createBuffer();
                  t.bindBuffer(n, o),
                    t.bufferData(n, r, i),
                    e.onUploadCallback();
                  var a = 5126;
                  return (
                    r instanceof Float32Array
                      ? (a = 5126)
                      : r instanceof Float64Array
                      ? console.warn(
                          "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                        )
                      : r instanceof Uint16Array
                      ? (a = 5123)
                      : r instanceof Int16Array
                      ? (a = 5122)
                      : r instanceof Uint32Array
                      ? (a = 5125)
                      : r instanceof Int32Array
                      ? (a = 5124)
                      : r instanceof Int8Array
                      ? (a = 5120)
                      : r instanceof Uint8Array && (a = 5121),
                    {
                      buffer: o,
                      type: a,
                      bytesPerElement: r.BYTES_PER_ELEMENT,
                      version: e.version,
                    }
                  );
                })(n, r)
              )
            : i.version < n.version &&
              (!(function (e, n, r) {
                var i = n.array,
                  o = n.updateRange;
                t.bindBuffer(r, e),
                  !1 === n.dynamic
                    ? t.bufferData(r, i, 35044)
                    : -1 === o.count
                    ? t.bufferSubData(r, 0, i)
                    : 0 === o.count
                    ? console.error(
                        "THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."
                      )
                    : (t.bufferSubData(
                        r,
                        o.offset * i.BYTES_PER_ELEMENT,
                        i.subarray(o.offset, o.offset + o.count)
                      ),
                      (o.count = -1));
              })(i.buffer, n, r),
              (i.version = n.version));
        },
      };
    }
    function Gi(t, e, n, r) {
      di.call(this),
        (this.type = "PlaneGeometry"),
        (this.parameters = {
          width: t,
          height: e,
          widthSegments: n,
          heightSegments: r,
        }),
        this.fromBufferGeometry(new ji(t, e, n, r)),
        this.mergeVertices();
    }
    function ji(t, e, n, r) {
      Hr.call(this),
        (this.type = "PlaneBufferGeometry"),
        (this.parameters = {
          width: t,
          height: e,
          widthSegments: n,
          heightSegments: r,
        });
      var i,
        o,
        a = (t = t || 1) / 2,
        s = (e = e || 1) / 2,
        c = Math.floor(n) || 1,
        u = Math.floor(r) || 1,
        l = c + 1,
        h = u + 1,
        p = t / c,
        f = e / u,
        d = [],
        m = [],
        v = [],
        g = [];
      for (o = 0; o < h; o++) {
        var y = o * f - s;
        for (i = 0; i < l; i++) {
          var x = i * p - a;
          m.push(x, -y, 0), v.push(0, 0, 1), g.push(i / c), g.push(1 - o / u);
        }
      }
      for (o = 0; o < u; o++)
        for (i = 0; i < c; i++) {
          var b = i + l * o,
            w = i + l * (o + 1),
            _ = i + 1 + l * (o + 1),
            M = i + 1 + l * o;
          d.push(b, w, M), d.push(w, _, M);
        }
      this.setIndex(d),
        this.addAttribute("position", new Or(m, 3)),
        this.addAttribute("normal", new Or(v, 3)),
        this.addAttribute("uv", new Or(g, 2));
    }
    function Vi(t, e, n, r) {
      var i,
        o,
        a = new vr(0),
        s = 0,
        c = null,
        u = 0;
      function l(t, n) {
        e.buffers.color.setClear(t.r, t.g, t.b, n, r);
      }
      return {
        getClearColor: function () {
          return a;
        },
        setClearColor: function (t, e) {
          a.set(t), l(a, (s = void 0 !== e ? e : 1));
        },
        getClearAlpha: function () {
          return s;
        },
        setClearAlpha: function (t) {
          l(a, (s = t));
        },
        render: function (e, r, h, p) {
          var f = r.background,
            d = t.vr,
            m = d.getSession && d.getSession();
          if (
            (m && "additive" === m.environmentBlendMode && (f = null),
            null === f
              ? (l(a, s), (c = null), (u = 0))
              : f && f.isColor && (l(f, 1), (p = !0), (c = null), (u = 0)),
            (t.autoClear || p) &&
              t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
            f && (f.isCubeTexture || f.isWebGLRenderTargetCube))
          ) {
            void 0 === o &&
              ((o = new si(
                new mi(1, 1, 1),
                new bi({
                  type: "BackgroundCubeMaterial",
                  uniforms: vi(Fi.cube.uniforms),
                  vertexShader: Fi.cube.vertexShader,
                  fragmentShader: Fi.cube.fragmentShader,
                  side: T,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1,
                })
              )).geometry.removeAttribute("normal"),
              o.geometry.removeAttribute("uv"),
              (o.onBeforeRender = function (t, e, n) {
                this.matrixWorld.copyPosition(n.matrixWorld);
              }),
              Object.defineProperty(o.material, "map", {
                get: function () {
                  return this.uniforms.tCube.value;
                },
              }),
              n.update(o));
            var v = f.isWebGLRenderTargetCube ? f.texture : f;
            (o.material.uniforms.tCube.value = v),
              (o.material.uniforms.tFlip.value = f.isWebGLRenderTargetCube
                ? 1
                : -1),
              (c === f && u === v.version) ||
                ((o.material.needsUpdate = !0), (c = f), (u = v.version)),
              e.unshift(o, o.geometry, o.material, 0, 0, null);
          } else
            f &&
              f.isTexture &&
              (void 0 === i &&
                ((i = new si(
                  new ji(2, 2),
                  new bi({
                    type: "BackgroundMaterial",
                    uniforms: vi(Fi.background.uniforms),
                    vertexShader: Fi.background.vertexShader,
                    fragmentShader: Fi.background.fragmentShader,
                    side: E,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                  })
                )).geometry.removeAttribute("normal"),
                Object.defineProperty(i.material, "map", {
                  get: function () {
                    return this.uniforms.t2D.value;
                  },
                }),
                n.update(i)),
              (i.material.uniforms.t2D.value = f),
              !0 === f.matrixAutoUpdate && f.updateMatrix(),
              i.material.uniforms.uvTransform.value.copy(f.matrix),
              (c === f && u === f.version) ||
                ((i.material.needsUpdate = !0), (c = f), (u = f.version)),
              e.unshift(i, i.geometry, i.material, 0, 0, null));
        },
      };
    }
    function Hi(t, e, n, r) {
      var i;
      (this.setMode = function (t) {
        i = t;
      }),
        (this.render = function (e, r) {
          t.drawArrays(i, e, r), n.update(r, i);
        }),
        (this.renderInstances = function (o, a, s, c) {
          if (0 !== c) {
            var u, l;
            if (r.isWebGL2) (u = t), (l = "drawArraysInstanced");
            else if (
              ((l = "drawArraysInstancedANGLE"),
              null === (u = e.get("ANGLE_instanced_arrays")))
            )
              return void console.error(
                "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
              );
            u[l](i, a, s, c), n.update(s, i, c);
          }
        });
    }
    function ki(t, e, n) {
      var r;
      function i(e) {
        if ("highp" === e) {
          if (
            t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
            t.getShaderPrecisionFormat(35632, 36338).precision > 0
          )
            return "highp";
          e = "mediump";
        }
        return "mediump" === e &&
          t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
          t.getShaderPrecisionFormat(35632, 36337).precision > 0
          ? "mediump"
          : "lowp";
      }
      var o =
          "undefined" != typeof WebGL2RenderingContext &&
          t instanceof WebGL2RenderingContext,
        a = void 0 !== n.precision ? n.precision : "highp",
        s = i(a);
      s !== a &&
        (console.warn(
          "THREE.WebGLRenderer:",
          a,
          "not supported, using",
          s,
          "instead."
        ),
        (a = s));
      var c = !0 === n.logarithmicDepthBuffer,
        u = t.getParameter(34930),
        l = t.getParameter(35660),
        h = t.getParameter(3379),
        p = t.getParameter(34076),
        f = t.getParameter(34921),
        d = t.getParameter(36347),
        m = t.getParameter(36348),
        v = t.getParameter(36349),
        g = l > 0,
        y = o || !!e.get("OES_texture_float");
      return {
        isWebGL2: o,
        getMaxAnisotropy: function () {
          if (void 0 !== r) return r;
          var n = e.get("EXT_texture_filter_anisotropic");
          return (r =
            null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0);
        },
        getMaxPrecision: i,
        precision: a,
        logarithmicDepthBuffer: c,
        maxTextures: u,
        maxVertexTextures: l,
        maxTextureSize: h,
        maxCubemapSize: p,
        maxAttributes: f,
        maxVertexUniforms: d,
        maxVaryings: m,
        maxFragmentUniforms: v,
        vertexTextures: g,
        floatFragmentTextures: y,
        floatVertexTextures: g && y,
        maxSamples: o ? t.getParameter(36183) : 0,
      };
    }
    function Wi() {
      var t = this,
        e = null,
        n = 0,
        r = !1,
        i = !1,
        o = new Ci(),
        a = new Qe(),
        s = { value: null, needsUpdate: !1 };
      function c() {
        s.value !== e && ((s.value = e), (s.needsUpdate = n > 0)),
          (t.numPlanes = n),
          (t.numIntersection = 0);
      }
      function u(e, n, r, i) {
        var c = null !== e ? e.length : 0,
          u = null;
        if (0 !== c) {
          if (((u = s.value), !0 !== i || null === u)) {
            var l = r + 4 * c,
              h = n.matrixWorldInverse;
            a.getNormalMatrix(h),
              (null === u || u.length < l) && (u = new Float32Array(l));
            for (var p = 0, f = r; p !== c; ++p, f += 4)
              o.copy(e[p]).applyMatrix4(h, a),
                o.normal.toArray(u, f),
                (u[f + 3] = o.constant);
          }
          (s.value = u), (s.needsUpdate = !0);
        }
        return (t.numPlanes = c), u;
      }
      (this.uniform = s),
        (this.numPlanes = 0),
        (this.numIntersection = 0),
        (this.init = function (t, i, o) {
          var a = 0 !== t.length || i || 0 !== n || r;
          return (r = i), (e = u(t, o, 0)), (n = t.length), a;
        }),
        (this.beginShadows = function () {
          (i = !0), u(null);
        }),
        (this.endShadows = function () {
          (i = !1), c();
        }),
        (this.setState = function (t, o, a, l, h, p) {
          if (!r || null === t || 0 === t.length || (i && !a))
            i ? u(null) : c();
          else {
            var f = i ? 0 : n,
              d = 4 * f,
              m = h.clippingState || null;
            (s.value = m), (m = u(t, l, d, p));
            for (var v = 0; v !== d; ++v) m[v] = e[v];
            (h.clippingState = m),
              (this.numIntersection = o ? this.numPlanes : 0),
              (this.numPlanes += f);
          }
        });
    }
    function qi(t) {
      var e = {};
      return {
        get: function (n) {
          if (void 0 !== e[n]) return e[n];
          var r;
          switch (n) {
            case "WEBGL_depth_texture":
              r =
                t.getExtension("WEBGL_depth_texture") ||
                t.getExtension("MOZ_WEBGL_depth_texture") ||
                t.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              r =
                t.getExtension("EXT_texture_filter_anisotropic") ||
                t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              r =
                t.getExtension("WEBGL_compressed_texture_s3tc") ||
                t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              r =
                t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              r = t.getExtension(n);
          }
          return (
            null === r &&
              console.warn(
                "THREE.WebGLRenderer: " + n + " extension not supported."
              ),
            (e[n] = r),
            r
          );
        },
      };
    }
    function Xi(t, e, n) {
      var r = new WeakMap(),
        i = new WeakMap();
      function o(t) {
        var a = t.target,
          s = r.get(a);
        for (var c in (null !== s.index && e.remove(s.index), s.attributes))
          e.remove(s.attributes[c]);
        a.removeEventListener("dispose", o), r.delete(a);
        var u = i.get(s);
        u && (e.remove(u), i.delete(s)), n.memory.geometries--;
      }
      function a(t) {
        var n = [],
          r = t.index,
          o = t.attributes.position,
          a = 0;
        if (null !== r) {
          var s = r.array;
          a = r.version;
          for (var c = 0, u = s.length; c < u; c += 3) {
            var l = s[c + 0],
              h = s[c + 1],
              p = s[c + 2];
            n.push(l, h, h, p, p, l);
          }
        } else {
          s = o.array;
          a = o.version;
          for (c = 0, u = s.length / 3 - 1; c < u; c += 3) {
            (l = c + 0), (h = c + 1), (p = c + 2);
            n.push(l, h, h, p, p, l);
          }
        }
        var f = new (Dr(n) > 65535 ? Cr : Pr)(n, 1);
        (f.version = a), e.update(f, 34963);
        var d = i.get(t);
        d && e.remove(d), i.set(t, f);
      }
      return {
        get: function (t, e) {
          var i = r.get(e);
          return (
            i ||
            (e.addEventListener("dispose", o),
            e.isBufferGeometry
              ? (i = e)
              : e.isGeometry &&
                (void 0 === e._bufferGeometry &&
                  (e._bufferGeometry = new Hr().setFromObject(t)),
                (i = e._bufferGeometry)),
            r.set(e, i),
            n.memory.geometries++,
            i)
          );
        },
        update: function (t) {
          var n = t.index,
            r = t.attributes;
          for (var i in (null !== n && e.update(n, 34963), r))
            e.update(r[i], 34962);
          var o = t.morphAttributes;
          for (var i in o)
            for (var a = o[i], s = 0, c = a.length; s < c; s++)
              e.update(a[s], 34962);
        },
        getWireframeAttribute: function (t) {
          var e = i.get(t);
          if (e) {
            var n = t.index;
            null !== n && e.version < n.version && a(t);
          } else a(t);
          return i.get(t);
        },
      };
    }
    function Yi(t, e, n, r) {
      var i, o, a;
      (this.setMode = function (t) {
        i = t;
      }),
        (this.setIndex = function (t) {
          (o = t.type), (a = t.bytesPerElement);
        }),
        (this.render = function (e, r) {
          t.drawElements(i, r, o, e * a), n.update(r, i);
        }),
        (this.renderInstances = function (s, c, u, l) {
          if (0 !== l) {
            var h, p;
            if (r.isWebGL2) (h = t), (p = "drawElementsInstanced");
            else if (
              ((p = "drawElementsInstancedANGLE"),
              null === (h = e.get("ANGLE_instanced_arrays")))
            )
              return void console.error(
                "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
              );
            h[p](i, u, o, c * a, l), n.update(u, i, l);
          }
        });
    }
    function Ji(t) {
      var e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
      return {
        memory: { geometries: 0, textures: 0 },
        render: e,
        programs: null,
        autoReset: !0,
        reset: function () {
          e.frame++,
            (e.calls = 0),
            (e.triangles = 0),
            (e.points = 0),
            (e.lines = 0);
        },
        update: function (t, n, r) {
          switch (((r = r || 1), e.calls++, n)) {
            case 4:
              e.triangles += r * (t / 3);
              break;
            case 5:
            case 6:
              e.triangles += r * (t - 2);
              break;
            case 1:
              e.lines += r * (t / 2);
              break;
            case 3:
              e.lines += r * (t - 1);
              break;
            case 2:
              e.lines += r * t;
              break;
            case 0:
              e.points += r * t;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", n);
          }
        },
      };
    }
    function Zi(t, e) {
      return Math.abs(e[1]) - Math.abs(t[1]);
    }
    function Qi(t) {
      var e = {},
        n = new Float32Array(8);
      return {
        update: function (r, i, o, a) {
          var s = r.morphTargetInfluences,
            c = s.length,
            u = e[i.id];
          if (void 0 === u) {
            u = [];
            for (var l = 0; l < c; l++) u[l] = [l, 0];
            e[i.id] = u;
          }
          var h = o.morphTargets && i.morphAttributes.position,
            p = o.morphNormals && i.morphAttributes.normal;
          for (l = 0; l < c; l++) {
            0 !== (f = u[l])[1] &&
              (h && i.removeAttribute("morphTarget" + l),
              p && i.removeAttribute("morphNormal" + l));
          }
          for (l = 0; l < c; l++) {
            ((f = u[l])[0] = l), (f[1] = s[l]);
          }
          for (u.sort(Zi), l = 0; l < 8; l++) {
            var f;
            if ((f = u[l])) {
              var d = f[0],
                m = f[1];
              if (m) {
                h && i.addAttribute("morphTarget" + l, h[d]),
                  p && i.addAttribute("morphNormal" + l, p[d]),
                  (n[l] = m);
                continue;
              }
            }
            n[l] = 0;
          }
          a.getUniforms().setValue(t, "morphTargetInfluences", n);
        },
      };
    }
    function Ki(t, e, n, r) {
      var i = {};
      return {
        update: function (t) {
          var o = r.render.frame,
            a = t.geometry,
            s = e.get(t, a);
          return (
            i[s.id] !== o &&
              (a.isGeometry && s.updateFromObject(t),
              e.update(s),
              (i[s.id] = o)),
            t.isInstancedMesh && n.update(t.instanceMatrix, 34962),
            s
          );
        },
        dispose: function () {
          i = {};
        },
      };
    }
    function $i(t, e, n, r, i, o, a, s, c, u) {
      (t = void 0 !== t ? t : []),
        (e = void 0 !== e ? e : vt),
        (a = void 0 !== a ? a : Wt),
        tn.call(this, t, e, n, r, i, o, a, s, c, u),
        (this.flipY = !1);
    }
    function to(t, e, n, r) {
      tn.call(this, null),
        (this.image = {
          data: t || null,
          width: e || 1,
          height: n || 1,
          depth: r || 1,
        }),
        (this.magFilter = Tt),
        (this.minFilter = Tt),
        (this.wrapR = St),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.needsUpdate = !0);
    }
    function eo(t, e, n, r) {
      tn.call(this, null),
        (this.image = {
          data: t || null,
          width: e || 1,
          height: n || 1,
          depth: r || 1,
        }),
        (this.magFilter = Tt),
        (this.minFilter = Tt),
        (this.wrapR = St),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.needsUpdate = !0);
    }
    (Fi.physical = {
      uniforms: gi([
        Fi.standard.uniforms,
        {
          transparency: { value: 0 },
          clearcoat: { value: 0 },
          clearcoatRoughness: { value: 0 },
          sheen: { value: new vr(0) },
          clearcoatNormalScale: { value: new ke(1, 1) },
          clearcoatNormalMap: { value: null },
        },
      ]),
      vertexShader: Di.meshphysical_vert,
      fragmentShader: Di.meshphysical_frag,
    }),
      (Gi.prototype = Object.create(di.prototype)),
      (Gi.prototype.constructor = Gi),
      (ji.prototype = Object.create(Hr.prototype)),
      (ji.prototype.constructor = ji),
      ($i.prototype = Object.create(tn.prototype)),
      ($i.prototype.constructor = $i),
      ($i.prototype.isCubeTexture = !0),
      Object.defineProperty($i.prototype, "images", {
        get: function () {
          return this.image;
        },
        set: function (t) {
          this.image = t;
        },
      }),
      (to.prototype = Object.create(tn.prototype)),
      (to.prototype.constructor = to),
      (to.prototype.isDataTexture2DArray = !0),
      (eo.prototype = Object.create(tn.prototype)),
      (eo.prototype.constructor = eo),
      (eo.prototype.isDataTexture3D = !0);
    var no = new tn(),
      ro = new to(),
      io = new eo(),
      oo = new $i(),
      ao = [],
      so = [],
      co = new Float32Array(16),
      uo = new Float32Array(9),
      lo = new Float32Array(4);
    function ho(t, e, n) {
      var r = t[0];
      if (r <= 0 || r > 0) return t;
      var i = e * n,
        o = ao[i];
      if ((void 0 === o && ((o = new Float32Array(i)), (ao[i] = o)), 0 !== e)) {
        r.toArray(o, 0);
        for (var a = 1, s = 0; a !== e; ++a) (s += n), t[a].toArray(o, s);
      }
      return o;
    }
    function po(t, e) {
      if (t.length !== e.length) return !1;
      for (var n = 0, r = t.length; n < r; n++) if (t[n] !== e[n]) return !1;
      return !0;
    }
    function fo(t, e) {
      for (var n = 0, r = e.length; n < r; n++) t[n] = e[n];
    }
    function mo(t, e) {
      var n = so[e];
      void 0 === n && ((n = new Int32Array(e)), (so[e] = n));
      for (var r = 0; r !== e; ++r) n[r] = t.allocateTextureUnit();
      return n;
    }
    function vo(t, e) {
      var n = this.cache;
      n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
    }
    function go(t, e) {
      var n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y) ||
          (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
      else {
        if (po(n, e)) return;
        t.uniform2fv(this.addr, e), fo(n, e);
      }
    }
    function yo(t, e) {
      var n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
          (t.uniform3f(this.addr, e.x, e.y, e.z),
          (n[0] = e.x),
          (n[1] = e.y),
          (n[2] = e.z));
      else if (void 0 !== e.r)
        (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
          (t.uniform3f(this.addr, e.r, e.g, e.b),
          (n[0] = e.r),
          (n[1] = e.g),
          (n[2] = e.b));
      else {
        if (po(n, e)) return;
        t.uniform3fv(this.addr, e), fo(n, e);
      }
    }
    function xo(t, e) {
      var n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
          (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
          (n[0] = e.x),
          (n[1] = e.y),
          (n[2] = e.z),
          (n[3] = e.w));
      else {
        if (po(n, e)) return;
        t.uniform4fv(this.addr, e), fo(n, e);
      }
    }
    function bo(t, e) {
      var n = this.cache,
        r = e.elements;
      if (void 0 === r) {
        if (po(n, e)) return;
        t.uniformMatrix2fv(this.addr, !1, e), fo(n, e);
      } else {
        if (po(n, r)) return;
        lo.set(r), t.uniformMatrix2fv(this.addr, !1, lo), fo(n, r);
      }
    }
    function wo(t, e) {
      var n = this.cache,
        r = e.elements;
      if (void 0 === r) {
        if (po(n, e)) return;
        t.uniformMatrix3fv(this.addr, !1, e), fo(n, e);
      } else {
        if (po(n, r)) return;
        uo.set(r), t.uniformMatrix3fv(this.addr, !1, uo), fo(n, r);
      }
    }
    function _o(t, e) {
      var n = this.cache,
        r = e.elements;
      if (void 0 === r) {
        if (po(n, e)) return;
        t.uniformMatrix4fv(this.addr, !1, e), fo(n, e);
      } else {
        if (po(n, r)) return;
        co.set(r), t.uniformMatrix4fv(this.addr, !1, co), fo(n, r);
      }
    }
    function Mo(t, e, n) {
      var r = this.cache,
        i = n.allocateTextureUnit();
      r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
        n.safeSetTexture2D(e || no, i);
    }
    function So(t, e, n) {
      var r = this.cache,
        i = n.allocateTextureUnit();
      r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
        n.setTexture2DArray(e || ro, i);
    }
    function Eo(t, e, n) {
      var r = this.cache,
        i = n.allocateTextureUnit();
      r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
        n.setTexture3D(e || io, i);
    }
    function To(t, e, n) {
      var r = this.cache,
        i = n.allocateTextureUnit();
      r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
        n.safeSetTextureCube(e || oo, i);
    }
    function Ao(t, e) {
      var n = this.cache;
      n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
    }
    function Lo(t, e) {
      var n = this.cache;
      po(n, e) || (t.uniform2iv(this.addr, e), fo(n, e));
    }
    function Po(t, e) {
      var n = this.cache;
      po(n, e) || (t.uniform3iv(this.addr, e), fo(n, e));
    }
    function Ro(t, e) {
      var n = this.cache;
      po(n, e) || (t.uniform4iv(this.addr, e), fo(n, e));
    }
    function Co(t, e) {
      t.uniform1fv(this.addr, e);
    }
    function Oo(t, e) {
      t.uniform1iv(this.addr, e);
    }
    function Io(t, e) {
      t.uniform2iv(this.addr, e);
    }
    function No(t, e) {
      t.uniform3iv(this.addr, e);
    }
    function Do(t, e) {
      t.uniform4iv(this.addr, e);
    }
    function zo(t, e) {
      var n = ho(e, this.size, 2);
      t.uniform2fv(this.addr, n);
    }
    function Fo(t, e) {
      var n = ho(e, this.size, 3);
      t.uniform3fv(this.addr, n);
    }
    function Uo(t, e) {
      var n = ho(e, this.size, 4);
      t.uniform4fv(this.addr, n);
    }
    function Bo(t, e) {
      var n = ho(e, this.size, 4);
      t.uniformMatrix2fv(this.addr, !1, n);
    }
    function Go(t, e) {
      var n = ho(e, this.size, 9);
      t.uniformMatrix3fv(this.addr, !1, n);
    }
    function jo(t, e) {
      var n = ho(e, this.size, 16);
      t.uniformMatrix4fv(this.addr, !1, n);
    }
    function Vo(t, e, n) {
      var r = e.length,
        i = mo(n, r);
      t.uniform1iv(this.addr, i);
      for (var o = 0; o !== r; ++o) n.safeSetTexture2D(e[o] || no, i[o]);
    }
    function Ho(t, e, n) {
      var r = e.length,
        i = mo(n, r);
      t.uniform1iv(this.addr, i);
      for (var o = 0; o !== r; ++o) n.safeSetTextureCube(e[o] || oo, i[o]);
    }
    function ko(t, e, n) {
      (this.id = t),
        (this.addr = n),
        (this.cache = []),
        (this.setValue = (function (t) {
          switch (t) {
            case 5126:
              return vo;
            case 35664:
              return go;
            case 35665:
              return yo;
            case 35666:
              return xo;
            case 35674:
              return bo;
            case 35675:
              return wo;
            case 35676:
              return _o;
            case 35678:
            case 36198:
              return Mo;
            case 35679:
              return Eo;
            case 35680:
              return To;
            case 36289:
              return So;
            case 5124:
            case 35670:
              return Ao;
            case 35667:
            case 35671:
              return Lo;
            case 35668:
            case 35672:
              return Po;
            case 35669:
            case 35673:
              return Ro;
          }
        })(e.type));
    }
    function Wo(t, e, n) {
      (this.id = t),
        (this.addr = n),
        (this.cache = []),
        (this.size = e.size),
        (this.setValue = (function (t) {
          switch (t) {
            case 5126:
              return Co;
            case 35664:
              return zo;
            case 35665:
              return Fo;
            case 35666:
              return Uo;
            case 35674:
              return Bo;
            case 35675:
              return Go;
            case 35676:
              return jo;
            case 35678:
              return Vo;
            case 35680:
              return Ho;
            case 5124:
            case 35670:
              return Oo;
            case 35667:
            case 35671:
              return Io;
            case 35668:
            case 35672:
              return No;
            case 35669:
            case 35673:
              return Do;
          }
        })(e.type));
    }
    function qo(t) {
      (this.id = t), (this.seq = []), (this.map = {});
    }
    (Wo.prototype.updateCache = function (t) {
      var e = this.cache;
      t instanceof Float32Array &&
        e.length !== t.length &&
        (this.cache = new Float32Array(t.length)),
        fo(e, t);
    }),
      (qo.prototype.setValue = function (t, e, n) {
        for (var r = this.seq, i = 0, o = r.length; i !== o; ++i) {
          var a = r[i];
          a.setValue(t, e[a.id], n);
        }
      });
    var Xo = /([\w\d_]+)(\])?(\[|\.)?/g;
    function Yo(t, e) {
      t.seq.push(e), (t.map[e.id] = e);
    }
    function Jo(t, e, n) {
      var r = t.name,
        i = r.length;
      for (Xo.lastIndex = 0; ; ) {
        var o = Xo.exec(r),
          a = Xo.lastIndex,
          s = o[1],
          c = "]" === o[2],
          u = o[3];
        if ((c && (s |= 0), void 0 === u || ("[" === u && a + 2 === i))) {
          Yo(n, void 0 === u ? new ko(s, t, e) : new Wo(s, t, e));
          break;
        }
        var l = n.map[s];
        void 0 === l && Yo(n, (l = new qo(s))), (n = l);
      }
    }
    function Zo(t, e) {
      (this.seq = []), (this.map = {});
      for (var n = t.getProgramParameter(e, 35718), r = 0; r < n; ++r) {
        var i = t.getActiveUniform(e, r);
        Jo(i, t.getUniformLocation(e, i.name), this);
      }
    }
    function Qo(t, e, n) {
      var r = t.createShader(e);
      return t.shaderSource(r, n), t.compileShader(r), r;
    }
    (Zo.prototype.setValue = function (t, e, n, r) {
      var i = this.map[e];
      void 0 !== i && i.setValue(t, n, r);
    }),
      (Zo.prototype.setOptional = function (t, e, n) {
        var r = e[n];
        void 0 !== r && this.setValue(t, n, r);
      }),
      (Zo.upload = function (t, e, n, r) {
        for (var i = 0, o = e.length; i !== o; ++i) {
          var a = e[i],
            s = n[a.id];
          !1 !== s.needsUpdate && a.setValue(t, s.value, r);
        }
      }),
      (Zo.seqWithValue = function (t, e) {
        for (var n = [], r = 0, i = t.length; r !== i; ++r) {
          var o = t[r];
          o.id in e && n.push(o);
        }
        return n;
      });
    var Ko = 0;
    function $o(t) {
      switch (t) {
        case Te:
          return ["Linear", "( value )"];
        case Ae:
          return ["sRGB", "( value )"];
        case Pe:
          return ["RGBE", "( value )"];
        case Ce:
          return ["RGBM", "( value, 7.0 )"];
        case Oe:
          return ["RGBM", "( value, 16.0 )"];
        case Ie:
          return ["RGBD", "( value, 256.0 )"];
        case Le:
          return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        case Re:
          return ["LogLuv", "( value )"];
        default:
          throw new Error("unsupported encoding: " + t);
      }
    }
    function ta(t, e, n) {
      var r = t.getShaderParameter(e, 35713),
        i = t.getShaderInfoLog(e).trim();
      return r && "" === i
        ? ""
        : "THREE.WebGLShader: gl.getShaderInfoLog() " +
            n +
            "\n" +
            i +
            (function (t) {
              for (var e = t.split("\n"), n = 0; n < e.length; n++)
                e[n] = n + 1 + ": " + e[n];
              return e.join("\n");
            })(t.getShaderSource(e));
    }
    function ea(t, e) {
      var n = $o(e);
      return (
        "vec4 " +
        t +
        "( vec4 value ) { return " +
        n[0] +
        "ToLinear" +
        n[1] +
        "; }"
      );
    }
    function na(t, e) {
      var n;
      switch (e) {
        case ht:
          n = "Linear";
          break;
        case pt:
          n = "Reinhard";
          break;
        case ft:
          n = "Uncharted2";
          break;
        case dt:
          n = "OptimizedCineon";
          break;
        case mt:
          n = "ACESFilmic";
          break;
        default:
          throw new Error("unsupported toneMapping: " + e);
      }
      return (
        "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
      );
    }
    function ra(t) {
      return "" !== t;
    }
    function ia(t, e) {
      return t
        .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
        .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
        .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
        .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
        .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
        .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
        .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
        .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
    }
    function oa(t, e) {
      return t
        .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
        .replace(
          /UNION_CLIPPING_PLANES/g,
          e.numClippingPlanes - e.numClipIntersection
        );
    }
    var aa = /^[ \t]*#include +<([\w\d.\/]+)>/gm;
    function sa(t) {
      return t.replace(aa, ca);
    }
    function ca(t, e) {
      var n = Di[e];
      if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
      return sa(n);
    }
    var ua =
      /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
    function la(t) {
      return t.replace(ua, ha);
    }
    function ha(t, e, n, r) {
      for (var i = "", o = parseInt(e); o < parseInt(n); o++)
        i += r
          .replace(/\[ i \]/g, "[ " + o + " ]")
          .replace(/UNROLLED_LOOP_INDEX/g, o);
      return i;
    }
    function pa(t) {
      var e =
        "precision " +
        t.precision +
        " float;\nprecision " +
        t.precision +
        " int;";
      return (
        "highp" === t.precision
          ? (e += "\n#define HIGH_PRECISION")
          : "mediump" === t.precision
          ? (e += "\n#define MEDIUM_PRECISION")
          : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
        e
      );
    }
    function fa(t, e, n, r, i, o) {
      var a,
        s,
        c,
        u,
        l,
        h = t.getContext(),
        p = r.defines,
        f = i.vertexShader,
        d = i.fragmentShader,
        m = (function (t) {
          var e = "SHADOWMAP_TYPE_BASIC";
          return (
            t.shadowMapType === _
              ? (e = "SHADOWMAP_TYPE_PCF")
              : t.shadowMapType === M
              ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
              : t.shadowMapType === S && (e = "SHADOWMAP_TYPE_VSM"),
            e
          );
        })(o),
        v = (function (t, e) {
          var n = "ENVMAP_TYPE_CUBE";
          if (t.envMap)
            switch (e.envMap.mapping) {
              case vt:
              case gt:
                n = "ENVMAP_TYPE_CUBE";
                break;
              case wt:
              case _t:
                n = "ENVMAP_TYPE_CUBE_UV";
                break;
              case yt:
              case xt:
                n = "ENVMAP_TYPE_EQUIREC";
                break;
              case bt:
                n = "ENVMAP_TYPE_SPHERE";
            }
          return n;
        })(o, r),
        g = (function (t, e) {
          var n = "ENVMAP_MODE_REFLECTION";
          if (t.envMap)
            switch (e.envMap.mapping) {
              case gt:
              case xt:
                n = "ENVMAP_MODE_REFRACTION";
            }
          return n;
        })(o, r),
        y = (function (t, e) {
          var n = "ENVMAP_BLENDING_MULTIPLY";
          if (t.envMap)
            switch (e.combine) {
              case st:
                n = "ENVMAP_BLENDING_MULTIPLY";
                break;
              case ct:
                n = "ENVMAP_BLENDING_MIX";
                break;
              case ut:
                n = "ENVMAP_BLENDING_ADD";
            }
          return n;
        })(o, r),
        x = t.gammaFactor > 0 ? t.gammaFactor : 1,
        b = o.isWebGL2
          ? ""
          : (function (t, e, n) {
              return [
                (t = t || {}).derivatives ||
                e.envMapCubeUV ||
                e.bumpMap ||
                e.tangentSpaceNormalMap ||
                e.clearcoatNormalMap ||
                e.flatShading
                  ? "#extension GL_OES_standard_derivatives : enable"
                  : "",
                (t.fragDepth || e.logarithmicDepthBuffer) &&
                n.get("EXT_frag_depth")
                  ? "#extension GL_EXT_frag_depth : enable"
                  : "",
                t.drawBuffers && n.get("WEBGL_draw_buffers")
                  ? "#extension GL_EXT_draw_buffers : require"
                  : "",
                (t.shaderTextureLOD || e.envMap) &&
                n.get("EXT_shader_texture_lod")
                  ? "#extension GL_EXT_shader_texture_lod : enable"
                  : "",
              ]
                .filter(ra)
                .join("\n");
            })(r.extensions, o, e),
        w = (function (t) {
          var e = [];
          for (var n in t) {
            var r = t[n];
            !1 !== r && e.push("#define " + n + " " + r);
          }
          return e.join("\n");
        })(p),
        E = h.createProgram(),
        T = t.getRenderTarget(),
        A = T && T.isWebGLMultiviewRenderTarget ? T.numViews : 0;
      if (
        (r.isRawShaderMaterial
          ? ((a = [w].filter(ra).join("\n")).length > 0 && (a += "\n"),
            (s = [b, w].filter(ra).join("\n")).length > 0 && (s += "\n"))
          : ((a = [
              pa(o),
              "#define SHADER_NAME " + i.name,
              w,
              o.instancing ? "#define USE_INSTANCING" : "",
              o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              "#define GAMMA_FACTOR " + x,
              "#define MAX_BONES " + o.maxBones,
              o.useFog && o.fog ? "#define USE_FOG" : "",
              o.useFog && o.fogExp2 ? "#define FOG_EXP2" : "",
              o.map ? "#define USE_MAP" : "",
              o.envMap ? "#define USE_ENVMAP" : "",
              o.envMap ? "#define " + g : "",
              o.lightMap ? "#define USE_LIGHTMAP" : "",
              o.aoMap ? "#define USE_AOMAP" : "",
              o.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              o.bumpMap ? "#define USE_BUMPMAP" : "",
              o.normalMap ? "#define USE_NORMALMAP" : "",
              o.normalMap && o.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              o.normalMap && o.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              o.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              o.displacementMap && o.supportsVertexTextures
                ? "#define USE_DISPLACEMENTMAP"
                : "",
              o.specularMap ? "#define USE_SPECULARMAP" : "",
              o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              o.metalnessMap ? "#define USE_METALNESSMAP" : "",
              o.alphaMap ? "#define USE_ALPHAMAP" : "",
              o.vertexTangents ? "#define USE_TANGENT" : "",
              o.vertexColors ? "#define USE_COLOR" : "",
              o.vertexUvs ? "#define USE_UV" : "",
              o.flatShading ? "#define FLAT_SHADED" : "",
              o.skinning ? "#define USE_SKINNING" : "",
              o.useVertexTexture ? "#define BONE_TEXTURE" : "",
              o.morphTargets ? "#define USE_MORPHTARGETS" : "",
              o.morphNormals && !1 === o.flatShading
                ? "#define USE_MORPHNORMALS"
                : "",
              o.doubleSided ? "#define DOUBLE_SIDED" : "",
              o.flipSided ? "#define FLIP_SIDED" : "",
              o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              o.shadowMapEnabled ? "#define " + m : "",
              o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              o.logarithmicDepthBuffer &&
              (o.isWebGL2 || e.get("EXT_frag_depth"))
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "#ifdef USE_INSTANCING",
              " attribute mat4 instanceMatrix;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_TANGENT",
              "\tattribute vec4 tangent;",
              "#endif",
              "#ifdef USE_COLOR",
              "\tattribute vec3 color;",
              "#endif",
              "#ifdef USE_MORPHTARGETS",
              "\tattribute vec3 morphTarget0;",
              "\tattribute vec3 morphTarget1;",
              "\tattribute vec3 morphTarget2;",
              "\tattribute vec3 morphTarget3;",
              "\t#ifdef USE_MORPHNORMALS",
              "\t\tattribute vec3 morphNormal0;",
              "\t\tattribute vec3 morphNormal1;",
              "\t\tattribute vec3 morphNormal2;",
              "\t\tattribute vec3 morphNormal3;",
              "\t#else",
              "\t\tattribute vec3 morphTarget4;",
              "\t\tattribute vec3 morphTarget5;",
              "\t\tattribute vec3 morphTarget6;",
              "\t\tattribute vec3 morphTarget7;",
              "\t#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "\tattribute vec4 skinIndex;",
              "\tattribute vec4 skinWeight;",
              "#endif",
              "\n",
            ]
              .filter(ra)
              .join("\n")),
            (s = [
              b,
              pa(o),
              "#define SHADER_NAME " + i.name,
              w,
              o.alphaTest
                ? "#define ALPHATEST " +
                  o.alphaTest +
                  (o.alphaTest % 1 ? "" : ".0")
                : "",
              "#define GAMMA_FACTOR " + x,
              o.useFog && o.fog ? "#define USE_FOG" : "",
              o.useFog && o.fogExp2 ? "#define FOG_EXP2" : "",
              o.map ? "#define USE_MAP" : "",
              o.matcap ? "#define USE_MATCAP" : "",
              o.envMap ? "#define USE_ENVMAP" : "",
              o.envMap ? "#define " + v : "",
              o.envMap ? "#define " + g : "",
              o.envMap ? "#define " + y : "",
              o.lightMap ? "#define USE_LIGHTMAP" : "",
              o.aoMap ? "#define USE_AOMAP" : "",
              o.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              o.bumpMap ? "#define USE_BUMPMAP" : "",
              o.normalMap ? "#define USE_NORMALMAP" : "",
              o.normalMap && o.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              o.normalMap && o.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              o.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              o.specularMap ? "#define USE_SPECULARMAP" : "",
              o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              o.metalnessMap ? "#define USE_METALNESSMAP" : "",
              o.alphaMap ? "#define USE_ALPHAMAP" : "",
              o.sheen ? "#define USE_SHEEN" : "",
              o.vertexTangents ? "#define USE_TANGENT" : "",
              o.vertexColors ? "#define USE_COLOR" : "",
              o.vertexUvs ? "#define USE_UV" : "",
              o.gradientMap ? "#define USE_GRADIENTMAP" : "",
              o.flatShading ? "#define FLAT_SHADED" : "",
              o.doubleSided ? "#define DOUBLE_SIDED" : "",
              o.flipSided ? "#define FLIP_SIDED" : "",
              o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              o.shadowMapEnabled ? "#define " + m : "",
              o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              o.physicallyCorrectLights
                ? "#define PHYSICALLY_CORRECT_LIGHTS"
                : "",
              o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              o.logarithmicDepthBuffer &&
              (o.isWebGL2 || e.get("EXT_frag_depth"))
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              ((r.extensions && r.extensions.shaderTextureLOD) || o.envMap) &&
              (o.isWebGL2 || e.get("EXT_shader_texture_lod"))
                ? "#define TEXTURE_LOD_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              o.toneMapping !== lt ? "#define TONE_MAPPING" : "",
              o.toneMapping !== lt ? Di.tonemapping_pars_fragment : "",
              o.toneMapping !== lt ? na("toneMapping", o.toneMapping) : "",
              o.dithering ? "#define DITHERING" : "",
              o.outputEncoding ||
              o.mapEncoding ||
              o.matcapEncoding ||
              o.envMapEncoding ||
              o.emissiveMapEncoding
                ? Di.encodings_pars_fragment
                : "",
              o.mapEncoding ? ea("mapTexelToLinear", o.mapEncoding) : "",
              o.matcapEncoding
                ? ea("matcapTexelToLinear", o.matcapEncoding)
                : "",
              o.envMapEncoding
                ? ea("envMapTexelToLinear", o.envMapEncoding)
                : "",
              o.emissiveMapEncoding
                ? ea("emissiveMapTexelToLinear", o.emissiveMapEncoding)
                : "",
              o.outputEncoding
                ? ((c = "linearToOutputTexel"),
                  (u = o.outputEncoding),
                  (l = $o(u)),
                  "vec4 " +
                    c +
                    "( vec4 value ) { return LinearTo" +
                    l[0] +
                    l[1] +
                    "; }")
                : "",
              o.depthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "",
              "\n",
            ]
              .filter(ra)
              .join("\n"))),
        (f = oa((f = ia((f = sa(f)), o)), o)),
        (d = oa((d = ia((d = sa(d)), o)), o)),
        (f = la(f)),
        (d = la(d)),
        o.isWebGL2 && !r.isRawShaderMaterial)
      ) {
        var L = !1,
          P = /^\s*#version\s+300\s+es\s*\n/;
        r.isShaderMaterial &&
          null !== f.match(P) &&
          null !== d.match(P) &&
          ((L = !0), (f = f.replace(P, "")), (d = d.replace(P, ""))),
          (a =
            [
              "#version 300 es\n",
              "#define attribute in",
              "#define varying out",
              "#define texture2D texture",
            ].join("\n") +
            "\n" +
            a),
          (s =
            [
              "#version 300 es\n",
              "#define varying in",
              L ? "" : "out highp vec4 pc_fragColor;",
              L ? "" : "#define gl_FragColor pc_fragColor",
              "#define gl_FragDepthEXT gl_FragDepth",
              "#define texture2D texture",
              "#define textureCube texture",
              "#define texture2DProj textureProj",
              "#define texture2DLodEXT textureLod",
              "#define texture2DProjLodEXT textureProjLod",
              "#define textureCubeLodEXT textureLod",
              "#define texture2DGradEXT textureGrad",
              "#define texture2DProjGradEXT textureProjGrad",
              "#define textureCubeGradEXT textureGrad",
            ].join("\n") +
            "\n" +
            s),
          A > 0 &&
            ((a = (a = a.replace(
              "#version 300 es\n",
              [
                "#version 300 es\n",
                "#extension GL_OVR_multiview2 : require",
                "layout(num_views = " + A + ") in;",
                "#define VIEW_ID gl_ViewID_OVR",
              ].join("\n")
            )).replace(
              [
                "uniform mat4 modelViewMatrix;",
                "uniform mat4 projectionMatrix;",
                "uniform mat4 viewMatrix;",
                "uniform mat3 normalMatrix;",
              ].join("\n"),
              [
                "uniform mat4 modelViewMatrices[" + A + "];",
                "uniform mat4 projectionMatrices[" + A + "];",
                "uniform mat4 viewMatrices[" + A + "];",
                "uniform mat3 normalMatrices[" + A + "];",
                "#define modelViewMatrix modelViewMatrices[VIEW_ID]",
                "#define projectionMatrix projectionMatrices[VIEW_ID]",
                "#define viewMatrix viewMatrices[VIEW_ID]",
                "#define normalMatrix normalMatrices[VIEW_ID]",
              ].join("\n")
            )),
            (s = (s = s.replace(
              "#version 300 es\n",
              [
                "#version 300 es\n",
                "#extension GL_OVR_multiview2 : require",
                "#define VIEW_ID gl_ViewID_OVR",
              ].join("\n")
            )).replace(
              "uniform mat4 viewMatrix;",
              [
                "uniform mat4 viewMatrices[" + A + "];",
                "#define viewMatrix viewMatrices[VIEW_ID]",
              ].join("\n")
            )));
      }
      var R,
        C,
        O = s + d,
        I = Qo(h, 35633, a + f),
        N = Qo(h, 35632, O);
      if (
        (h.attachShader(E, I),
        h.attachShader(E, N),
        void 0 !== r.index0AttributeName
          ? h.bindAttribLocation(E, 0, r.index0AttributeName)
          : !0 === o.morphTargets && h.bindAttribLocation(E, 0, "position"),
        h.linkProgram(E),
        t.debug.checkShaderErrors)
      ) {
        var D = h.getProgramInfoLog(E).trim(),
          z = h.getShaderInfoLog(I).trim(),
          F = h.getShaderInfoLog(N).trim(),
          U = !0,
          B = !0;
        if (!1 === h.getProgramParameter(E, 35714)) {
          U = !1;
          var G = ta(h, I, "vertex"),
            j = ta(h, N, "fragment");
          console.error(
            "THREE.WebGLProgram: shader error: ",
            h.getError(),
            "35715",
            h.getProgramParameter(E, 35715),
            "gl.getProgramInfoLog",
            D,
            G,
            j
          );
        } else
          "" !== D
            ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", D)
            : ("" !== z && "" !== F) || (B = !1);
        B &&
          (this.diagnostics = {
            runnable: U,
            material: r,
            programLog: D,
            vertexShader: { log: z, prefix: a },
            fragmentShader: { log: F, prefix: s },
          });
      }
      return (
        h.deleteShader(I),
        h.deleteShader(N),
        (this.getUniforms = function () {
          return void 0 === R && (R = new Zo(h, E)), R;
        }),
        (this.getAttributes = function () {
          return (
            void 0 === C &&
              (C = (function (t, e) {
                for (
                  var n = {}, r = t.getProgramParameter(e, 35721), i = 0;
                  i < r;
                  i++
                ) {
                  var o = t.getActiveAttrib(e, i).name;
                  n[o] = t.getAttribLocation(e, o);
                }
                return n;
              })(h, E)),
            C
          );
        }),
        (this.destroy = function () {
          h.deleteProgram(E), (this.program = void 0);
        }),
        (this.name = i.name),
        (this.id = Ko++),
        (this.code = n),
        (this.usedTimes = 1),
        (this.program = E),
        (this.vertexShader = I),
        (this.fragmentShader = N),
        (this.numMultiviewViews = A),
        this
      );
    }
    function da(t, e, n) {
      var r = [],
        i = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "phong",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite",
        },
        o = [
          "precision",
          "supportsVertexTextures",
          "instancing",
          "map",
          "mapEncoding",
          "matcap",
          "matcapEncoding",
          "envMap",
          "envMapMode",
          "envMapEncoding",
          "lightMap",
          "aoMap",
          "emissiveMap",
          "emissiveMapEncoding",
          "bumpMap",
          "normalMap",
          "objectSpaceNormalMap",
          "tangentSpaceNormalMap",
          "clearcoatNormalMap",
          "displacementMap",
          "specularMap",
          "roughnessMap",
          "metalnessMap",
          "gradientMap",
          "alphaMap",
          "combine",
          "vertexColors",
          "vertexTangents",
          "fog",
          "useFog",
          "fogExp2",
          "flatShading",
          "sizeAttenuation",
          "logarithmicDepthBuffer",
          "skinning",
          "maxBones",
          "useVertexTexture",
          "morphTargets",
          "morphNormals",
          "maxMorphTargets",
          "maxMorphNormals",
          "premultipliedAlpha",
          "numDirLights",
          "numPointLights",
          "numSpotLights",
          "numHemiLights",
          "numRectAreaLights",
          "shadowMapEnabled",
          "shadowMapType",
          "toneMapping",
          "physicallyCorrectLights",
          "alphaTest",
          "doubleSided",
          "flipSided",
          "numClippingPlanes",
          "numClipIntersection",
          "depthPacking",
          "dithering",
          "sheen",
        ];
      function a(t, e) {
        var n;
        return (
          t
            ? t.isTexture
              ? (n = t.encoding)
              : t.isWebGLRenderTarget &&
                (console.warn(
                  "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                ),
                (n = t.texture.encoding))
            : (n = Te),
          n === Te && e && (n = Le),
          n
        );
      }
      (this.getParameters = function (e, r, o, s, c, u, l) {
        var h = i[e.type],
          p = l.isSkinnedMesh
            ? (function (t) {
                var e = t.skeleton.bones;
                if (n.floatVertexTextures) return 1024;
                var r = n.maxVertexUniforms,
                  i = Math.floor((r - 20) / 4),
                  o = Math.min(i, e.length);
                return o < e.length
                  ? (console.warn(
                      "THREE.WebGLRenderer: Skeleton has " +
                        e.length +
                        " bones. This GPU supports " +
                        o +
                        "."
                    ),
                    0)
                  : o;
              })(l)
            : 0,
          f = n.precision;
        null !== e.precision &&
          (f = n.getMaxPrecision(e.precision)) !== e.precision &&
          console.warn(
            "THREE.WebGLProgram.getParameters:",
            e.precision,
            "not supported, using",
            f,
            "instead."
          );
        var d = t.getRenderTarget();
        return {
          isWebGL2: n.isWebGL2,
          shaderID: h,
          precision: f,
          instancing: !0 === l.isInstancedMesh,
          supportsVertexTextures: n.vertexTextures,
          outputEncoding: a(d ? d.texture : null, t.gammaOutput),
          map: !!e.map,
          mapEncoding: a(e.map, t.gammaInput),
          matcap: !!e.matcap,
          matcapEncoding: a(e.matcap, t.gammaInput),
          envMap: !!e.envMap,
          envMapMode: e.envMap && e.envMap.mapping,
          envMapEncoding: a(e.envMap, t.gammaInput),
          envMapCubeUV:
            !!e.envMap && (e.envMap.mapping === wt || e.envMap.mapping === _t),
          lightMap: !!e.lightMap,
          aoMap: !!e.aoMap,
          emissiveMap: !!e.emissiveMap,
          emissiveMapEncoding: a(e.emissiveMap, t.gammaInput),
          bumpMap: !!e.bumpMap,
          normalMap: !!e.normalMap,
          objectSpaceNormalMap: e.normalMapType === Fe,
          tangentSpaceNormalMap: e.normalMapType === ze,
          clearcoatNormalMap: !!e.clearcoatNormalMap,
          displacementMap: !!e.displacementMap,
          roughnessMap: !!e.roughnessMap,
          metalnessMap: !!e.metalnessMap,
          specularMap: !!e.specularMap,
          alphaMap: !!e.alphaMap,
          gradientMap: !!e.gradientMap,
          sheen: !!e.sheen,
          combine: e.combine,
          vertexTangents: e.normalMap && e.vertexTangents,
          vertexColors: e.vertexColors,
          vertexUvs: !!(
            e.map ||
            e.bumpMap ||
            e.normalMap ||
            e.specularMap ||
            e.alphaMap ||
            e.emissiveMap ||
            e.roughnessMap ||
            e.metalnessMap ||
            e.clearcoatNormalMap
          ),
          fog: !!s,
          useFog: e.fog,
          fogExp2: s && s.isFogExp2,
          flatShading: e.flatShading,
          sizeAttenuation: e.sizeAttenuation,
          logarithmicDepthBuffer: n.logarithmicDepthBuffer,
          skinning: e.skinning && p > 0,
          maxBones: p,
          useVertexTexture: n.floatVertexTextures,
          morphTargets: e.morphTargets,
          morphNormals: e.morphNormals,
          maxMorphTargets: t.maxMorphTargets,
          maxMorphNormals: t.maxMorphNormals,
          numDirLights: r.directional.length,
          numPointLights: r.point.length,
          numSpotLights: r.spot.length,
          numRectAreaLights: r.rectArea.length,
          numHemiLights: r.hemi.length,
          numDirLightShadows: r.directionalShadowMap.length,
          numPointLightShadows: r.pointShadowMap.length,
          numSpotLightShadows: r.spotShadowMap.length,
          numClippingPlanes: c,
          numClipIntersection: u,
          dithering: e.dithering,
          shadowMapEnabled: t.shadowMap.enabled && o.length > 0,
          shadowMapType: t.shadowMap.type,
          toneMapping: e.toneMapped ? t.toneMapping : lt,
          physicallyCorrectLights: t.physicallyCorrectLights,
          premultipliedAlpha: e.premultipliedAlpha,
          alphaTest: e.alphaTest,
          doubleSided: e.side === A,
          flipSided: e.side === T,
          depthPacking: void 0 !== e.depthPacking && e.depthPacking,
        };
      }),
        (this.getProgramCode = function (e, n) {
          var r = [];
          if (
            (n.shaderID
              ? r.push(n.shaderID)
              : (r.push(e.fragmentShader), r.push(e.vertexShader)),
            void 0 !== e.defines)
          )
            for (var i in e.defines) r.push(i), r.push(e.defines[i]);
          for (var a = 0; a < o.length; a++) r.push(n[o[a]]);
          return (
            r.push(e.onBeforeCompile.toString()),
            r.push(t.gammaOutput),
            r.push(t.gammaFactor),
            r.join()
          );
        }),
        (this.acquireProgram = function (n, i, o, a) {
          for (var s, c = 0, u = r.length; c < u; c++) {
            var l = r[c];
            if (l.code === a) {
              ++(s = l).usedTimes;
              break;
            }
          }
          return void 0 === s && ((s = new fa(t, e, a, n, i, o)), r.push(s)), s;
        }),
        (this.releaseProgram = function (t) {
          if (0 == --t.usedTimes) {
            var e = r.indexOf(t);
            (r[e] = r[r.length - 1]), r.pop(), t.destroy();
          }
        }),
        (this.programs = r);
    }
    function ma() {
      var t = new WeakMap();
      return {
        get: function (e) {
          var n = t.get(e);
          return void 0 === n && ((n = {}), t.set(e, n)), n;
        },
        remove: function (e) {
          t.delete(e);
        },
        update: function (e, n, r) {
          t.get(e)[n] = r;
        },
        dispose: function () {
          t = new WeakMap();
        },
      };
    }
    function va(t, e) {
      return t.groupOrder !== e.groupOrder
        ? t.groupOrder - e.groupOrder
        : t.renderOrder !== e.renderOrder
        ? t.renderOrder - e.renderOrder
        : t.program !== e.program
        ? t.program.id - e.program.id
        : t.material.id !== e.material.id
        ? t.material.id - e.material.id
        : t.z !== e.z
        ? t.z - e.z
        : t.id - e.id;
    }
    function ga(t, e) {
      return t.groupOrder !== e.groupOrder
        ? t.groupOrder - e.groupOrder
        : t.renderOrder !== e.renderOrder
        ? t.renderOrder - e.renderOrder
        : t.z !== e.z
        ? e.z - t.z
        : t.id - e.id;
    }
    function ya() {
      var t = [],
        e = 0,
        n = [],
        r = [],
        i = { id: -1 };
      function o(n, r, o, a, s, c) {
        var u = t[e];
        return (
          void 0 === u
            ? ((u = {
                id: n.id,
                object: n,
                geometry: r,
                material: o,
                program: o.program || i,
                groupOrder: a,
                renderOrder: n.renderOrder,
                z: s,
                group: c,
              }),
              (t[e] = u))
            : ((u.id = n.id),
              (u.object = n),
              (u.geometry = r),
              (u.material = o),
              (u.program = o.program || i),
              (u.groupOrder = a),
              (u.renderOrder = n.renderOrder),
              (u.z = s),
              (u.group = c)),
          e++,
          u
        );
      }
      return {
        opaque: n,
        transparent: r,
        init: function () {
          (e = 0), (n.length = 0), (r.length = 0);
        },
        push: function (t, e, i, a, s, c) {
          var u = o(t, e, i, a, s, c);
          (!0 === i.transparent ? r : n).push(u);
        },
        unshift: function (t, e, i, a, s, c) {
          var u = o(t, e, i, a, s, c);
          (!0 === i.transparent ? r : n).unshift(u);
        },
        sort: function () {
          n.length > 1 && n.sort(va), r.length > 1 && r.sort(ga);
        },
      };
    }
    function xa() {
      var t = new WeakMap();
      function e(n) {
        var r = n.target;
        r.removeEventListener("dispose", e), t.delete(r);
      }
      return {
        get: function (n, r) {
          var i,
            o = t.get(n);
          return (
            void 0 === o
              ? ((i = new ya()),
                t.set(n, new WeakMap()),
                t.get(n).set(r, i),
                n.addEventListener("dispose", e))
              : void 0 === (i = o.get(r)) && ((i = new ya()), o.set(r, i)),
            i
          );
        },
        dispose: function () {
          t = new WeakMap();
        },
      };
    }
    function ba() {
      var t = {};
      return {
        get: function (e) {
          if (void 0 !== t[e.id]) return t[e.id];
          var n;
          switch (e.type) {
            case "DirectionalLight":
              n = {
                direction: new Ye(),
                color: new vr(),
                shadow: !1,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new ke(),
              };
              break;
            case "SpotLight":
              n = {
                position: new Ye(),
                direction: new Ye(),
                color: new vr(),
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0,
                shadow: !1,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new ke(),
              };
              break;
            case "PointLight":
              n = {
                position: new Ye(),
                color: new vr(),
                distance: 0,
                decay: 0,
                shadow: !1,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new ke(),
                shadowCameraNear: 1,
                shadowCameraFar: 1e3,
              };
              break;
            case "HemisphereLight":
              n = {
                direction: new Ye(),
                skyColor: new vr(),
                groundColor: new vr(),
              };
              break;
            case "RectAreaLight":
              n = {
                color: new vr(),
                position: new Ye(),
                halfWidth: new Ye(),
                halfHeight: new Ye(),
              };
          }
          return (t[e.id] = n), n;
        },
      };
    }
    var wa = 0;
    function _a(t, e) {
      return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
    }
    function Ma() {
      for (
        var t = new ba(),
          e = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
          },
          n = 0;
        n < 9;
        n++
      )
        e.probe.push(new Ye());
      var r = new Ye(),
        i = new pn(),
        o = new pn();
      return {
        setup: function (n, a, s) {
          for (var c = 0, u = 0, l = 0, h = 0; h < 9; h++)
            e.probe[h].set(0, 0, 0);
          var p = 0,
            f = 0,
            d = 0,
            m = 0,
            v = 0,
            g = 0,
            y = 0,
            x = 0,
            b = s.matrixWorldInverse;
          n.sort(_a), (h = 0);
          for (var w = n.length; h < w; h++) {
            var _ = n[h],
              M = _.color,
              S = _.intensity,
              E = _.distance,
              T = _.shadow && _.shadow.map ? _.shadow.map.texture : null;
            if (_.isAmbientLight)
              (c += M.r * S), (u += M.g * S), (l += M.b * S);
            else if (_.isLightProbe)
              for (var A = 0; A < 9; A++)
                e.probe[A].addScaledVector(_.sh.coefficients[A], S);
            else if (_.isDirectionalLight) {
              if (
                ((P = t.get(_)).color.copy(_.color).multiplyScalar(_.intensity),
                P.direction.setFromMatrixPosition(_.matrixWorld),
                r.setFromMatrixPosition(_.target.matrixWorld),
                P.direction.sub(r),
                P.direction.transformDirection(b),
                (P.shadow = _.castShadow),
                _.castShadow)
              ) {
                var L = _.shadow;
                (P.shadowBias = L.bias),
                  (P.shadowRadius = L.radius),
                  (P.shadowMapSize = L.mapSize),
                  (e.directionalShadowMap[p] = T),
                  (e.directionalShadowMatrix[p] = _.shadow.matrix),
                  g++;
              }
              (e.directional[p] = P), p++;
            } else if (_.isSpotLight) {
              if (
                ((P = t.get(_)).position.setFromMatrixPosition(_.matrixWorld),
                P.position.applyMatrix4(b),
                P.color.copy(M).multiplyScalar(S),
                (P.distance = E),
                P.direction.setFromMatrixPosition(_.matrixWorld),
                r.setFromMatrixPosition(_.target.matrixWorld),
                P.direction.sub(r),
                P.direction.transformDirection(b),
                (P.coneCos = Math.cos(_.angle)),
                (P.penumbraCos = Math.cos(_.angle * (1 - _.penumbra))),
                (P.decay = _.decay),
                (P.shadow = _.castShadow),
                _.castShadow)
              ) {
                L = _.shadow;
                (P.shadowBias = L.bias),
                  (P.shadowRadius = L.radius),
                  (P.shadowMapSize = L.mapSize),
                  (e.spotShadowMap[d] = T),
                  (e.spotShadowMatrix[d] = _.shadow.matrix),
                  x++;
              }
              (e.spot[d] = P), d++;
            } else if (_.isRectAreaLight) {
              (P = t.get(_)).color.copy(M).multiplyScalar(S),
                P.position.setFromMatrixPosition(_.matrixWorld),
                P.position.applyMatrix4(b),
                o.identity(),
                i.copy(_.matrixWorld),
                i.premultiply(b),
                o.extractRotation(i),
                P.halfWidth.set(0.5 * _.width, 0, 0),
                P.halfHeight.set(0, 0.5 * _.height, 0),
                P.halfWidth.applyMatrix4(o),
                P.halfHeight.applyMatrix4(o),
                (e.rectArea[m] = P),
                m++;
            } else if (_.isPointLight) {
              if (
                ((P = t.get(_)).position.setFromMatrixPosition(_.matrixWorld),
                P.position.applyMatrix4(b),
                P.color.copy(_.color).multiplyScalar(_.intensity),
                (P.distance = _.distance),
                (P.decay = _.decay),
                (P.shadow = _.castShadow),
                _.castShadow)
              ) {
                L = _.shadow;
                (P.shadowBias = L.bias),
                  (P.shadowRadius = L.radius),
                  (P.shadowMapSize = L.mapSize),
                  (P.shadowCameraNear = L.camera.near),
                  (P.shadowCameraFar = L.camera.far),
                  (e.pointShadowMap[f] = T),
                  (e.pointShadowMatrix[f] = _.shadow.matrix),
                  y++;
              }
              (e.point[f] = P), f++;
            } else if (_.isHemisphereLight) {
              var P;
              (P = t.get(_)).direction.setFromMatrixPosition(_.matrixWorld),
                P.direction.transformDirection(b),
                P.direction.normalize(),
                P.skyColor.copy(_.color).multiplyScalar(S),
                P.groundColor.copy(_.groundColor).multiplyScalar(S),
                (e.hemi[v] = P),
                v++;
            }
          }
          (e.ambient[0] = c), (e.ambient[1] = u), (e.ambient[2] = l);
          var R = e.hash;
          (R.directionalLength === p &&
            R.pointLength === f &&
            R.spotLength === d &&
            R.rectAreaLength === m &&
            R.hemiLength === v &&
            R.numDirectionalShadows === g &&
            R.numPointShadows === y &&
            R.numSpotShadows === x) ||
            ((e.directional.length = p),
            (e.spot.length = d),
            (e.rectArea.length = m),
            (e.point.length = f),
            (e.hemi.length = v),
            (e.directionalShadowMap.length = g),
            (e.pointShadowMap.length = y),
            (e.spotShadowMap.length = x),
            (e.directionalShadowMatrix.length = g),
            (e.pointShadowMatrix.length = y),
            (e.spotShadowMatrix.length = x),
            (R.directionalLength = p),
            (R.pointLength = f),
            (R.spotLength = d),
            (R.rectAreaLength = m),
            (R.hemiLength = v),
            (R.numDirectionalShadows = g),
            (R.numPointShadows = y),
            (R.numSpotShadows = x),
            (e.version = wa++));
        },
        state: e,
      };
    }
    function Sa() {
      var t = new Ma(),
        e = [],
        n = [];
      return {
        init: function () {
          (e.length = 0), (n.length = 0);
        },
        state: { lightsArray: e, shadowsArray: n, lights: t },
        setupLights: function (r) {
          t.setup(e, n, r);
        },
        pushLight: function (t) {
          e.push(t);
        },
        pushShadow: function (t) {
          n.push(t);
        },
      };
    }
    function Ea() {
      var t = new WeakMap();
      function e(n) {
        var r = n.target;
        r.removeEventListener("dispose", e), t.delete(r);
      }
      return {
        get: function (n, r) {
          var i;
          return (
            !1 === t.has(n)
              ? ((i = new Sa()),
                t.set(n, new WeakMap()),
                t.get(n).set(r, i),
                n.addEventListener("dispose", e))
              : !1 === t.get(n).has(r)
              ? ((i = new Sa()), t.get(n).set(r, i))
              : (i = t.get(n).get(r)),
            i
          );
        },
        dispose: function () {
          t = new WeakMap();
        },
      };
    }
    function Ta(t) {
      _r.call(this),
        (this.type = "MeshDepthMaterial"),
        (this.depthPacking = Ne),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        this.setValues(t);
    }
    function Aa(t) {
      _r.call(this),
        (this.type = "MeshDistanceMaterial"),
        (this.referencePosition = new Ye()),
        (this.nearDistance = 1),
        (this.farDistance = 1e3),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.fog = !1),
        this.setValues(t);
    }
    (Ta.prototype = Object.create(_r.prototype)),
      (Ta.prototype.constructor = Ta),
      (Ta.prototype.isMeshDepthMaterial = !0),
      (Ta.prototype.copy = function (t) {
        return (
          _r.prototype.copy.call(this, t),
          (this.depthPacking = t.depthPacking),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          this
        );
      }),
      (Aa.prototype = Object.create(_r.prototype)),
      (Aa.prototype.constructor = Aa),
      (Aa.prototype.isMeshDistanceMaterial = !0),
      (Aa.prototype.copy = function (t) {
        return (
          _r.prototype.copy.call(this, t),
          this.referencePosition.copy(t.referencePosition),
          (this.nearDistance = t.nearDistance),
          (this.farDistance = t.farDistance),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          this
        );
      });
    var La =
        "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n  \n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = decodeHalfRGBA ( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = pow( squared_mean - mean * mean, 0.5 );\n  gl_FragColor = encodeHalfRGBA( vec2( mean, std_dev ) );\n}",
      Pa = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
    function Ra(t, e, n) {
      var r = new Ni(),
        i = new ke(),
        o = new ke(),
        a = new en(),
        s = 1,
        c = 2,
        u = 1 + (s | c),
        l = new Array(u),
        h = new Array(u),
        p = {},
        f = { 0: T, 1: E, 2: A },
        d = new bi({
          defines: { SAMPLE_RATE: 0.25, HALF_SAMPLE_RATE: 1 / 8 },
          uniforms: {
            shadow_pass: { value: null },
            resolution: { value: new ke() },
            radius: { value: 4 },
          },
          vertexShader: Pa,
          fragmentShader: La,
        }),
        m = d.clone();
      m.defines.HORIZONAL_PASS = 1;
      var v = new Hr();
      v.addAttribute(
        "position",
        new Sr(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
      );
      for (var g = new si(v, d), y = 0; y !== u; ++y) {
        var x = 0 != (y & s),
          b = 0 != (y & c),
          w = new Ta({ depthPacking: De, morphTargets: x, skinning: b });
        l[y] = w;
        var M = new Aa({ morphTargets: x, skinning: b });
        h[y] = M;
      }
      var L = this;
      function P(n, r) {
        var i = e.update(g);
        (d.uniforms.shadow_pass.value = n.map.texture),
          (d.uniforms.resolution.value = n.mapSize),
          (d.uniforms.radius.value = n.radius),
          t.setRenderTarget(n.mapPass),
          t.clear(),
          t.renderBufferDirect(r, null, i, d, g, null),
          (m.uniforms.shadow_pass.value = n.mapPass.texture),
          (m.uniforms.resolution.value = n.mapSize),
          (m.uniforms.radius.value = n.radius),
          t.setRenderTarget(n.map),
          t.clear(),
          t.renderBufferDirect(r, null, i, m, g, null);
      }
      function R(e, n, r, i, o, a) {
        var u = e.geometry,
          d = null,
          m = l,
          v = e.customDepthMaterial;
        if ((r.isPointLight && ((m = h), (v = e.customDistanceMaterial)), v))
          d = v;
        else {
          var g = !1;
          n.morphTargets &&
            (u && u.isBufferGeometry
              ? (g =
                  u.morphAttributes &&
                  u.morphAttributes.position &&
                  u.morphAttributes.position.length > 0)
              : u &&
                u.isGeometry &&
                (g = u.morphTargets && u.morphTargets.length > 0)),
            e.isSkinnedMesh &&
              !1 === n.skinning &&
              console.warn(
                "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
                e
              );
          var y = e.isSkinnedMesh && n.skinning,
            x = 0;
          g && (x |= s), y && (x |= c), (d = m[x]);
        }
        if (
          t.localClippingEnabled &&
          !0 === n.clipShadows &&
          0 !== n.clippingPlanes.length
        ) {
          var b = d.uuid,
            w = n.uuid,
            _ = p[b];
          void 0 === _ && ((_ = {}), (p[b] = _));
          var M = _[w];
          void 0 === M && ((M = d.clone()), (_[w] = M)), (d = M);
        }
        return (
          (d.visible = n.visible),
          (d.wireframe = n.wireframe),
          (d.side =
            a === S
              ? null != n.shadowSide
                ? n.shadowSide
                : n.side
              : null != n.shadowSide
              ? n.shadowSide
              : f[n.side]),
          (d.clipShadows = n.clipShadows),
          (d.clippingPlanes = n.clippingPlanes),
          (d.clipIntersection = n.clipIntersection),
          (d.wireframeLinewidth = n.wireframeLinewidth),
          (d.linewidth = n.linewidth),
          r.isPointLight &&
            d.isMeshDistanceMaterial &&
            (d.referencePosition.setFromMatrixPosition(r.matrixWorld),
            (d.nearDistance = i),
            (d.farDistance = o)),
          d
        );
      }
      function O(n, i, o, a, s) {
        if (!1 !== n.visible) {
          if (
            n.layers.test(i.layers) &&
            (n.isMesh || n.isLine || n.isPoints) &&
            (n.castShadow || (n.receiveShadow && s === S)) &&
            (!n.frustumCulled || r.intersectsObject(n))
          ) {
            n.modelViewMatrix.multiplyMatrices(
              o.matrixWorldInverse,
              n.matrixWorld
            );
            var c = e.update(n),
              u = n.material;
            if (Array.isArray(u))
              for (var l = c.groups, h = 0, p = l.length; h < p; h++) {
                var f = l[h],
                  d = u[f.materialIndex];
                if (d && d.visible) {
                  var m = R(n, d, a, o.near, o.far, s);
                  t.renderBufferDirect(o, null, c, m, n, f);
                }
              }
            else if (u.visible) {
              m = R(n, u, a, o.near, o.far, s);
              t.renderBufferDirect(o, null, c, m, n, null);
            }
          }
          for (var v = n.children, g = 0, y = v.length; g < y; g++)
            O(v[g], i, o, a, s);
        }
      }
      (this.enabled = !1),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this.type = _),
        (this.render = function (e, s, c) {
          if (
            !1 !== L.enabled &&
            (!1 !== L.autoUpdate || !1 !== L.needsUpdate) &&
            0 !== e.length
          ) {
            var u = t.getRenderTarget(),
              l = t.getActiveCubeFace(),
              h = t.getActiveMipmapLevel(),
              p = t.state;
            p.setBlending(C),
              p.buffers.color.setClear(1, 1, 1, 1),
              p.buffers.depth.setTest(!0),
              p.setScissorTest(!1);
            for (var f = 0, d = e.length; f < d; f++) {
              var m = e[f],
                v = m.shadow;
              if (void 0 !== v) {
                i.copy(v.mapSize);
                var g = v.getFrameExtents();
                if (
                  (i.multiply(g),
                  o.copy(v.mapSize),
                  (i.x > n || i.y > n) &&
                    (console.warn(
                      "THREE.WebGLShadowMap:",
                      m,
                      "has shadow exceeding max texture size, reducing"
                    ),
                    i.x > n &&
                      ((o.x = Math.floor(n / g.x)),
                      (i.x = o.x * g.x),
                      (v.mapSize.x = o.x)),
                    i.y > n &&
                      ((o.y = Math.floor(n / g.y)),
                      (i.y = o.y * g.y),
                      (v.mapSize.y = o.y))),
                  null === v.map && !v.isPointLightShadow && this.type === S)
                ) {
                  var y = { minFilter: Pt, magFilter: Pt, format: qt };
                  (v.map = new nn(i.x, i.y, y)),
                    (v.map.texture.name = m.name + ".shadowMap"),
                    (v.mapPass = new nn(i.x, i.y, y)),
                    v.camera.updateProjectionMatrix();
                }
                if (null === v.map) {
                  y = { minFilter: Tt, magFilter: Tt, format: qt };
                  (v.map = new nn(i.x, i.y, y)),
                    (v.map.texture.name = m.name + ".shadowMap"),
                    v.camera.updateProjectionMatrix();
                }
                t.setRenderTarget(v.map), t.clear();
                for (var x = v.getViewportCount(), b = 0; b < x; b++) {
                  var w = v.getViewport(b);
                  a.set(o.x * w.x, o.y * w.y, o.x * w.z, o.y * w.w),
                    p.viewport(a),
                    v.updateMatrices(m, c, b),
                    (r = v.getFrustum()),
                    O(s, c, v.camera, m, this.type);
                }
                v.isPointLightShadow || this.type !== S || P(v, c);
              } else console.warn("THREE.WebGLShadowMap:", m, "has no shadow.");
            }
            (L.needsUpdate = !1), t.setRenderTarget(u, l, h);
          }
        });
    }
    function Ca(t, e, n, r) {
      var i = new (function () {
          var e = !1,
            n = new en(),
            r = null,
            i = new en(0, 0, 0, 0);
          return {
            setMask: function (n) {
              r === n || e || (t.colorMask(n, n, n, n), (r = n));
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e, r, o, a, s) {
              !0 === s && ((e *= a), (r *= a), (o *= a)),
                n.set(e, r, o, a),
                !1 === i.equals(n) && (t.clearColor(e, r, o, a), i.copy(n));
            },
            reset: function () {
              (e = !1), (r = null), i.set(-1, 0, 0, 0);
            },
          };
        })(),
        o = new (function () {
          var e = !1,
            n = null,
            r = null,
            i = null;
          return {
            setTest: function (t) {
              t ? Q(2929) : K(2929);
            },
            setMask: function (r) {
              n === r || e || (t.depthMask(r), (n = r));
            },
            setFunc: function (e) {
              if (r !== e) {
                if (e)
                  switch (e) {
                    case $:
                      t.depthFunc(512);
                      break;
                    case tt:
                      t.depthFunc(519);
                      break;
                    case et:
                      t.depthFunc(513);
                      break;
                    case nt:
                      t.depthFunc(515);
                      break;
                    case rt:
                      t.depthFunc(514);
                      break;
                    case it:
                      t.depthFunc(518);
                      break;
                    case ot:
                      t.depthFunc(516);
                      break;
                    case at:
                      t.depthFunc(517);
                      break;
                    default:
                      t.depthFunc(515);
                  }
                else t.depthFunc(515);
                r = e;
              }
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e) {
              i !== e && (t.clearDepth(e), (i = e));
            },
            reset: function () {
              (e = !1), (n = null), (r = null), (i = null);
            },
          };
        })(),
        a = new (function () {
          var e = !1,
            n = null,
            r = null,
            i = null,
            o = null,
            a = null,
            s = null,
            c = null,
            u = null;
          return {
            setTest: function (t) {
              e || (t ? Q(2960) : K(2960));
            },
            setMask: function (r) {
              n === r || e || (t.stencilMask(r), (n = r));
            },
            setFunc: function (e, n, a) {
              (r === e && i === n && o === a) ||
                (t.stencilFunc(e, n, a), (r = e), (i = n), (o = a));
            },
            setOp: function (e, n, r) {
              (a === e && s === n && c === r) ||
                (t.stencilOp(e, n, r), (a = e), (s = n), (c = r));
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e) {
              u !== e && (t.clearStencil(e), (u = e));
            },
            reset: function () {
              (e = !1),
                (n = null),
                (r = null),
                (i = null),
                (o = null),
                (a = null),
                (s = null),
                (c = null),
                (u = null);
            },
          };
        })(),
        s = t.getParameter(34921),
        c = new Uint8Array(s),
        u = new Uint8Array(s),
        l = new Uint8Array(s),
        h = {},
        p = null,
        f = null,
        d = null,
        m = null,
        v = null,
        g = null,
        y = null,
        _ = null,
        M = null,
        S = null,
        E = !1,
        L = null,
        P = null,
        R = null,
        U = null,
        B = null,
        G = t.getParameter(35661),
        j = !1,
        V = 0,
        H = t.getParameter(7938);
      -1 !== H.indexOf("WebGL")
        ? ((V = parseFloat(/^WebGL\ ([0-9])/.exec(H)[1])), (j = V >= 1))
        : -1 !== H.indexOf("OpenGL ES") &&
          ((V = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(H)[1])), (j = V >= 2));
      var k = null,
        W = {},
        q = new en(),
        X = new en();
      function Y(e, n, r) {
        var i = new Uint8Array(4),
          o = t.createTexture();
        t.bindTexture(e, o),
          t.texParameteri(e, 10241, 9728),
          t.texParameteri(e, 10240, 9728);
        for (var a = 0; a < r; a++)
          t.texImage2D(n + a, 0, 6408, 1, 1, 0, 6408, 5121, i);
        return o;
      }
      var J = {};
      function Z(n, i) {
        ((c[n] = 1),
        0 === u[n] && (t.enableVertexAttribArray(n), (u[n] = 1)),
        l[n] !== i) &&
          ((r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
            r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
          ](n, i),
          (l[n] = i));
      }
      function Q(e) {
        !0 !== h[e] && (t.enable(e), (h[e] = !0));
      }
      function K(e) {
        !1 !== h[e] && (t.disable(e), (h[e] = !1));
      }
      function st(e, r, i, o, a, s, c, u) {
        if (e !== C) {
          if ((d || (Q(3042), (d = !0)), e === z))
            (a = a || r),
              (s = s || i),
              (c = c || o),
              (r === v && a === _) ||
                (t.blendEquationSeparate(n.convert(r), n.convert(a)),
                (v = r),
                (_ = a)),
              (i === g && o === y && s === M && c === S) ||
                (t.blendFuncSeparate(
                  n.convert(i),
                  n.convert(o),
                  n.convert(s),
                  n.convert(c)
                ),
                (g = i),
                (y = o),
                (M = s),
                (S = c)),
              (m = e),
              (E = null);
          else if (e !== m || u !== E) {
            if (
              ((v === F && _ === F) ||
                (t.blendEquation(32774), (v = F), (_ = F)),
              u)
            )
              switch (e) {
                case O:
                  t.blendFuncSeparate(1, 771, 1, 771);
                  break;
                case I:
                  t.blendFunc(1, 1);
                  break;
                case N:
                  t.blendFuncSeparate(0, 0, 769, 771);
                  break;
                case D:
                  t.blendFuncSeparate(0, 768, 0, 770);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", e);
              }
            else
              switch (e) {
                case O:
                  t.blendFuncSeparate(770, 771, 1, 771);
                  break;
                case I:
                  t.blendFunc(770, 1);
                  break;
                case N:
                  t.blendFunc(0, 769);
                  break;
                case D:
                  t.blendFunc(0, 768);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", e);
              }
            (g = null), (y = null), (M = null), (S = null), (m = e), (E = u);
          }
        } else d && (K(3042), (d = !1));
      }
      function ct(e) {
        L !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (L = e));
      }
      function ut(e) {
        e !== x
          ? (Q(2884),
            e !== P &&
              (e === b
                ? t.cullFace(1029)
                : e === w
                ? t.cullFace(1028)
                : t.cullFace(1032)))
          : K(2884),
          (P = e);
      }
      function lt(e, n, r) {
        e
          ? (Q(32823),
            (U === n && B === r) || (t.polygonOffset(n, r), (U = n), (B = r)))
          : K(32823);
      }
      function ht(e) {
        void 0 === e && (e = 33984 + G - 1),
          k !== e && (t.activeTexture(e), (k = e));
      }
      return (
        (J[3553] = Y(3553, 3553, 1)),
        (J[34067] = Y(34067, 34069, 6)),
        i.setClear(0, 0, 0, 1),
        o.setClear(1),
        a.setClear(0),
        Q(2929),
        o.setFunc(nt),
        ct(!1),
        ut(b),
        Q(2884),
        st(C),
        {
          buffers: { color: i, depth: o, stencil: a },
          initAttributes: function () {
            for (var t = 0, e = c.length; t < e; t++) c[t] = 0;
          },
          enableAttribute: function (t) {
            Z(t, 0);
          },
          enableAttributeAndDivisor: Z,
          disableUnusedAttributes: function () {
            for (var e = 0, n = u.length; e !== n; ++e)
              u[e] !== c[e] && (t.disableVertexAttribArray(e), (u[e] = 0));
          },
          enable: Q,
          disable: K,
          getCompressedTextureFormats: function () {
            if (
              null === p &&
              ((p = []),
              e.get("WEBGL_compressed_texture_pvrtc") ||
                e.get("WEBGL_compressed_texture_s3tc") ||
                e.get("WEBGL_compressed_texture_etc1") ||
                e.get("WEBGL_compressed_texture_astc"))
            )
              for (var n = t.getParameter(34467), r = 0; r < n.length; r++)
                p.push(n[r]);
            return p;
          },
          useProgram: function (e) {
            return f !== e && (t.useProgram(e), (f = e), !0);
          },
          setBlending: st,
          setMaterial: function (t, e) {
            t.side === A ? K(2884) : Q(2884);
            var n = t.side === T;
            e && (n = !n),
              ct(n),
              t.blending === O && !1 === t.transparent
                ? st(C)
                : st(
                    t.blending,
                    t.blendEquation,
                    t.blendSrc,
                    t.blendDst,
                    t.blendEquationAlpha,
                    t.blendSrcAlpha,
                    t.blendDstAlpha,
                    t.premultipliedAlpha
                  ),
              o.setFunc(t.depthFunc),
              o.setTest(t.depthTest),
              o.setMask(t.depthWrite),
              i.setMask(t.colorWrite);
            var r = t.stencilWrite;
            a.setTest(r),
              r &&
                (a.setMask(t.stencilWriteMask),
                a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
              lt(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits);
          },
          setFlipSided: ct,
          setCullFace: ut,
          setLineWidth: function (e) {
            e !== R && (j && t.lineWidth(e), (R = e));
          },
          setPolygonOffset: lt,
          setScissorTest: function (t) {
            t ? Q(3089) : K(3089);
          },
          activeTexture: ht,
          bindTexture: function (e, n) {
            null === k && ht();
            var r = W[k];
            void 0 === r &&
              ((r = { type: void 0, texture: void 0 }), (W[k] = r)),
              (r.type === e && r.texture === n) ||
                (t.bindTexture(e, n || J[e]), (r.type = e), (r.texture = n));
          },
          compressedTexImage2D: function () {
            try {
              t.compressedTexImage2D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texImage2D: function () {
            try {
              t.texImage2D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texImage3D: function () {
            try {
              t.texImage3D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          scissor: function (e) {
            !1 === q.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), q.copy(e));
          },
          viewport: function (e) {
            !1 === X.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), X.copy(e));
          },
          reset: function () {
            for (var e = 0; e < u.length; e++)
              1 === u[e] && (t.disableVertexAttribArray(e), (u[e] = 0));
            (h = {}),
              (p = null),
              (k = null),
              (W = {}),
              (f = null),
              (m = null),
              (L = null),
              (P = null),
              i.reset(),
              o.reset(),
              a.reset();
          },
        }
      );
    }
    function Oa(t, e, n, r, i, o, a) {
      var s,
        c = new WeakMap(),
        u =
          "undefined" != typeof OffscreenCanvas &&
          null !== new OffscreenCanvas(1, 1).getContext("2d");
      function l(t, e) {
        return u
          ? new OffscreenCanvas(t, e)
          : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      }
      function h(t, e, n, r) {
        var i = 1;
        if (
          ((t.width > r || t.height > r) &&
            (i = r / Math.max(t.width, t.height)),
          i < 1 || !0 === e)
        ) {
          if (
            ("undefined" != typeof HTMLImageElement &&
              t instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement &&
              t instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
          ) {
            var o = e ? He.floorPowerOfTwo : Math.floor,
              a = o(i * t.width),
              c = o(i * t.height);
            void 0 === s && (s = l(a, c));
            var u = n ? l(a, c) : s;
            return (
              (u.width = a),
              (u.height = c),
              u.getContext("2d").drawImage(t, 0, 0, a, c),
              console.warn(
                "THREE.WebGLRenderer: Texture has been resized from (" +
                  t.width +
                  "x" +
                  t.height +
                  ") to (" +
                  a +
                  "x" +
                  c +
                  ")."
              ),
              u
            );
          }
          return (
            "data" in t &&
              console.warn(
                "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                  t.width +
                  "x" +
                  t.height +
                  ")."
              ),
            t
          );
        }
        return t;
      }
      function p(t) {
        return He.isPowerOfTwo(t.width) && He.isPowerOfTwo(t.height);
      }
      function f(t, e) {
        return (
          t.generateMipmaps && e && t.minFilter !== Tt && t.minFilter !== Pt
        );
      }
      function d(e, n, i, o) {
        t.generateMipmap(e),
          (r.get(n).__maxMipLevel = Math.log(Math.max(i, o)) * Math.LOG2E);
      }
      function m(t, n) {
        if (!i.isWebGL2) return t;
        var r = t;
        return (
          6403 === t &&
            (5126 === n && (r = 33326),
            5131 === n && (r = 33325),
            5121 === n && (r = 33321)),
          6407 === t &&
            (5126 === n && (r = 34837),
            5131 === n && (r = 34843),
            5121 === n && (r = 32849)),
          6408 === t &&
            (5126 === n && (r = 34836),
            5131 === n && (r = 34842),
            5121 === n && (r = 32856)),
          33325 === r || 33326 === r || 34842 === r || 34836 === r
            ? e.get("EXT_color_buffer_float")
            : (34843 !== r && 34837 !== r) ||
              console.warn(
                "THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."
              ),
          r
        );
      }
      function v(t) {
        return t === Tt || t === At || t === Lt ? 9728 : 9729;
      }
      function g(e) {
        var n = e.target;
        n.removeEventListener("dispose", g),
          (function (e) {
            var n = r.get(e);
            if (void 0 === n.__webglInit) return;
            t.deleteTexture(n.__webglTexture), r.remove(e);
          })(n),
          n.isVideoTexture && c.delete(n),
          a.memory.textures--;
      }
      function y(e) {
        var n = e.target;
        n.removeEventListener("dispose", y),
          (function (e) {
            var n = r.get(e),
              i = r.get(e.texture);
            if (!e) return;
            void 0 !== i.__webglTexture && t.deleteTexture(i.__webglTexture);
            e.depthTexture && e.depthTexture.dispose();
            if (e.isWebGLRenderTargetCube)
              for (var o = 0; o < 6; o++)
                t.deleteFramebuffer(n.__webglFramebuffer[o]),
                  n.__webglDepthbuffer &&
                    t.deleteRenderbuffer(n.__webglDepthbuffer[o]);
            else
              t.deleteFramebuffer(n.__webglFramebuffer),
                n.__webglDepthbuffer &&
                  t.deleteRenderbuffer(n.__webglDepthbuffer);
            if (e.isWebGLMultiviewRenderTarget) {
              t.deleteTexture(n.__webglColorTexture),
                t.deleteTexture(n.__webglDepthStencilTexture),
                (a.memory.textures -= 2);
              o = 0;
              for (var s = n.__webglViewFramebuffers.length; o < s; o++)
                t.deleteFramebuffer(n.__webglViewFramebuffers[o]);
            }
            r.remove(e.texture), r.remove(e);
          })(n),
          a.memory.textures--;
      }
      var x = 0;
      function b(t, e) {
        var i = r.get(t);
        if (
          (t.isVideoTexture &&
            (function (t) {
              var e = a.render.frame;
              c.get(t) !== e && (c.set(t, e), t.update());
            })(t),
          t.version > 0 && i.__version !== t.version)
        ) {
          var o = t.image;
          if (void 0 === o)
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is undefined"
            );
          else {
            if (!1 !== o.complete) return void E(i, t, e);
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
            );
          }
        }
        n.activeTexture(33984 + e), n.bindTexture(3553, i.__webglTexture);
      }
      function w(e, a) {
        if (6 === e.image.length) {
          var s = r.get(e);
          if (e.version > 0 && s.__version !== e.version) {
            S(s, e),
              n.activeTexture(33984 + a),
              n.bindTexture(34067, s.__webglTexture),
              t.pixelStorei(37440, e.flipY);
            for (
              var c = e && e.isCompressedTexture,
                u = e.image[0] && e.image[0].isDataTexture,
                l = [],
                v = 0;
              v < 6;
              v++
            )
              l[v] =
                c || u
                  ? u
                    ? e.image[v].image
                    : e.image[v]
                  : h(e.image[v], !1, !0, i.maxCubemapSize);
            var g,
              y = l[0],
              x = p(y) || i.isWebGL2,
              b = o.convert(e.format),
              w = o.convert(e.type),
              _ = m(b, w);
            if ((M(34067, e, x), c)) {
              for (v = 0; v < 6; v++) {
                g = l[v].mipmaps;
                for (var E = 0; E < g.length; E++) {
                  var T = g[E];
                  e.format !== qt && e.format !== Wt
                    ? n.getCompressedTextureFormats().indexOf(b) > -1
                      ? n.compressedTexImage2D(
                          34069 + v,
                          E,
                          _,
                          T.width,
                          T.height,
                          0,
                          T.data
                        )
                      : console.warn(
                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                        )
                    : n.texImage2D(
                        34069 + v,
                        E,
                        _,
                        T.width,
                        T.height,
                        0,
                        b,
                        w,
                        T.data
                      );
                }
              }
              s.__maxMipLevel = g.length - 1;
            } else {
              g = e.mipmaps;
              for (v = 0; v < 6; v++)
                if (u) {
                  n.texImage2D(
                    34069 + v,
                    0,
                    _,
                    l[v].width,
                    l[v].height,
                    0,
                    b,
                    w,
                    l[v].data
                  );
                  for (E = 0; E < g.length; E++) {
                    var A = (T = g[E]).image[v].image;
                    n.texImage2D(
                      34069 + v,
                      E + 1,
                      _,
                      A.width,
                      A.height,
                      0,
                      b,
                      w,
                      A.data
                    );
                  }
                } else {
                  n.texImage2D(34069 + v, 0, _, b, w, l[v]);
                  for (E = 0; E < g.length; E++) {
                    T = g[E];
                    n.texImage2D(34069 + v, E + 1, _, b, w, T.image[v]);
                  }
                }
              s.__maxMipLevel = g.length;
            }
            f(e, x) && d(34067, e, y.width, y.height),
              (s.__version = e.version),
              e.onUpdate && e.onUpdate(e);
          } else
            n.activeTexture(33984 + a), n.bindTexture(34067, s.__webglTexture);
        }
      }
      function _(t, e) {
        n.activeTexture(33984 + e),
          n.bindTexture(34067, r.get(t).__webglTexture);
      }
      function M(n, a, s) {
        var c;
        if (
          (s
            ? (t.texParameteri(n, 10242, o.convert(a.wrapS)),
              t.texParameteri(n, 10243, o.convert(a.wrapT)),
              (32879 !== n && 35866 !== n) ||
                t.texParameteri(n, 32882, o.convert(a.wrapR)),
              t.texParameteri(n, 10240, o.convert(a.magFilter)),
              t.texParameteri(n, 10241, o.convert(a.minFilter)))
            : (t.texParameteri(n, 10242, 33071),
              t.texParameteri(n, 10243, 33071),
              (32879 !== n && 35866 !== n) || t.texParameteri(n, 32882, 33071),
              (a.wrapS === St && a.wrapT === St) ||
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                ),
              t.texParameteri(n, 10240, v(a.magFilter)),
              t.texParameteri(n, 10241, v(a.minFilter)),
              a.minFilter !== Tt &&
                a.minFilter !== Pt &&
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                )),
          (c = e.get("EXT_texture_filter_anisotropic")))
        ) {
          if (a.type === Ut && null === e.get("OES_texture_float_linear"))
            return;
          if (
            a.type === Bt &&
            null === (i.isWebGL2 || e.get("OES_texture_half_float_linear"))
          )
            return;
          (a.anisotropy > 1 || r.get(a).__currentAnisotropy) &&
            (t.texParameterf(
              n,
              c.TEXTURE_MAX_ANISOTROPY_EXT,
              Math.min(a.anisotropy, i.getMaxAnisotropy())
            ),
            (r.get(a).__currentAnisotropy = a.anisotropy));
        }
      }
      function S(e, n) {
        void 0 === e.__webglInit &&
          ((e.__webglInit = !0),
          n.addEventListener("dispose", g),
          (e.__webglTexture = t.createTexture()),
          a.memory.textures++);
      }
      function E(e, r, a) {
        var s = 3553;
        r.isDataTexture2DArray && (s = 35866),
          r.isDataTexture3D && (s = 32879),
          S(e, r),
          n.activeTexture(33984 + a),
          n.bindTexture(s, e.__webglTexture),
          t.pixelStorei(37440, r.flipY),
          t.pixelStorei(37441, r.premultiplyAlpha),
          t.pixelStorei(3317, r.unpackAlignment);
        var c =
            (function (t) {
              return (
                !i.isWebGL2 &&
                (t.wrapS !== St ||
                  t.wrapT !== St ||
                  (t.minFilter !== Tt && t.minFilter !== Pt))
              );
            })(r) && !1 === p(r.image),
          u = h(r.image, c, !1, i.maxTextureSize),
          l = p(u) || i.isWebGL2,
          v = o.convert(r.format),
          g = o.convert(r.type),
          y = m(v, g);
        M(s, r, l);
        var x,
          b = r.mipmaps;
        if (r.isDepthTexture) {
          if (((y = 6402), r.type === Ut)) {
            if (!i.isWebGL2)
              throw new Error("Float Depth Texture only supported in WebGL2.0");
            y = 36012;
          } else i.isWebGL2 && (y = 33189);
          r.format === Jt &&
            6402 === y &&
            r.type !== Dt &&
            r.type !== Ft &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (r.type = Dt),
            (g = o.convert(r.type))),
            r.format === Zt &&
              ((y = 34041),
              r.type !== Ht &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                ),
                (r.type = Ht),
                (g = o.convert(r.type)))),
            n.texImage2D(3553, 0, y, u.width, u.height, 0, v, g, null);
        } else if (r.isDataTexture)
          if (b.length > 0 && l) {
            for (var w = 0, _ = b.length; w < _; w++)
              (x = b[w]),
                n.texImage2D(3553, w, y, x.width, x.height, 0, v, g, x.data);
            (r.generateMipmaps = !1), (e.__maxMipLevel = b.length - 1);
          } else
            n.texImage2D(3553, 0, y, u.width, u.height, 0, v, g, u.data),
              (e.__maxMipLevel = 0);
        else if (r.isCompressedTexture) {
          for (w = 0, _ = b.length; w < _; w++)
            (x = b[w]),
              r.format !== qt && r.format !== Wt
                ? n.getCompressedTextureFormats().indexOf(v) > -1
                  ? n.compressedTexImage2D(
                      3553,
                      w,
                      y,
                      x.width,
                      x.height,
                      0,
                      x.data
                    )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : n.texImage2D(3553, w, y, x.width, x.height, 0, v, g, x.data);
          e.__maxMipLevel = b.length - 1;
        } else if (r.isDataTexture2DArray)
          n.texImage3D(
            35866,
            0,
            y,
            u.width,
            u.height,
            u.depth,
            0,
            v,
            g,
            u.data
          ),
            (e.__maxMipLevel = 0);
        else if (r.isDataTexture3D)
          n.texImage3D(
            32879,
            0,
            y,
            u.width,
            u.height,
            u.depth,
            0,
            v,
            g,
            u.data
          ),
            (e.__maxMipLevel = 0);
        else if (b.length > 0 && l) {
          for (w = 0, _ = b.length; w < _; w++)
            (x = b[w]), n.texImage2D(3553, w, y, v, g, x);
          (r.generateMipmaps = !1), (e.__maxMipLevel = b.length - 1);
        } else n.texImage2D(3553, 0, y, v, g, u), (e.__maxMipLevel = 0);
        f(r, l) && d(3553, r, u.width, u.height),
          (e.__version = r.version),
          r.onUpdate && r.onUpdate(r);
      }
      function T(e, i, a, s) {
        var c = o.convert(i.texture.format),
          u = o.convert(i.texture.type),
          l = m(c, u);
        n.texImage2D(s, 0, l, i.width, i.height, 0, c, u, null),
          t.bindFramebuffer(36160, e),
          t.framebufferTexture2D(
            36160,
            a,
            s,
            r.get(i.texture).__webglTexture,
            0
          ),
          t.bindFramebuffer(36160, null);
      }
      function A(e, n, r) {
        if ((t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)) {
          if (r) {
            var i = P(n);
            t.renderbufferStorageMultisample(
              36161,
              i,
              33189,
              n.width,
              n.height
            );
          } else t.renderbufferStorage(36161, 33189, n.width, n.height);
          t.framebufferRenderbuffer(36160, 36096, 36161, e);
        } else if (n.depthBuffer && n.stencilBuffer) {
          if (r) {
            i = P(n);
            t.renderbufferStorageMultisample(
              36161,
              i,
              35056,
              n.width,
              n.height
            );
          } else t.renderbufferStorage(36161, 34041, n.width, n.height);
          t.framebufferRenderbuffer(36160, 33306, 36161, e);
        } else {
          var a = m(o.convert(n.texture.format), o.convert(n.texture.type));
          if (r) {
            i = P(n);
            t.renderbufferStorageMultisample(36161, i, a, n.width, n.height);
          } else t.renderbufferStorage(36161, a, n.width, n.height);
        }
        t.bindRenderbuffer(36161, null);
      }
      function L(e) {
        var n = r.get(e),
          i = !0 === e.isWebGLRenderTargetCube;
        if (e.depthTexture) {
          if (i)
            throw new Error(
              "target.depthTexture not supported in Cube render targets"
            );
          !(function (e, n) {
            if (n && n.isWebGLRenderTargetCube)
              throw new Error(
                "Depth Texture with cube render targets is not supported"
              );
            if (
              (t.bindFramebuffer(36160, e),
              !n.depthTexture || !n.depthTexture.isDepthTexture)
            )
              throw new Error(
                "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
              );
            (r.get(n.depthTexture).__webglTexture &&
              n.depthTexture.image.width === n.width &&
              n.depthTexture.image.height === n.height) ||
              ((n.depthTexture.image.width = n.width),
              (n.depthTexture.image.height = n.height),
              (n.depthTexture.needsUpdate = !0)),
              b(n.depthTexture, 0);
            var i = r.get(n.depthTexture).__webglTexture;
            if (n.depthTexture.format === Jt)
              t.framebufferTexture2D(36160, 36096, 3553, i, 0);
            else {
              if (n.depthTexture.format !== Zt)
                throw new Error("Unknown depthTexture format");
              t.framebufferTexture2D(36160, 33306, 3553, i, 0);
            }
          })(n.__webglFramebuffer, e);
        } else if (i) {
          n.__webglDepthbuffer = [];
          for (var o = 0; o < 6; o++)
            t.bindFramebuffer(36160, n.__webglFramebuffer[o]),
              (n.__webglDepthbuffer[o] = t.createRenderbuffer()),
              A(n.__webglDepthbuffer[o], e);
        } else
          t.bindFramebuffer(36160, n.__webglFramebuffer),
            (n.__webglDepthbuffer = t.createRenderbuffer()),
            A(n.__webglDepthbuffer, e);
        t.bindFramebuffer(36160, null);
      }
      function P(t) {
        return i.isWebGL2 && t.isWebGLMultisampleRenderTarget
          ? Math.min(i.maxSamples, t.samples)
          : 0;
      }
      var R = !1,
        C = !1;
      (this.allocateTextureUnit = function () {
        var t = x;
        return (
          t >= i.maxTextures &&
            console.warn(
              "THREE.WebGLTextures: Trying to use " +
                t +
                " texture units while this GPU supports only " +
                i.maxTextures
            ),
          (x += 1),
          t
        );
      }),
        (this.resetTextureUnits = function () {
          x = 0;
        }),
        (this.setTexture2D = b),
        (this.setTexture2DArray = function (t, e) {
          var i = r.get(t);
          t.version > 0 && i.__version !== t.version
            ? E(i, t, e)
            : (n.activeTexture(33984 + e),
              n.bindTexture(35866, i.__webglTexture));
        }),
        (this.setTexture3D = function (t, e) {
          var i = r.get(t);
          t.version > 0 && i.__version !== t.version
            ? E(i, t, e)
            : (n.activeTexture(33984 + e),
              n.bindTexture(32879, i.__webglTexture));
        }),
        (this.setTextureCube = w),
        (this.setTextureCubeDynamic = _),
        (this.setupRenderTarget = function (s) {
          var c = r.get(s),
            u = r.get(s.texture);
          s.addEventListener("dispose", y),
            (u.__webglTexture = t.createTexture()),
            a.memory.textures++;
          var l = !0 === s.isWebGLRenderTargetCube,
            h = !0 === s.isWebGLMultisampleRenderTarget,
            v = !0 === s.isWebGLMultiviewRenderTarget,
            g = p(s) || i.isWebGL2;
          if (l) {
            c.__webglFramebuffer = [];
            for (var x = 0; x < 6; x++)
              c.__webglFramebuffer[x] = t.createFramebuffer();
          } else if (((c.__webglFramebuffer = t.createFramebuffer()), h))
            if (i.isWebGL2) {
              (c.__webglMultisampledFramebuffer = t.createFramebuffer()),
                (c.__webglColorRenderbuffer = t.createRenderbuffer()),
                t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
              var b = m(o.convert(s.texture.format), o.convert(s.texture.type)),
                w = P(s);
              t.renderbufferStorageMultisample(36161, w, b, s.width, s.height),
                t.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                t.framebufferRenderbuffer(
                  36160,
                  36064,
                  36161,
                  c.__webglColorRenderbuffer
                ),
                t.bindRenderbuffer(36161, null),
                s.depthBuffer &&
                  ((c.__webglDepthRenderbuffer = t.createRenderbuffer()),
                  A(c.__webglDepthRenderbuffer, s, !0)),
                t.bindFramebuffer(36160, null);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
          else if (v) {
            var _ = s.width,
              S = s.height,
              E = s.numViews;
            t.bindFramebuffer(36160, c.__webglFramebuffer);
            var R = e.get("OVR_multiview2");
            a.memory.textures += 2;
            var C = t.createTexture();
            t.bindTexture(35866, C),
              t.texParameteri(35866, 10240, 9728),
              t.texParameteri(35866, 10241, 9728),
              t.texImage3D(35866, 0, 32856, _, S, E, 0, 6408, 5121, null),
              R.framebufferTextureMultiviewOVR(36160, 36064, C, 0, 0, E);
            var O = t.createTexture();
            t.bindTexture(35866, O),
              t.texParameteri(35866, 10240, 9728),
              t.texParameteri(35866, 10241, 9728),
              t.texImage3D(35866, 0, 35056, _, S, E, 0, 34041, 34042, null),
              R.framebufferTextureMultiviewOVR(36160, 33306, O, 0, 0, E);
            var I = new Array(E);
            for (x = 0; x < E; ++x)
              (I[x] = t.createFramebuffer()),
                t.bindFramebuffer(36160, I[x]),
                t.framebufferTextureLayer(36160, 36064, C, 0, x);
            (c.__webglColorTexture = C),
              (c.__webglDepthStencilTexture = O),
              (c.__webglViewFramebuffers = I),
              t.bindFramebuffer(36160, null),
              t.bindTexture(35866, null);
          }
          if (l) {
            n.bindTexture(34067, u.__webglTexture), M(34067, s.texture, g);
            for (x = 0; x < 6; x++)
              T(c.__webglFramebuffer[x], s, 36064, 34069 + x);
            f(s.texture, g) && d(34067, s.texture, s.width, s.height),
              n.bindTexture(34067, null);
          } else
            v ||
              (n.bindTexture(3553, u.__webglTexture),
              M(3553, s.texture, g),
              T(c.__webglFramebuffer, s, 36064, 3553),
              f(s.texture, g) && d(3553, s.texture, s.width, s.height),
              n.bindTexture(3553, null));
          s.depthBuffer && L(s);
        }),
        (this.updateRenderTargetMipmap = function (t) {
          var e = t.texture;
          if (f(e, p(t) || i.isWebGL2)) {
            var o = t.isWebGLRenderTargetCube ? 34067 : 3553,
              a = r.get(e).__webglTexture;
            n.bindTexture(o, a),
              d(o, e, t.width, t.height),
              n.bindTexture(o, null);
          }
        }),
        (this.updateMultisampleRenderTarget = function (e) {
          if (e.isWebGLMultisampleRenderTarget)
            if (i.isWebGL2) {
              var n = r.get(e);
              t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer),
                t.bindFramebuffer(36009, n.__webglFramebuffer);
              var o = e.width,
                a = e.height,
                s = 16384;
              e.depthBuffer && (s |= 256),
                e.stencilBuffer && (s |= 1024),
                t.blitFramebuffer(0, 0, o, a, 0, 0, o, a, s, 9728);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
        }),
        (this.safeSetTexture2D = function (t, e) {
          t &&
            t.isWebGLRenderTarget &&
            (!1 === R &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
              ),
              (R = !0)),
            (t = t.texture)),
            b(t, e);
        }),
        (this.safeSetTextureCube = function (t, e) {
          t &&
            t.isWebGLRenderTargetCube &&
            (!1 === C &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
              ),
              (C = !0)),
            (t = t.texture)),
            (t && t.isCubeTexture) ||
            (Array.isArray(t.image) && 6 === t.image.length)
              ? w(t, e)
              : _(t, e);
        });
    }
    function Ia(t, e, n) {
      return {
        convert: function (t) {
          var r;
          if (t === Mt) return 10497;
          if (t === St) return 33071;
          if (t === Et) return 33648;
          if (t === Tt) return 9728;
          if (t === At) return 9984;
          if (t === Lt) return 9986;
          if (t === Pt) return 9729;
          if (t === Rt) return 9985;
          if (t === Ct) return 9987;
          if (t === Ot) return 5121;
          if (t === Gt) return 32819;
          if (t === jt) return 32820;
          if (t === Vt) return 33635;
          if (t === It) return 5120;
          if (t === Nt) return 5122;
          if (t === Dt) return 5123;
          if (t === zt) return 5124;
          if (t === Ft) return 5125;
          if (t === Ut) return 5126;
          if (t === Bt) {
            if (n.isWebGL2) return 5131;
            if (null !== (r = e.get("OES_texture_half_float")))
              return r.HALF_FLOAT_OES;
          }
          if (t === kt) return 6406;
          if (t === Wt) return 6407;
          if (t === qt) return 6408;
          if (t === Xt) return 6409;
          if (t === Yt) return 6410;
          if (t === Jt) return 6402;
          if (t === Zt) return 34041;
          if (t === Qt) return 6403;
          if (t === F) return 32774;
          if (t === U) return 32778;
          if (t === B) return 32779;
          if (t === V) return 0;
          if (t === H) return 1;
          if (t === k) return 768;
          if (t === W) return 769;
          if (t === q) return 770;
          if (t === X) return 771;
          if (t === Y) return 772;
          if (t === J) return 773;
          if (t === Z) return 774;
          if (t === Q) return 775;
          if (t === K) return 776;
          if (
            (t === Kt || t === $t || t === te || t === ee) &&
            null !== (r = e.get("WEBGL_compressed_texture_s3tc"))
          ) {
            if (t === Kt) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (t === $t) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (t === te) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (t === ee) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
          if (
            (t === ne || t === re || t === ie || t === oe) &&
            null !== (r = e.get("WEBGL_compressed_texture_pvrtc"))
          ) {
            if (t === ne) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (t === re) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (t === ie) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (t === oe) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          if (t === ae && null !== (r = e.get("WEBGL_compressed_texture_etc1")))
            return r.COMPRESSED_RGB_ETC1_WEBGL;
          if (
            (t === se ||
              t === ce ||
              t === ue ||
              t === le ||
              t === he ||
              t === pe ||
              t === fe ||
              t === de ||
              t === me ||
              t === ve ||
              t === ge ||
              t === ye ||
              t === xe ||
              t === be) &&
            null !== (r = e.get("WEBGL_compressed_texture_astc"))
          )
            return t;
          if (t === G || t === j) {
            if (n.isWebGL2) {
              if (t === G) return 32775;
              if (t === j) return 32776;
            }
            if (null !== (r = e.get("EXT_blend_minmax"))) {
              if (t === G) return r.MIN_EXT;
              if (t === j) return r.MAX_EXT;
            }
          }
          if (t === Ht) {
            if (n.isWebGL2) return 34042;
            if (null !== (r = e.get("WEBGL_depth_texture")))
              return r.UNSIGNED_INT_24_8_WEBGL;
          }
          return 0;
        },
      };
    }
    function Na(t, e, n, r) {
      nn.call(this, t, e, r),
        (this.depthBuffer = !1),
        (this.stencilBuffer = !1),
        (this.numViews = n);
    }
    function Da(t, e) {
      var n,
        r,
        i,
        o,
        a,
        s,
        c,
        u = 2,
        l = t.extensions,
        h = t.properties,
        p = 0;
      function f(t) {
        return t.isArrayCamera ? t.cameras : ((a[0] = t), a);
      }
      (this.isAvailable = function () {
        if (void 0 === c) {
          var t = l.get("OVR_multiview2");
          if ((c = null !== t && !1 === e.getContextAttributes().antialias)) {
            (p = e.getParameter(t.MAX_VIEWS_OVR)),
              (n = new Na(0, 0, u)),
              (s = new ke()),
              (o = []),
              (i = []),
              (a = []);
            for (var r = 0; r < p; r++) (o[r] = new pn()), (i[r] = new Qe());
          }
        }
        return c;
      }),
        (this.attachCamera = function (e) {
          !1 !==
            (function (t) {
              if (void 0 === t.isArrayCamera) return !0;
              var e = t.cameras;
              if (e.length > p) return !1;
              for (var n = 1, r = e.length; n < r; n++)
                if (
                  e[0].viewport.z !== e[n].viewport.z ||
                  e[0].viewport.w !== e[n].viewport.w
                )
                  return !1;
              return !0;
            })(e) &&
            ((r = t.getRenderTarget()),
            (function (e) {
              if (
                (r ? s.set(r.width, r.height) : t.getDrawingBufferSize(s),
                e.isArrayCamera)
              ) {
                var i = e.cameras[0].viewport;
                n.setSize(i.z, i.w), n.setNumViews(e.cameras.length);
              } else n.setSize(s.x, s.y), n.setNumViews(u);
            })(e),
            t.setRenderTarget(n));
        }),
        (this.detachCamera = function (i) {
          n === t.getRenderTarget() &&
            (t.setRenderTarget(r),
            (function (t) {
              var r = n,
                i = r.numViews,
                o = h.get(r).__webglViewFramebuffers,
                a = r.width,
                c = r.height;
              if (t.isArrayCamera)
                for (var u = 0; u < i; u++) {
                  var l = t.cameras[u].viewport,
                    p = l.x,
                    f = l.y,
                    d = p + l.z,
                    m = f + l.w;
                  e.bindFramebuffer(36008, o[u]),
                    e.blitFramebuffer(0, 0, a, c, p, f, d, m, 16384, 9728);
                }
              else
                e.bindFramebuffer(36008, o[0]),
                  e.blitFramebuffer(0, 0, a, c, 0, 0, s.x, s.y, 16384, 9728);
            })(i));
        }),
        (this.updateCameraProjectionMatricesUniform = function (t, n) {
          for (var r = f(t), i = 0; i < r.length; i++)
            o[i].copy(r[i].projectionMatrix);
          n.setValue(e, "projectionMatrices", o);
        }),
        (this.updateCameraViewMatricesUniform = function (t, n) {
          for (var r = f(t), i = 0; i < r.length; i++)
            o[i].copy(r[i].matrixWorldInverse);
          n.setValue(e, "viewMatrices", o);
        }),
        (this.updateObjectMatricesUniforms = function (t, n, r) {
          for (var a = f(n), s = 0; s < a.length; s++)
            o[s].multiplyMatrices(a[s].matrixWorldInverse, t.matrixWorld),
              i[s].getNormalMatrix(o[s]);
          r.setValue(e, "modelViewMatrices", o),
            r.setValue(e, "normalMatrices", i);
        });
    }
    function za() {
      Rn.call(this), (this.type = "Group");
    }
    function Fa(t) {
      _i.call(this), (this.cameras = t || []);
    }
    (Na.prototype = Object.assign(Object.create(nn.prototype), {
      constructor: Na,
      isWebGLMultiviewRenderTarget: !0,
      copy: function (t) {
        return (
          nn.prototype.copy.call(this, t), (this.numViews = t.numViews), this
        );
      },
      setNumViews: function (t) {
        return (
          this.numViews !== t && ((this.numViews = t), this.dispose()), this
        );
      },
    })),
      (za.prototype = Object.assign(Object.create(Rn.prototype), {
        constructor: za,
        isGroup: !0,
      })),
      (Fa.prototype = Object.assign(Object.create(_i.prototype), {
        constructor: Fa,
        isArrayCamera: !0,
      }));
    var Ua,
      Ba = new Ye(),
      Ga = new Ye();
    function ja(t, e, n) {
      Ba.setFromMatrixPosition(e.matrixWorld),
        Ga.setFromMatrixPosition(n.matrixWorld);
      var r = Ba.distanceTo(Ga),
        i = e.projectionMatrix.elements,
        o = n.projectionMatrix.elements,
        a = i[14] / (i[10] - 1),
        s = i[14] / (i[10] + 1),
        c = (i[9] + 1) / i[5],
        u = (i[9] - 1) / i[5],
        l = (i[8] - 1) / i[0],
        h = (o[8] + 1) / o[0],
        p = a * l,
        f = a * h,
        d = r / (-l + h),
        m = d * -l;
      e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
        t.translateX(m),
        t.translateZ(d),
        t.matrixWorld.compose(t.position, t.quaternion, t.scale),
        t.matrixWorldInverse.getInverse(t.matrixWorld);
      var v = a + d,
        g = s + d,
        y = p - m,
        x = f + (r - m),
        b = ((c * s) / g) * v,
        w = ((u * s) / g) * v;
      t.projectionMatrix.makePerspective(y, x, b, w, v, g);
    }
    function Va(t) {
      var e,
        n,
        r = this,
        i = null,
        o = null,
        a = null,
        s = [],
        c = new pn(),
        u = new pn(),
        l = 1,
        h = "local-floor";
      "undefined" != typeof window &&
        "VRFrameData" in window &&
        ((o = new window.VRFrameData()),
        window.addEventListener("vrdisplaypresentchange", w, !1));
      var p = new pn(),
        f = new We(),
        d = new Ye(),
        m = new _i();
      (m.viewport = new en()), m.layers.enable(1);
      var v = new _i();
      (v.viewport = new en()), v.layers.enable(2);
      var g = new Fa([m, v]);
      function y() {
        return null !== i && !0 === i.isPresenting;
      }
      g.layers.enable(1), g.layers.enable(2);
      var x,
        b = new ke();
      function w() {
        if (y()) {
          var o = i.getEyeParameters("left");
          (e = 2 * o.renderWidth * l),
            (n = o.renderHeight * l),
            (x = t.getPixelRatio()),
            t.getSize(b),
            t.setDrawingBufferSize(e, n, 1),
            m.viewport.set(0, 0, e / 2, n),
            v.viewport.set(e / 2, 0, e / 2, n),
            E.start(),
            r.dispatchEvent({ type: "sessionstart" });
        } else
          r.enabled && t.setDrawingBufferSize(b.width, b.height, x),
            E.stop(),
            r.dispatchEvent({ type: "sessionend" });
      }
      var _ = [];
      function M(t) {
        for (
          var e = navigator.getGamepads && navigator.getGamepads(),
            n = 0,
            r = 0,
            i = e.length;
          n < i;
          n++
        ) {
          var o = e[n];
          if (
            o &&
            ("Daydream Controller" === o.id ||
              "Gear VR Controller" === o.id ||
              "Oculus Go Controller" === o.id ||
              "OpenVR Gamepad" === o.id ||
              o.id.startsWith("Oculus Touch") ||
              o.id.startsWith("HTC Vive Focus") ||
              o.id.startsWith("Spatial Controller"))
          ) {
            if (r === t) return o;
            r++;
          }
        }
      }
      function S(t, r) {
        null !== r &&
          4 === r.length &&
          t.set(r[0] * e, r[1] * n, r[2] * e, r[3] * n);
      }
      (this.enabled = !1),
        (this.getController = function (t) {
          var e = s[t];
          return (
            void 0 === e &&
              (((e = new za()).matrixAutoUpdate = !1),
              (e.visible = !1),
              (s[t] = e)),
            e
          );
        }),
        (this.getDevice = function () {
          return i;
        }),
        (this.setDevice = function (t) {
          void 0 !== t && (i = t), E.setContext(t);
        }),
        (this.setFramebufferScaleFactor = function (t) {
          l = t;
        }),
        (this.setReferenceSpaceType = function (t) {
          h = t;
        }),
        (this.setPoseTarget = function (t) {
          void 0 !== t && (a = t);
        }),
        (this.getCamera = function (t) {
          var e = "local-floor" === h ? 1.6 : 0;
          if (!1 === y())
            return t.position.set(0, e, 0), t.rotation.set(0, 0, 0), t;
          if (
            ((i.depthNear = t.near),
            (i.depthFar = t.far),
            i.getFrameData(o),
            "local-floor" === h)
          ) {
            var n = i.stageParameters;
            n
              ? c.fromArray(n.sittingToStandingTransform)
              : c.makeTranslation(0, e, 0);
          }
          var r = o.pose,
            l = null !== a ? a : t;
          l.matrix.copy(c),
            l.matrix.decompose(l.position, l.quaternion, l.scale),
            null !== r.orientation &&
              (f.fromArray(r.orientation), l.quaternion.multiply(f)),
            null !== r.position &&
              (f.setFromRotationMatrix(c),
              d.fromArray(r.position),
              d.applyQuaternion(f),
              l.position.add(d)),
            l.updateMatrixWorld(),
            (m.near = t.near),
            (v.near = t.near),
            (m.far = t.far),
            (v.far = t.far),
            m.matrixWorldInverse.fromArray(o.leftViewMatrix),
            v.matrixWorldInverse.fromArray(o.rightViewMatrix),
            u.getInverse(c),
            "local-floor" === h &&
              (m.matrixWorldInverse.multiply(u),
              v.matrixWorldInverse.multiply(u));
          var x = l.parent;
          null !== x &&
            (p.getInverse(x.matrixWorld),
            m.matrixWorldInverse.multiply(p),
            v.matrixWorldInverse.multiply(p)),
            m.matrixWorld.getInverse(m.matrixWorldInverse),
            v.matrixWorld.getInverse(v.matrixWorldInverse),
            m.projectionMatrix.fromArray(o.leftProjectionMatrix),
            v.projectionMatrix.fromArray(o.rightProjectionMatrix),
            ja(g, m, v);
          var b = i.getLayers();
          if (b.length) {
            var w = b[0];
            S(m.viewport, w.leftBounds), S(v.viewport, w.rightBounds);
          }
          return (
            (function () {
              for (var t = 0; t < s.length; t++) {
                var e = s[t],
                  n = M(t);
                if (void 0 !== n && void 0 !== n.pose) {
                  if (null === n.pose) return;
                  var r = n.pose;
                  !1 === r.hasPosition && e.position.set(0.2, -0.6, -0.05),
                    null !== r.position && e.position.fromArray(r.position),
                    null !== r.orientation &&
                      e.quaternion.fromArray(r.orientation),
                    e.matrix.compose(e.position, e.quaternion, e.scale),
                    e.matrix.premultiply(c),
                    e.matrix.decompose(e.position, e.quaternion, e.scale),
                    (e.matrixWorldNeedsUpdate = !0),
                    (e.visible = !0);
                  var i = "Daydream Controller" === n.id ? 0 : 1;
                  void 0 === _[t] && (_[t] = !1),
                    _[t] !== n.buttons[i].pressed &&
                      ((_[t] = n.buttons[i].pressed),
                      !0 === _[t]
                        ? e.dispatchEvent({ type: "selectstart" })
                        : (e.dispatchEvent({ type: "selectend" }),
                          e.dispatchEvent({ type: "select" })));
                } else e.visible = !1;
              }
            })(),
            g
          );
        }),
        (this.getStandingMatrix = function () {
          return c;
        }),
        (this.isPresenting = y);
      var E = new Ui();
      (this.setAnimationLoop = function (t) {
        E.setAnimationLoop(t), y() && E.start();
      }),
        (this.submitFrame = function () {
          y() && i.submitFrame();
        }),
        (this.dispose = function () {
          "undefined" != typeof window &&
            window.removeEventListener("vrdisplaypresentchange", w);
        }),
        (this.setFrameOfReferenceType = function () {
          console.warn(
            "THREE.WebVRManager: setFrameOfReferenceType() has been deprecated."
          );
        });
    }
    function Ha(t, e) {
      var n = this,
        r = null,
        i = null,
        o = "local-floor",
        a = null,
        s = [],
        c = [];
      function u() {
        return null !== r && null !== i;
      }
      var l = new _i();
      l.layers.enable(1), (l.viewport = new en());
      var h = new _i();
      h.layers.enable(2), (h.viewport = new en());
      var p = new Fa([l, h]);
      function f(t) {
        for (var e = 0; e < s.length; e++)
          c[e] === t.inputSource && s[e].dispatchEvent({ type: t.type });
      }
      function d() {
        t.setFramebuffer(null),
          t.setRenderTarget(t.getRenderTarget()),
          y.stop(),
          n.dispatchEvent({ type: "sessionend" });
      }
      function m(t) {
        (i = t),
          y.setContext(r),
          y.start(),
          n.dispatchEvent({ type: "sessionstart" });
      }
      function v(t, e) {
        null === e
          ? t.matrixWorld.copy(t.matrix)
          : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
          t.matrixWorldInverse.getInverse(t.matrixWorld);
      }
      p.layers.enable(1),
        p.layers.enable(2),
        (this.enabled = !1),
        (this.getController = function (t) {
          var e = s[t];
          return (
            void 0 === e &&
              (((e = new za()).matrixAutoUpdate = !1),
              (e.visible = !1),
              (s[t] = e)),
            e
          );
        }),
        (this.setFramebufferScaleFactor = function () {}),
        (this.setReferenceSpaceType = function (t) {
          o = t;
        }),
        (this.getSession = function () {
          return r;
        }),
        (this.setSession = function (t) {
          null !== (r = t) &&
            (r.addEventListener("select", f),
            r.addEventListener("selectstart", f),
            r.addEventListener("selectend", f),
            r.addEventListener("end", d),
            r.updateRenderState({ baseLayer: new XRWebGLLayer(r, e) }),
            r.requestReferenceSpace(o).then(m),
            (c = r.inputSources),
            r.addEventListener("inputsourceschange", function () {
              (c = r.inputSources), console.log(c);
              for (var t = 0; t < s.length; t++) {
                s[t].userData.inputSource = c[t];
              }
            }));
        }),
        (this.getCamera = function (t) {
          if (u()) {
            var e = t.parent,
              n = p.cameras;
            v(p, e);
            for (var r = 0; r < n.length; r++) v(n[r], e);
            t.matrixWorld.copy(p.matrixWorld);
            for (var i = t.children, o = ((r = 0), i.length); r < o; r++)
              i[r].updateMatrixWorld(!0);
            return ja(p, l, h), p;
          }
          return t;
        }),
        (this.isPresenting = u);
      var g = null;
      var y = new Ui();
      y.setAnimationLoop(function (e, n) {
        if (null !== (a = n.getViewerPose(i))) {
          var o = a.views,
            u = r.renderState.baseLayer;
          t.setFramebuffer(u.framebuffer);
          for (var l = 0; l < o.length; l++) {
            var h = o[l],
              f = u.getViewport(h),
              d = h.transform.inverse.matrix,
              m = p.cameras[l];
            m.matrix.fromArray(d).getInverse(m.matrix),
              m.projectionMatrix.fromArray(h.projectionMatrix),
              m.viewport.set(f.x, f.y, f.width, f.height),
              0 === l && p.matrix.copy(m.matrix);
          }
        }
        for (l = 0; l < s.length; l++) {
          var v = s[l],
            y = c[l];
          if (y) {
            var x = n.getPose(y.targetRaySpace, i);
            if (null !== x) {
              v.matrix.fromArray(x.transform.matrix),
                v.matrix.decompose(v.position, v.rotation, v.scale),
                (v.visible = !0);
              continue;
            }
          }
          v.visible = !1;
        }
        g && g(e);
      }),
        (this.setAnimationLoop = function (t) {
          g = t;
        }),
        (this.dispose = function () {}),
        (this.getStandingMatrix = function () {
          return (
            console.warn(
              "THREE.WebXRManager: getStandingMatrix() is no longer needed."
            ),
            new pn()
          );
        }),
        (this.getDevice = function () {
          console.warn("THREE.WebXRManager: getDevice() has been deprecated.");
        }),
        (this.setDevice = function () {
          console.warn("THREE.WebXRManager: setDevice() has been deprecated.");
        }),
        (this.setFrameOfReferenceType = function () {
          console.warn(
            "THREE.WebXRManager: setFrameOfReferenceType() has been deprecated."
          );
        }),
        (this.submitFrame = function () {});
    }
    function ka(t) {
      var e =
          void 0 !== (t = t || {}).canvas
            ? t.canvas
            : document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              ),
        n = void 0 !== t.context ? t.context : null,
        r = void 0 !== t.alpha && t.alpha,
        i = void 0 === t.depth || t.depth,
        o = void 0 === t.stencil || t.stencil,
        a = void 0 !== t.antialias && t.antialias,
        s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
        c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
        u = void 0 !== t.powerPreference ? t.powerPreference : "default",
        l =
          void 0 !== t.failIfMajorPerformanceCaveat &&
          t.failIfMajorPerformanceCaveat,
        h = null,
        p = null;
      (this.domElement = e),
        (this.debug = { checkShaderErrors: !0 }),
        (this.autoClear = !0),
        (this.autoClearColor = !0),
        (this.autoClearDepth = !0),
        (this.autoClearStencil = !0),
        (this.sortObjects = !0),
        (this.clippingPlanes = []),
        (this.localClippingEnabled = !1),
        (this.gammaFactor = 2),
        (this.gammaInput = !1),
        (this.gammaOutput = !1),
        (this.physicallyCorrectLights = !1),
        (this.toneMapping = ht),
        (this.toneMappingExposure = 1),
        (this.toneMappingWhitePoint = 1),
        (this.maxMorphTargets = 8),
        (this.maxMorphNormals = 4);
      var f,
        d,
        m,
        v,
        g,
        y,
        x,
        b,
        w,
        _,
        M,
        S,
        E,
        A,
        L,
        P,
        R,
        C,
        O = this,
        I = !1,
        N = null,
        D = 0,
        z = 0,
        F = null,
        U = null,
        B = -1,
        G = { geometry: null, program: null, wireframe: !1 },
        j = null,
        V = null,
        H = new en(),
        k = new en(),
        W = null,
        q = e.width,
        X = e.height,
        Y = 1,
        J = new en(0, 0, q, X),
        Z = new en(0, 0, q, X),
        Q = !1,
        K = new Ni(),
        $ = new Wi(),
        tt = !1,
        et = !1,
        nt = new pn(),
        rt = new Ye();
      function it() {
        return null === F ? Y : 1;
      }
      try {
        var ot = {
          alpha: r,
          depth: i,
          stencil: o,
          antialias: a,
          premultipliedAlpha: s,
          preserveDrawingBuffer: c,
          powerPreference: u,
          failIfMajorPerformanceCaveat: l,
          xrCompatible: !0,
        };
        if (
          (e.addEventListener("webglcontextlost", lt, !1),
          e.addEventListener("webglcontextrestored", pt, !1),
          null ===
            (f =
              n ||
              e.getContext("webgl", ot) ||
              e.getContext("experimental-webgl", ot)))
        )
          throw null !== e.getContext("webgl")
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
        void 0 === f.getShaderPrecisionFormat &&
          (f.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
      } catch (t) {
        throw (console.error("THREE.WebGLRenderer: " + t.message), t);
      }
      function at() {
        (d = new qi(f)),
          !1 === (m = new ki(f, d, t)).isWebGL2 &&
            (d.get("WEBGL_depth_texture"),
            d.get("OES_texture_float"),
            d.get("OES_texture_half_float"),
            d.get("OES_texture_half_float_linear"),
            d.get("OES_standard_derivatives"),
            d.get("OES_element_index_uint"),
            d.get("ANGLE_instanced_arrays")),
          d.get("OES_texture_float_linear"),
          (C = new Ia(f, d, m)),
          (v = new Ca(f, d, C, m)).scissor(k.copy(Z).multiplyScalar(Y).floor()),
          v.viewport(H.copy(J).multiplyScalar(Y).floor()),
          (g = new Ji(f)),
          (y = new ma()),
          (x = new Oa(f, d, v, y, m, C, g)),
          (b = new Bi(f)),
          (w = new Xi(f, b, g)),
          (_ = new Ki(f, w, b, g)),
          (L = new Qi(f)),
          (M = new da(O, d, m)),
          (S = new xa()),
          (E = new Ea()),
          (A = new Vi(O, v, _, s)),
          (P = new Hi(f, d, g, m)),
          (R = new Yi(f, d, g, m)),
          (g.programs = M.programs),
          (O.capabilities = m),
          (O.extensions = d),
          (O.properties = y),
          (O.renderLists = S),
          (O.state = v),
          (O.info = g);
      }
      at();
      var st =
        "undefined" != typeof navigator &&
        "xr" in navigator &&
        "supportsSession" in navigator.xr
          ? new Ha(O, f)
          : new Va(O);
      this.vr = st;
      var ct = new Da(O, f),
        ut = new Ra(O, _, m.maxTextureSize);
      function lt(t) {
        t.preventDefault(),
          console.log("THREE.WebGLRenderer: Context Lost."),
          (I = !0);
      }
      function pt() {
        console.log("THREE.WebGLRenderer: Context Restored."), (I = !1), at();
      }
      function ft(t) {
        var e = t.target;
        e.removeEventListener("dispose", ft),
          (function (t) {
            dt(t), y.remove(t);
          })(e);
      }
      function dt(t) {
        var e = y.get(t).program;
        (t.program = void 0), void 0 !== e && M.releaseProgram(e);
      }
      (this.shadowMap = ut),
        (this.getContext = function () {
          return f;
        }),
        (this.getContextAttributes = function () {
          return f.getContextAttributes();
        }),
        (this.forceContextLoss = function () {
          var t = d.get("WEBGL_lose_context");
          t && t.loseContext();
        }),
        (this.forceContextRestore = function () {
          var t = d.get("WEBGL_lose_context");
          t && t.restoreContext();
        }),
        (this.getPixelRatio = function () {
          return Y;
        }),
        (this.setPixelRatio = function (t) {
          void 0 !== t && ((Y = t), this.setSize(q, X, !1));
        }),
        (this.getSize = function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "WebGLRenderer: .getsize() now requires a Vector2 as an argument"
              ),
              (t = new ke())),
            t.set(q, X)
          );
        }),
        (this.setSize = function (t, n, r) {
          st.isPresenting()
            ? console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting."
              )
            : ((q = t),
              (X = n),
              (e.width = Math.floor(t * Y)),
              (e.height = Math.floor(n * Y)),
              !1 !== r &&
                ((e.style.width = t + "px"), (e.style.height = n + "px")),
              this.setViewport(0, 0, t, n));
        }),
        (this.getDrawingBufferSize = function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"
              ),
              (t = new ke())),
            t.set(q * Y, X * Y).floor()
          );
        }),
        (this.setDrawingBufferSize = function (t, n, r) {
          (q = t),
            (X = n),
            (Y = r),
            (e.width = Math.floor(t * r)),
            (e.height = Math.floor(n * r)),
            this.setViewport(0, 0, t, n);
        }),
        (this.getCurrentViewport = function (t) {
          return (
            void 0 === t &&
              (console.warn(
                "WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"
              ),
              (t = new en())),
            t.copy(H)
          );
        }),
        (this.getViewport = function (t) {
          return t.copy(J);
        }),
        (this.setViewport = function (t, e, n, r) {
          t.isVector4 ? J.set(t.x, t.y, t.z, t.w) : J.set(t, e, n, r),
            v.viewport(H.copy(J).multiplyScalar(Y).floor());
        }),
        (this.getScissor = function (t) {
          return t.copy(Z);
        }),
        (this.setScissor = function (t, e, n, r) {
          t.isVector4 ? Z.set(t.x, t.y, t.z, t.w) : Z.set(t, e, n, r),
            v.scissor(k.copy(Z).multiplyScalar(Y).floor());
        }),
        (this.getScissorTest = function () {
          return Q;
        }),
        (this.setScissorTest = function (t) {
          v.setScissorTest((Q = t));
        }),
        (this.getClearColor = function () {
          return A.getClearColor();
        }),
        (this.setClearColor = function () {
          A.setClearColor.apply(A, arguments);
        }),
        (this.getClearAlpha = function () {
          return A.getClearAlpha();
        }),
        (this.setClearAlpha = function () {
          A.setClearAlpha.apply(A, arguments);
        }),
        (this.clear = function (t, e, n) {
          var r = 0;
          (void 0 === t || t) && (r |= 16384),
            (void 0 === e || e) && (r |= 256),
            (void 0 === n || n) && (r |= 1024),
            f.clear(r);
        }),
        (this.clearColor = function () {
          this.clear(!0, !1, !1);
        }),
        (this.clearDepth = function () {
          this.clear(!1, !0, !1);
        }),
        (this.clearStencil = function () {
          this.clear(!1, !1, !0);
        }),
        (this.dispose = function () {
          e.removeEventListener("webglcontextlost", lt, !1),
            e.removeEventListener("webglcontextrestored", pt, !1),
            S.dispose(),
            E.dispose(),
            y.dispose(),
            _.dispose(),
            st.dispose(),
            vt.stop();
        }),
        (this.renderBufferImmediate = function (t, e) {
          v.initAttributes();
          var n = y.get(t);
          t.hasPositions && !n.position && (n.position = f.createBuffer()),
            t.hasNormals && !n.normal && (n.normal = f.createBuffer()),
            t.hasUvs && !n.uv && (n.uv = f.createBuffer()),
            t.hasColors && !n.color && (n.color = f.createBuffer());
          var r = e.getAttributes();
          t.hasPositions &&
            (f.bindBuffer(34962, n.position),
            f.bufferData(34962, t.positionArray, 35048),
            v.enableAttribute(r.position),
            f.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)),
            t.hasNormals &&
              (f.bindBuffer(34962, n.normal),
              f.bufferData(34962, t.normalArray, 35048),
              v.enableAttribute(r.normal),
              f.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)),
            t.hasUvs &&
              (f.bindBuffer(34962, n.uv),
              f.bufferData(34962, t.uvArray, 35048),
              v.enableAttribute(r.uv),
              f.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)),
            t.hasColors &&
              (f.bindBuffer(34962, n.color),
              f.bufferData(34962, t.colorArray, 35048),
              v.enableAttribute(r.color),
              f.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)),
            v.disableUnusedAttributes(),
            f.drawArrays(4, 0, t.count),
            (t.count = 0);
        }),
        (this.renderBufferDirect = function (t, e, n, r, i, o) {
          var a = i.isMesh && i.matrixWorld.determinant() < 0;
          v.setMaterial(r, a);
          var s = wt(t, e, r, i),
            c = !1;
          (G.geometry === n.id &&
            G.program === s.id &&
            G.wireframe === (!0 === r.wireframe)) ||
            ((G.geometry = n.id),
            (G.program = s.id),
            (G.wireframe = !0 === r.wireframe),
            (c = !0)),
            i.morphTargetInfluences && (L.update(i, n, r, s), (c = !0));
          var u,
            l = n.index,
            h = n.attributes.position,
            p = 1;
          !0 === r.wireframe && ((l = w.getWireframeAttribute(n)), (p = 2));
          var g = P;
          null !== l && ((u = b.get(l)), (g = R).setIndex(u)),
            c &&
              (!(function (t, e, n, r) {
                if (
                  !1 === m.isWebGL2 &&
                  (t.isInstancedMesh || e.isInstancedBufferGeometry) &&
                  null === d.get("ANGLE_instanced_arrays")
                )
                  return;
                v.initAttributes();
                var i = e.attributes,
                  o = r.getAttributes(),
                  a = n.defaultAttributeValues;
                for (var s in o) {
                  var c = o[s];
                  if (c >= 0) {
                    var u = i[s];
                    if (void 0 !== u) {
                      var l = u.normalized,
                        h = u.itemSize;
                      if (void 0 === (M = b.get(u))) continue;
                      var p = M.buffer,
                        g = M.type,
                        y = M.bytesPerElement;
                      if (u.isInterleavedBufferAttribute) {
                        var x = u.data,
                          w = x.stride,
                          _ = u.offset;
                        x && x.isInstancedInterleavedBuffer
                          ? (v.enableAttributeAndDivisor(c, x.meshPerAttribute),
                            void 0 === e.maxInstancedCount &&
                              (e.maxInstancedCount =
                                x.meshPerAttribute * x.count))
                          : v.enableAttribute(c),
                          f.bindBuffer(34962, p),
                          f.vertexAttribPointer(c, h, g, l, w * y, _ * y);
                      } else
                        u.isInstancedBufferAttribute
                          ? (v.enableAttributeAndDivisor(c, u.meshPerAttribute),
                            void 0 === e.maxInstancedCount &&
                              (e.maxInstancedCount =
                                u.meshPerAttribute * u.count))
                          : v.enableAttribute(c),
                          f.bindBuffer(34962, p),
                          f.vertexAttribPointer(c, h, g, l, 0, 0);
                    } else if ("instanceMatrix" === s) {
                      var M;
                      if (void 0 === (M = b.get(t.instanceMatrix))) continue;
                      (p = M.buffer), (g = M.type);
                      v.enableAttributeAndDivisor(c + 0, 1),
                        v.enableAttributeAndDivisor(c + 1, 1),
                        v.enableAttributeAndDivisor(c + 2, 1),
                        v.enableAttributeAndDivisor(c + 3, 1),
                        f.bindBuffer(34962, p),
                        f.vertexAttribPointer(c + 0, 4, g, !1, 64, 0),
                        f.vertexAttribPointer(c + 1, 4, g, !1, 64, 16),
                        f.vertexAttribPointer(c + 2, 4, g, !1, 64, 32),
                        f.vertexAttribPointer(c + 3, 4, g, !1, 64, 48);
                    } else if (void 0 !== a) {
                      var S = a[s];
                      if (void 0 !== S)
                        switch (S.length) {
                          case 2:
                            f.vertexAttrib2fv(c, S);
                            break;
                          case 3:
                            f.vertexAttrib3fv(c, S);
                            break;
                          case 4:
                            f.vertexAttrib4fv(c, S);
                            break;
                          default:
                            f.vertexAttrib1fv(c, S);
                        }
                    }
                  }
                }
                v.disableUnusedAttributes();
              })(i, n, r, s),
              null !== l && f.bindBuffer(34963, u.buffer));
          var y = 1 / 0;
          null !== l ? (y = l.count) : void 0 !== h && (y = h.count);
          var x = n.drawRange.start * p,
            _ = n.drawRange.count * p,
            M = null !== o ? o.start * p : 0,
            S = null !== o ? o.count * p : 1 / 0,
            E = Math.max(x, M),
            T = Math.min(y, x + _, M + S) - 1,
            A = Math.max(0, T - E + 1);
          if (0 !== A) {
            if (i.isMesh)
              if (!0 === r.wireframe)
                v.setLineWidth(r.wireframeLinewidth * it()), g.setMode(1);
              else
                switch (i.drawMode) {
                  case Me:
                    g.setMode(4);
                    break;
                  case Se:
                    g.setMode(5);
                    break;
                  case Ee:
                    g.setMode(6);
                }
            else if (i.isLine) {
              var C = r.linewidth;
              void 0 === C && (C = 1),
                v.setLineWidth(C * it()),
                i.isLineSegments
                  ? g.setMode(1)
                  : i.isLineLoop
                  ? g.setMode(2)
                  : g.setMode(3);
            } else i.isPoints ? g.setMode(0) : i.isSprite && g.setMode(4);
            i.isInstancedMesh
              ? g.renderInstances(n, E, A, i.count)
              : n.isInstancedBufferGeometry
              ? g.renderInstances(n, E, A, n.maxInstancedCount)
              : g.render(E, A);
          }
        }),
        (this.compile = function (t, e) {
          (p = E.get(t, e)).init(),
            t.traverse(function (t) {
              t.isLight && (p.pushLight(t), t.castShadow && p.pushShadow(t));
            }),
            p.setupLights(e),
            t.traverse(function (e) {
              if (e.material)
                if (Array.isArray(e.material))
                  for (var n = 0; n < e.material.length; n++)
                    bt(e.material[n], t.fog, e);
                else bt(e.material, t.fog, e);
            });
        });
      var mt = null;
      var vt = new Ui();
      function gt(t, e, n, r) {
        if (!1 !== t.visible) {
          if (t.layers.test(e.layers))
            if (t.isGroup) n = t.renderOrder;
            else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
            else if (t.isLight) p.pushLight(t), t.castShadow && p.pushShadow(t);
            else if (t.isSprite) {
              if (!t.frustumCulled || K.intersectsSprite(t)) {
                r && rt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(nt);
                var i = _.update(t);
                (o = t.material).visible && h.push(t, i, o, n, rt.z, null);
              }
            } else if (t.isImmediateRenderObject)
              r && rt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(nt),
                h.push(t, null, t.material, n, rt.z, null);
            else if (
              (t.isMesh || t.isLine || t.isPoints) &&
              (t.isSkinnedMesh &&
                t.skeleton.frame !== g.render.frame &&
                (t.skeleton.update(), (t.skeleton.frame = g.render.frame)),
              !t.frustumCulled || K.intersectsObject(t))
            ) {
              r && rt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(nt);
              i = _.update(t);
              var o = t.material;
              if (Array.isArray(o))
                for (var a = i.groups, s = 0, c = a.length; s < c; s++) {
                  var u = a[s],
                    l = o[u.materialIndex];
                  l && l.visible && h.push(t, i, l, n, rt.z, u);
                }
              else o.visible && h.push(t, i, o, n, rt.z, null);
            }
          var f = t.children;
          for (s = 0, c = f.length; s < c; s++) gt(f[s], e, n, r);
        }
      }
      function yt(t, e, n, r) {
        for (var i = 0, o = t.length; i < o; i++) {
          var a = t[i],
            s = a.object,
            c = a.geometry,
            u = void 0 === r ? a.material : r,
            l = a.group;
          if (n.isArrayCamera)
            if (((V = n), st.enabled && ct.isAvailable())) xt(s, e, n, c, u, l);
            else
              for (var h = n.cameras, f = 0, d = h.length; f < d; f++) {
                var m = h[f];
                s.layers.test(m.layers) &&
                  (v.viewport(H.copy(m.viewport)),
                  p.setupLights(m),
                  xt(s, e, m, c, u, l));
              }
          else (V = null), xt(s, e, n, c, u, l);
        }
      }
      function xt(t, e, n, r, i, o) {
        if (
          (t.onBeforeRender(O, e, n, r, i, o),
          (p = E.get(e, V || n)),
          t.modelViewMatrix.multiplyMatrices(
            n.matrixWorldInverse,
            t.matrixWorld
          ),
          t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
          t.isImmediateRenderObject)
        ) {
          v.setMaterial(i);
          var a = wt(n, e.fog, i, t);
          (G.geometry = null),
            (G.program = null),
            (G.wireframe = !1),
            (function (t, e) {
              t.render(function (t) {
                O.renderBufferImmediate(t, e);
              });
            })(t, a);
        } else O.renderBufferDirect(n, e.fog, r, i, t, o);
        t.onAfterRender(O, e, n, r, i, o), (p = E.get(e, V || n));
      }
      function bt(t, e, n) {
        var r = y.get(t),
          i = p.state.lights,
          o = p.state.shadowsArray,
          a = i.state.version,
          s = M.getParameters(
            t,
            i.state,
            o,
            e,
            $.numPlanes,
            $.numIntersection,
            n
          ),
          c = M.getProgramCode(t, s),
          u = r.program,
          l = !0;
        if (void 0 === u) t.addEventListener("dispose", ft);
        else if (u.code !== c) dt(t);
        else if (r.lightsStateVersion !== a)
          (r.lightsStateVersion = a), (l = !1);
        else {
          if (void 0 !== s.shaderID) return;
          l = !1;
        }
        if (l) {
          if (s.shaderID) {
            var h = Fi[s.shaderID];
            r.shader = {
              name: t.type,
              uniforms: vi(h.uniforms),
              vertexShader: h.vertexShader,
              fragmentShader: h.fragmentShader,
            };
          } else
            r.shader = {
              name: t.type,
              uniforms: t.uniforms,
              vertexShader: t.vertexShader,
              fragmentShader: t.fragmentShader,
            };
          t.onBeforeCompile(r.shader, O),
            (c = M.getProgramCode(t, s)),
            (u = M.acquireProgram(t, r.shader, s, c)),
            (r.program = u),
            (t.program = u);
        }
        var f = u.getAttributes();
        if (t.morphTargets) {
          t.numSupportedMorphTargets = 0;
          for (var d = 0; d < O.maxMorphTargets; d++)
            f["morphTarget" + d] >= 0 && t.numSupportedMorphTargets++;
        }
        if (t.morphNormals) {
          t.numSupportedMorphNormals = 0;
          for (d = 0; d < O.maxMorphNormals; d++)
            f["morphNormal" + d] >= 0 && t.numSupportedMorphNormals++;
        }
        var m = r.shader.uniforms;
        ((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
          ((r.numClippingPlanes = $.numPlanes),
          (r.numIntersection = $.numIntersection),
          (m.clippingPlanes = $.uniform)),
          (r.fog = e),
          (r.needsLights = (function (t) {
            return (
              t.isMeshLambertMaterial ||
              t.isMeshPhongMaterial ||
              t.isMeshStandardMaterial ||
              t.isShadowMaterial ||
              (t.isShaderMaterial && !0 === t.lights)
            );
          })(t)),
          (r.lightsStateVersion = a),
          r.needsLights &&
            ((m.ambientLightColor.value = i.state.ambient),
            (m.lightProbe.value = i.state.probe),
            (m.directionalLights.value = i.state.directional),
            (m.spotLights.value = i.state.spot),
            (m.rectAreaLights.value = i.state.rectArea),
            (m.pointLights.value = i.state.point),
            (m.hemisphereLights.value = i.state.hemi),
            (m.directionalShadowMap.value = i.state.directionalShadowMap),
            (m.directionalShadowMatrix.value = i.state.directionalShadowMatrix),
            (m.spotShadowMap.value = i.state.spotShadowMap),
            (m.spotShadowMatrix.value = i.state.spotShadowMatrix),
            (m.pointShadowMap.value = i.state.pointShadowMap),
            (m.pointShadowMatrix.value = i.state.pointShadowMatrix));
        var v = r.program.getUniforms(),
          g = Zo.seqWithValue(v.seq, m);
        r.uniformsList = g;
      }
      function wt(t, e, n, r) {
        x.resetTextureUnits();
        var i = y.get(n),
          o = p.state.lights;
        if (tt && (et || t !== j)) {
          var a = t === j && n.id === B;
          $.setState(
            n.clippingPlanes,
            n.clipIntersection,
            n.clipShadows,
            t,
            i,
            a
          );
        }
        !1 === n.needsUpdate &&
          (void 0 === i.program
            ? (n.needsUpdate = !0)
            : n.fog && i.fog !== e
            ? (n.needsUpdate = !0)
            : i.needsLights && i.lightsStateVersion !== o.state.version
            ? (n.needsUpdate = !0)
            : void 0 === i.numClippingPlanes ||
              (i.numClippingPlanes === $.numPlanes &&
                i.numIntersection === $.numIntersection) ||
              (n.needsUpdate = !0)),
          n.needsUpdate && (bt(n, e, r), (n.needsUpdate = !1));
        var s,
          c,
          u = !1,
          l = !1,
          h = !1,
          d = i.program,
          g = d.getUniforms(),
          b = i.shader.uniforms;
        if (
          (v.useProgram(d.program) && ((u = !0), (l = !0), (h = !0)),
          n.id !== B && ((B = n.id), (l = !0)),
          u || j !== t)
        ) {
          if (
            (d.numMultiviewViews > 0
              ? ct.updateCameraProjectionMatricesUniform(t, g)
              : g.setValue(f, "projectionMatrix", t.projectionMatrix),
            m.logarithmicDepthBuffer &&
              g.setValue(
                f,
                "logDepthBufFC",
                2 / (Math.log(t.far + 1) / Math.LN2)
              ),
            j !== t && ((j = t), (l = !0), (h = !0)),
            n.isShaderMaterial ||
              n.isMeshPhongMaterial ||
              n.isMeshStandardMaterial ||
              n.envMap)
          ) {
            var w = g.map.cameraPosition;
            void 0 !== w &&
              w.setValue(f, rt.setFromMatrixPosition(t.matrixWorld));
          }
          (n.isMeshPhongMaterial ||
            n.isMeshLambertMaterial ||
            n.isMeshBasicMaterial ||
            n.isMeshStandardMaterial ||
            n.isShaderMaterial ||
            n.skinning) &&
            (d.numMultiviewViews > 0
              ? ct.updateCameraViewMatricesUniform(t, g)
              : g.setValue(f, "viewMatrix", t.matrixWorldInverse));
        }
        if (n.skinning) {
          g.setOptional(f, r, "bindMatrix"),
            g.setOptional(f, r, "bindMatrixInverse");
          var _ = r.skeleton;
          if (_) {
            var M = _.bones;
            if (m.floatVertexTextures) {
              if (void 0 === _.boneTexture) {
                var S = Math.sqrt(4 * M.length);
                (S = He.ceilPowerOfTwo(S)), (S = Math.max(S, 4));
                var E = new Float32Array(S * S * 4);
                E.set(_.boneMatrices);
                var A = new Ai(E, S, S, qt, Ut);
                (_.boneMatrices = E),
                  (_.boneTexture = A),
                  (_.boneTextureSize = S);
              }
              g.setValue(f, "boneTexture", _.boneTexture, x),
                g.setValue(f, "boneTextureSize", _.boneTextureSize);
            } else g.setOptional(f, _, "boneMatrices");
          }
        }
        return (
          (l || i.receiveShadow !== r.receiveShadow) &&
            ((i.receiveShadow = r.receiveShadow),
            g.setValue(f, "receiveShadow", r.receiveShadow)),
          l &&
            (g.setValue(f, "toneMappingExposure", O.toneMappingExposure),
            g.setValue(f, "toneMappingWhitePoint", O.toneMappingWhitePoint),
            i.needsLights &&
              ((c = h),
              ((s = b).ambientLightColor.needsUpdate = c),
              (s.lightProbe.needsUpdate = c),
              (s.directionalLights.needsUpdate = c),
              (s.pointLights.needsUpdate = c),
              (s.spotLights.needsUpdate = c),
              (s.rectAreaLights.needsUpdate = c),
              (s.hemisphereLights.needsUpdate = c)),
            e &&
              n.fog &&
              (function (t, e) {
                t.fogColor.value.copy(e.color),
                  e.isFog
                    ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
                    : e.isFogExp2 && (t.fogDensity.value = e.density);
              })(b, e),
            n.isMeshBasicMaterial
              ? _t(b, n)
              : n.isMeshLambertMaterial
              ? (_t(b, n),
                (function (t, e) {
                  e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                })(b, n))
              : n.isMeshPhongMaterial
              ? (_t(b, n),
                n.isMeshToonMaterial
                  ? (function (t, e) {
                      Mt(t, e),
                        e.gradientMap && (t.gradientMap.value = e.gradientMap);
                    })(b, n)
                  : Mt(b, n))
              : n.isMeshStandardMaterial
              ? (_t(b, n),
                n.isMeshPhysicalMaterial
                  ? (function (t, e) {
                      St(t, e),
                        (t.reflectivity.value = e.reflectivity),
                        (t.clearcoat.value = e.clearcoat),
                        (t.clearcoatRoughness.value = e.clearcoatRoughness),
                        e.sheen && t.sheen.value.copy(e.sheen);
                      e.clearcoatNormalMap &&
                        (t.clearcoatNormalScale.value.copy(
                          e.clearcoatNormalScale
                        ),
                        (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                        e.side === T && t.clearcoatNormalScale.value.negate());
                      t.transparency.value = e.transparency;
                    })(b, n)
                  : St(b, n))
              : n.isMeshMatcapMaterial
              ? (_t(b, n),
                (function (t, e) {
                  e.matcap && (t.matcap.value = e.matcap);
                  e.bumpMap &&
                    ((t.bumpMap.value = e.bumpMap),
                    (t.bumpScale.value = e.bumpScale),
                    e.side === T && (t.bumpScale.value *= -1));
                  e.normalMap &&
                    ((t.normalMap.value = e.normalMap),
                    t.normalScale.value.copy(e.normalScale),
                    e.side === T && t.normalScale.value.negate());
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias));
                })(b, n))
              : n.isMeshDepthMaterial
              ? (_t(b, n),
                (function (t, e) {
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias));
                })(b, n))
              : n.isMeshDistanceMaterial
              ? (_t(b, n),
                (function (t, e) {
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias));
                  t.referencePosition.value.copy(e.referencePosition),
                    (t.nearDistance.value = e.nearDistance),
                    (t.farDistance.value = e.farDistance);
                })(b, n))
              : n.isMeshNormalMaterial
              ? (_t(b, n),
                (function (t, e) {
                  e.bumpMap &&
                    ((t.bumpMap.value = e.bumpMap),
                    (t.bumpScale.value = e.bumpScale),
                    e.side === T && (t.bumpScale.value *= -1));
                  e.normalMap &&
                    ((t.normalMap.value = e.normalMap),
                    t.normalScale.value.copy(e.normalScale),
                    e.side === T && t.normalScale.value.negate());
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias));
                })(b, n))
              : n.isLineBasicMaterial
              ? ((function (t, e) {
                  t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity);
                })(b, n),
                n.isLineDashedMaterial &&
                  (function (t, e) {
                    (t.dashSize.value = e.dashSize),
                      (t.totalSize.value = e.dashSize + e.gapSize),
                      (t.scale.value = e.scale);
                  })(b, n))
              : n.isPointsMaterial
              ? (function (t, e) {
                  t.diffuse.value.copy(e.color),
                    (t.opacity.value = e.opacity),
                    (t.size.value = e.size * Y),
                    (t.scale.value = 0.5 * X),
                    (t.map.value = e.map),
                    null !== e.map &&
                      (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(),
                      t.uvTransform.value.copy(e.map.matrix));
                })(b, n)
              : n.isSpriteMaterial
              ? (function (t, e) {
                  t.diffuse.value.copy(e.color),
                    (t.opacity.value = e.opacity),
                    (t.rotation.value = e.rotation),
                    (t.map.value = e.map),
                    null !== e.map &&
                      (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(),
                      t.uvTransform.value.copy(e.map.matrix));
                })(b, n)
              : n.isShadowMaterial &&
                (b.color.value.copy(n.color), (b.opacity.value = n.opacity)),
            void 0 !== b.ltc_1 && (b.ltc_1.value = zi.LTC_1),
            void 0 !== b.ltc_2 && (b.ltc_2.value = zi.LTC_2),
            Zo.upload(f, i.uniformsList, b, x)),
          n.isShaderMaterial &&
            !0 === n.uniformsNeedUpdate &&
            (Zo.upload(f, i.uniformsList, b, x), (n.uniformsNeedUpdate = !1)),
          n.isSpriteMaterial && g.setValue(f, "center", r.center),
          d.numMultiviewViews > 0
            ? ct.updateObjectMatricesUniforms(r, t, g)
            : (g.setValue(f, "modelViewMatrix", r.modelViewMatrix),
              g.setValue(f, "normalMatrix", r.normalMatrix)),
          g.setValue(f, "modelMatrix", r.matrixWorld),
          d
        );
      }
      function _t(t, e) {
        var n;
        (t.opacity.value = e.opacity),
          e.color && t.diffuse.value.copy(e.color),
          e.emissive &&
            t.emissive.value
              .copy(e.emissive)
              .multiplyScalar(e.emissiveIntensity),
          e.map && (t.map.value = e.map),
          e.alphaMap && (t.alphaMap.value = e.alphaMap),
          e.specularMap && (t.specularMap.value = e.specularMap),
          e.envMap &&
            ((t.envMap.value = e.envMap),
            (t.flipEnvMap.value = e.envMap.isCubeTexture ? -1 : 1),
            (t.reflectivity.value = e.reflectivity),
            (t.refractionRatio.value = e.refractionRatio),
            (t.maxMipLevel.value = y.get(e.envMap).__maxMipLevel)),
          e.lightMap &&
            ((t.lightMap.value = e.lightMap),
            (t.lightMapIntensity.value = e.lightMapIntensity)),
          e.aoMap &&
            ((t.aoMap.value = e.aoMap),
            (t.aoMapIntensity.value = e.aoMapIntensity)),
          e.map
            ? (n = e.map)
            : e.specularMap
            ? (n = e.specularMap)
            : e.displacementMap
            ? (n = e.displacementMap)
            : e.normalMap
            ? (n = e.normalMap)
            : e.bumpMap
            ? (n = e.bumpMap)
            : e.roughnessMap
            ? (n = e.roughnessMap)
            : e.metalnessMap
            ? (n = e.metalnessMap)
            : e.alphaMap
            ? (n = e.alphaMap)
            : e.emissiveMap && (n = e.emissiveMap),
          void 0 !== n &&
            (n.isWebGLRenderTarget && (n = n.texture),
            !0 === n.matrixAutoUpdate && n.updateMatrix(),
            t.uvTransform.value.copy(n.matrix));
      }
      function Mt(t, e) {
        t.specular.value.copy(e.specular),
          (t.shininess.value = Math.max(e.shininess, 1e-4)),
          e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
          e.bumpMap &&
            ((t.bumpMap.value = e.bumpMap),
            (t.bumpScale.value = e.bumpScale),
            e.side === T && (t.bumpScale.value *= -1)),
          e.normalMap &&
            ((t.normalMap.value = e.normalMap),
            t.normalScale.value.copy(e.normalScale),
            e.side === T && t.normalScale.value.negate()),
          e.displacementMap &&
            ((t.displacementMap.value = e.displacementMap),
            (t.displacementScale.value = e.displacementScale),
            (t.displacementBias.value = e.displacementBias));
      }
      function St(t, e) {
        (t.roughness.value = e.roughness),
          (t.metalness.value = e.metalness),
          e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
          e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
          e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
          e.bumpMap &&
            ((t.bumpMap.value = e.bumpMap),
            (t.bumpScale.value = e.bumpScale),
            e.side === T && (t.bumpScale.value *= -1)),
          e.normalMap &&
            ((t.normalMap.value = e.normalMap),
            t.normalScale.value.copy(e.normalScale),
            e.side === T && t.normalScale.value.negate()),
          e.displacementMap &&
            ((t.displacementMap.value = e.displacementMap),
            (t.displacementScale.value = e.displacementScale),
            (t.displacementBias.value = e.displacementBias)),
          e.envMap && (t.envMapIntensity.value = e.envMapIntensity);
      }
      vt.setAnimationLoop(function (t) {
        st.isPresenting() || (mt && mt(t));
      }),
        "undefined" != typeof window && vt.setContext(window),
        (this.setAnimationLoop = function (t) {
          (mt = t), st.setAnimationLoop(t), vt.start();
        }),
        (this.render = function (t, e) {
          var n, r;
          if (
            (void 0 !== arguments[2] &&
              (console.warn(
                "THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."
              ),
              (n = arguments[2])),
            void 0 !== arguments[3] &&
              (console.warn(
                "THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."
              ),
              (r = arguments[3])),
            e && e.isCamera)
          ) {
            if (!I) {
              (G.geometry = null),
                (G.program = null),
                (G.wireframe = !1),
                (B = -1),
                (j = null),
                !0 === t.autoUpdate && t.updateMatrixWorld(),
                null === e.parent && e.updateMatrixWorld(),
                st.enabled && (e = st.getCamera(e)),
                (p = E.get(t, e)).init(),
                t.onBeforeRender(O, t, e, n || F),
                nt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                K.setFromMatrix(nt),
                (et = this.localClippingEnabled),
                (tt = $.init(this.clippingPlanes, et, e)),
                (h = S.get(t, e)).init(),
                gt(t, e, 0, O.sortObjects),
                !0 === O.sortObjects && h.sort(),
                tt && $.beginShadows();
              var i = p.state.shadowsArray;
              ut.render(i, t, e),
                p.setupLights(e),
                tt && $.endShadows(),
                this.info.autoReset && this.info.reset(),
                void 0 !== n && this.setRenderTarget(n),
                st.enabled && ct.isAvailable() && ct.attachCamera(e),
                A.render(h, t, e, r);
              var o = h.opaque,
                a = h.transparent;
              if (t.overrideMaterial) {
                var s = t.overrideMaterial;
                o.length && yt(o, t, e, s), a.length && yt(a, t, e, s);
              } else o.length && yt(o, t, e), a.length && yt(a, t, e);
              t.onAfterRender(O, t, e),
                null !== F &&
                  (x.updateRenderTargetMipmap(F),
                  x.updateMultisampleRenderTarget(F)),
                v.buffers.depth.setTest(!0),
                v.buffers.depth.setMask(!0),
                v.buffers.color.setMask(!0),
                v.setPolygonOffset(!1),
                st.enabled &&
                  (ct.isAvailable() && ct.detachCamera(e), st.submitFrame()),
                (h = null),
                (p = null);
            }
          } else
            console.error(
              "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
            );
        }),
        (this.setFramebuffer = function (t) {
          N !== t && f.bindFramebuffer(36160, t), (N = t);
        }),
        (this.getActiveCubeFace = function () {
          return D;
        }),
        (this.getActiveMipmapLevel = function () {
          return z;
        }),
        (this.getRenderTarget = function () {
          return F;
        }),
        (this.setRenderTarget = function (t, e, n) {
          (F = t),
            (D = e),
            (z = n),
            t &&
              void 0 === y.get(t).__webglFramebuffer &&
              x.setupRenderTarget(t);
          var r = N,
            i = !1;
          if (t) {
            var o = y.get(t).__webglFramebuffer;
            t.isWebGLRenderTargetCube
              ? ((r = o[e || 0]), (i = !0))
              : (r = t.isWebGLMultisampleRenderTarget
                  ? y.get(t).__webglMultisampledFramebuffer
                  : o),
              H.copy(t.viewport),
              k.copy(t.scissor),
              (W = t.scissorTest);
          } else
            H.copy(J).multiplyScalar(Y).floor(),
              k.copy(Z).multiplyScalar(Y).floor(),
              (W = Q);
          if (
            (U !== r && (f.bindFramebuffer(36160, r), (U = r)),
            v.viewport(H),
            v.scissor(k),
            v.setScissorTest(W),
            i)
          ) {
            var a = y.get(t.texture);
            f.framebufferTexture2D(
              36160,
              36064,
              34069 + (e || 0),
              a.__webglTexture,
              n || 0
            );
          }
        }),
        (this.readRenderTargetPixels = function (t, e, n, r, i, o, a) {
          if (t && t.isWebGLRenderTarget) {
            var s = y.get(t).__webglFramebuffer;
            if ((t.isWebGLRenderTargetCube && void 0 !== a && (s = s[a]), s)) {
              var c = !1;
              s !== U && (f.bindFramebuffer(36160, s), (c = !0));
              try {
                var u = t.texture,
                  l = u.format,
                  h = u.type;
                if (l !== qt && C.convert(l) !== f.getParameter(35739))
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                  );
                if (
                  !(
                    h === Ot ||
                    C.convert(h) === f.getParameter(35738) ||
                    (h === Ut &&
                      (m.isWebGL2 ||
                        d.get("OES_texture_float") ||
                        d.get("WEBGL_color_buffer_float"))) ||
                    (h === Bt &&
                      (m.isWebGL2
                        ? d.get("EXT_color_buffer_float")
                        : d.get("EXT_color_buffer_half_float")))
                  )
                )
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                  );
                36053 === f.checkFramebufferStatus(36160)
                  ? e >= 0 &&
                    e <= t.width - r &&
                    n >= 0 &&
                    n <= t.height - i &&
                    f.readPixels(e, n, r, i, C.convert(l), C.convert(h), o)
                  : console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                    );
              } finally {
                c && f.bindFramebuffer(36160, U);
              }
            }
          } else
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
            );
        }),
        (this.copyFramebufferToTexture = function (t, e, n) {
          var r = e.image.width,
            i = e.image.height,
            o = C.convert(e.format);
          x.setTexture2D(e, 0),
            f.copyTexImage2D(3553, n || 0, o, t.x, t.y, r, i, 0);
        }),
        (this.copyTextureToTexture = function (t, e, n, r) {
          var i = e.image.width,
            o = e.image.height,
            a = C.convert(n.format),
            s = C.convert(n.type);
          x.setTexture2D(n, 0),
            e.isDataTexture
              ? f.texSubImage2D(
                  3553,
                  r || 0,
                  t.x,
                  t.y,
                  i,
                  o,
                  a,
                  s,
                  e.image.data
                )
              : f.texSubImage2D(3553, r || 0, t.x, t.y, a, s, e.image);
        }),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    function Wa(t, e) {
      (this.name = ""),
        (this.color = new vr(t)),
        (this.density = void 0 !== e ? e : 25e-5);
    }
    function qa(t, e, n) {
      (this.name = ""),
        (this.color = new vr(t)),
        (this.near = void 0 !== e ? e : 1),
        (this.far = void 0 !== n ? n : 1e3);
    }
    function Xa(t, e) {
      (this.array = t),
        (this.stride = e),
        (this.count = void 0 !== t ? t.length / e : 0),
        (this.dynamic = !1),
        (this.updateRange = { offset: 0, count: -1 }),
        (this.version = 0);
    }
    function Ya(t, e, n, r) {
      (this.data = t),
        (this.itemSize = e),
        (this.offset = n),
        (this.normalized = !0 === r);
    }
    function Ja(t) {
      _r.call(this),
        (this.type = "SpriteMaterial"),
        (this.color = new vr(16777215)),
        (this.map = null),
        (this.rotation = 0),
        (this.sizeAttenuation = !0),
        (this.transparent = !0),
        this.setValues(t);
    }
    Object.assign(Va.prototype, Ge.prototype),
      Object.assign(Ha.prototype, Ge.prototype),
      Object.assign(Wa.prototype, {
        isFogExp2: !0,
        clone: function () {
          return new Wa(this.color, this.density);
        },
        toJSON: function () {
          return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density,
          };
        },
      }),
      Object.assign(qa.prototype, {
        isFog: !0,
        clone: function () {
          return new qa(this.color, this.near, this.far);
        },
        toJSON: function () {
          return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far,
          };
        },
      }),
      Object.defineProperty(Xa.prototype, "needsUpdate", {
        set: function (t) {
          !0 === t && this.version++;
        },
      }),
      Object.assign(Xa.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function () {},
        setDynamic: function (t) {
          return (this.dynamic = t), this;
        },
        copy: function (t) {
          return (
            (this.array = new t.array.constructor(t.array)),
            (this.count = t.count),
            (this.stride = t.stride),
            (this.dynamic = t.dynamic),
            this
          );
        },
        copyAt: function (t, e, n) {
          (t *= this.stride), (n *= e.stride);
          for (var r = 0, i = this.stride; r < i; r++)
            this.array[t + r] = e.array[n + r];
          return this;
        },
        set: function (t, e) {
          return void 0 === e && (e = 0), this.array.set(t, e), this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        onUpload: function (t) {
          return (this.onUploadCallback = t), this;
        },
      }),
      Object.defineProperties(Ya.prototype, {
        count: {
          get: function () {
            return this.data.count;
          },
        },
        array: {
          get: function () {
            return this.data.array;
          },
        },
      }),
      Object.assign(Ya.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function (t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset] = e), this
          );
        },
        setY: function (t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 1] = e), this
          );
        },
        setZ: function (t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 2] = e), this
          );
        },
        setW: function (t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 3] = e), this
          );
        },
        getX: function (t) {
          return this.data.array[t * this.data.stride + this.offset];
        },
        getY: function (t) {
          return this.data.array[t * this.data.stride + this.offset + 1];
        },
        getZ: function (t) {
          return this.data.array[t * this.data.stride + this.offset + 2];
        },
        getW: function (t) {
          return this.data.array[t * this.data.stride + this.offset + 3];
        },
        setXY: function (t, e, n) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            this
          );
        },
        setXYZ: function (t, e, n, r) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            (this.data.array[t + 2] = r),
            this
          );
        },
        setXYZW: function (t, e, n, r, i) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            (this.data.array[t + 2] = r),
            (this.data.array[t + 3] = i),
            this
          );
        },
      }),
      (Ja.prototype = Object.create(_r.prototype)),
      (Ja.prototype.constructor = Ja),
      (Ja.prototype.isSpriteMaterial = !0),
      (Ja.prototype.copy = function (t) {
        return (
          _r.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.rotation = t.rotation),
          (this.sizeAttenuation = t.sizeAttenuation),
          this
        );
      });
    var Za = new Ye(),
      Qa = new Ye(),
      Ka = new Ye(),
      $a = new ke(),
      ts = new ke(),
      es = new pn(),
      ns = new Ye(),
      rs = new Ye(),
      is = new Ye(),
      os = new ke(),
      as = new ke(),
      ss = new ke();
    function cs(t) {
      if ((Rn.call(this), (this.type = "Sprite"), void 0 === Ua)) {
        Ua = new Hr();
        var e = new Xa(
          new Float32Array([
            -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5,
            0.5, 0, 0, 1,
          ]),
          5
        );
        Ua.setIndex([0, 1, 2, 0, 2, 3]),
          Ua.addAttribute("position", new Ya(e, 3, 0, !1)),
          Ua.addAttribute("uv", new Ya(e, 2, 3, !1));
      }
      (this.geometry = Ua),
        (this.material = void 0 !== t ? t : new Ja()),
        (this.center = new ke(0.5, 0.5));
    }
    function us(t, e, n, r, i, o) {
      $a.subVectors(t, n).addScalar(0.5).multiply(r),
        void 0 !== i
          ? ((ts.x = o * $a.x - i * $a.y), (ts.y = i * $a.x + o * $a.y))
          : ts.copy($a),
        t.copy(e),
        (t.x += ts.x),
        (t.y += ts.y),
        t.applyMatrix4(es);
    }
    cs.prototype = Object.assign(Object.create(Rn.prototype), {
      constructor: cs,
      isSprite: !0,
      raycast: function (t, e) {
        null === t.camera &&
          console.error(
            'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
          ),
          Qa.setFromMatrixScale(this.matrixWorld),
          es.copy(t.camera.matrixWorld),
          this.modelViewMatrix.multiplyMatrices(
            t.camera.matrixWorldInverse,
            this.matrixWorld
          ),
          Ka.setFromMatrixPosition(this.modelViewMatrix),
          t.camera.isPerspectiveCamera &&
            !1 === this.material.sizeAttenuation &&
            Qa.multiplyScalar(-Ka.z);
        var n,
          r,
          i = this.material.rotation;
        0 !== i && ((r = Math.cos(i)), (n = Math.sin(i)));
        var o = this.center;
        us(ns.set(-0.5, -0.5, 0), Ka, o, Qa, n, r),
          us(rs.set(0.5, -0.5, 0), Ka, o, Qa, n, r),
          us(is.set(0.5, 0.5, 0), Ka, o, Qa, n, r),
          os.set(0, 0),
          as.set(1, 0),
          ss.set(1, 1);
        var a = t.ray.intersectTriangle(ns, rs, is, !1, Za);
        if (
          null !== a ||
          (us(rs.set(-0.5, 0.5, 0), Ka, o, Qa, n, r),
          as.set(0, 1),
          null !== (a = t.ray.intersectTriangle(ns, is, rs, !1, Za)))
        ) {
          var s = t.ray.origin.distanceTo(Za);
          s < t.near ||
            s > t.far ||
            e.push({
              distance: s,
              point: Za.clone(),
              uv: pr.getUV(Za, ns, rs, is, os, as, ss, new ke()),
              face: null,
              object: this,
            });
        }
      },
      clone: function () {
        return new this.constructor(this.material).copy(this);
      },
      copy: function (t) {
        return (
          Rn.prototype.copy.call(this, t),
          void 0 !== t.center && this.center.copy(t.center),
          this
        );
      },
    });
    var ls = new Ye(),
      hs = new Ye();
    function ps() {
      Rn.call(this),
        (this.type = "LOD"),
        Object.defineProperties(this, {
          levels: { enumerable: !0, value: [] },
        }),
        (this.autoUpdate = !0);
    }
    function fs(t, e) {
      t &&
        t.isGeometry &&
        console.error(
          "THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        ),
        si.call(this, t, e),
        (this.type = "SkinnedMesh"),
        (this.bindMode = "attached"),
        (this.bindMatrix = new pn()),
        (this.bindMatrixInverse = new pn());
    }
    (ps.prototype = Object.assign(Object.create(Rn.prototype), {
      constructor: ps,
      isLOD: !0,
      copy: function (t) {
        Rn.prototype.copy.call(this, t, !1);
        for (var e = t.levels, n = 0, r = e.length; n < r; n++) {
          var i = e[n];
          this.addLevel(i.object.clone(), i.distance);
        }
        return this;
      },
      addLevel: function (t, e) {
        void 0 === e && (e = 0), (e = Math.abs(e));
        for (
          var n = this.levels, r = 0;
          r < n.length && !(e < n[r].distance);
          r++
        );
        return n.splice(r, 0, { distance: e, object: t }), this.add(t), this;
      },
      getObjectForDistance: function (t) {
        for (
          var e = this.levels, n = 1, r = e.length;
          n < r && !(t < e[n].distance);
          n++
        );
        return e[n - 1].object;
      },
      raycast: function (t, e) {
        ls.setFromMatrixPosition(this.matrixWorld);
        var n = t.ray.origin.distanceTo(ls);
        this.getObjectForDistance(n).raycast(t, e);
      },
      update: function (t) {
        var e = this.levels;
        if (e.length > 1) {
          ls.setFromMatrixPosition(t.matrixWorld),
            hs.setFromMatrixPosition(this.matrixWorld);
          var n = ls.distanceTo(hs);
          e[0].object.visible = !0;
          for (var r = 1, i = e.length; r < i && n >= e[r].distance; r++)
            (e[r - 1].object.visible = !1), (e[r].object.visible = !0);
          for (; r < i; r++) e[r].object.visible = !1;
        }
      },
      toJSON: function (t) {
        var e = Rn.prototype.toJSON.call(this, t);
        e.object.levels = [];
        for (var n = this.levels, r = 0, i = n.length; r < i; r++) {
          var o = n[r];
          e.object.levels.push({ object: o.object.uuid, distance: o.distance });
        }
        return e;
      },
    })),
      (fs.prototype = Object.assign(Object.create(si.prototype), {
        constructor: fs,
        isSkinnedMesh: !0,
        bind: function (t, e) {
          (this.skeleton = t),
            void 0 === e &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (e = this.matrixWorld)),
            this.bindMatrix.copy(e),
            this.bindMatrixInverse.getInverse(e);
        },
        pose: function () {
          this.skeleton.pose();
        },
        normalizeSkinWeights: function () {
          for (
            var t = new en(),
              e = this.geometry.attributes.skinWeight,
              n = 0,
              r = e.count;
            n < r;
            n++
          ) {
            (t.x = e.getX(n)),
              (t.y = e.getY(n)),
              (t.z = e.getZ(n)),
              (t.w = e.getW(n));
            var i = 1 / t.manhattanLength();
            i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
              e.setXYZW(n, t.x, t.y, t.z, t.w);
          }
        },
        updateMatrixWorld: function (t) {
          si.prototype.updateMatrixWorld.call(this, t),
            "attached" === this.bindMode
              ? this.bindMatrixInverse.getInverse(this.matrixWorld)
              : "detached" === this.bindMode
              ? this.bindMatrixInverse.getInverse(this.bindMatrix)
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                );
        },
        clone: function () {
          return new this.constructor(this.geometry, this.material).copy(this);
        },
      }));
    var ds = new pn(),
      ms = new pn();
    function vs(t, e) {
      if (
        ((t = t || []),
        (this.bones = t.slice(0)),
        (this.boneMatrices = new Float32Array(16 * this.bones.length)),
        (this.frame = -1),
        void 0 === e)
      )
        this.calculateInverses();
      else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
      else {
        console.warn("THREE.Skeleton boneInverses is the wrong length."),
          (this.boneInverses = []);
        for (var n = 0, r = this.bones.length; n < r; n++)
          this.boneInverses.push(new pn());
      }
    }
    function gs() {
      Rn.call(this), (this.type = "Bone");
    }
    function ys(t, e, n) {
      si.call(this, t, e),
        (this.instanceMatrix = new Sr(new Float32Array(16 * n), 16)),
        (this.count = n);
    }
    function xs(t) {
      _r.call(this),
        (this.type = "LineBasicMaterial"),
        (this.color = new vr(16777215)),
        (this.linewidth = 1),
        (this.linecap = "round"),
        (this.linejoin = "round"),
        this.setValues(t);
    }
    Object.assign(vs.prototype, {
      calculateInverses: function () {
        this.boneInverses = [];
        for (var t = 0, e = this.bones.length; t < e; t++) {
          var n = new pn();
          this.bones[t] && n.getInverse(this.bones[t].matrixWorld),
            this.boneInverses.push(n);
        }
      },
      pose: function () {
        var t, e, n;
        for (e = 0, n = this.bones.length; e < n; e++)
          (t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
        for (e = 0, n = this.bones.length; e < n; e++)
          (t = this.bones[e]) &&
            (t.parent && t.parent.isBone
              ? (t.matrix.getInverse(t.parent.matrixWorld),
                t.matrix.multiply(t.matrixWorld))
              : t.matrix.copy(t.matrixWorld),
            t.matrix.decompose(t.position, t.quaternion, t.scale));
      },
      update: function () {
        for (
          var t = this.bones,
            e = this.boneInverses,
            n = this.boneMatrices,
            r = this.boneTexture,
            i = 0,
            o = t.length;
          i < o;
          i++
        ) {
          var a = t[i] ? t[i].matrixWorld : ms;
          ds.multiplyMatrices(a, e[i]), ds.toArray(n, 16 * i);
        }
        void 0 !== r && (r.needsUpdate = !0);
      },
      clone: function () {
        return new vs(this.bones, this.boneInverses);
      },
      getBoneByName: function (t) {
        for (var e = 0, n = this.bones.length; e < n; e++) {
          var r = this.bones[e];
          if (r.name === t) return r;
        }
      },
    }),
      (gs.prototype = Object.assign(Object.create(Rn.prototype), {
        constructor: gs,
        isBone: !0,
      })),
      (ys.prototype = Object.assign(Object.create(si.prototype), {
        constructor: ys,
        isInstancedMesh: !0,
        raycast: function () {},
        setMatrixAt: function (t, e) {
          e.toArray(this.instanceMatrix.array, 16 * t);
        },
        updateMorphTargets: function () {},
      })),
      (xs.prototype = Object.create(_r.prototype)),
      (xs.prototype.constructor = xs),
      (xs.prototype.isLineBasicMaterial = !0),
      (xs.prototype.copy = function (t) {
        return (
          _r.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.linewidth = t.linewidth),
          (this.linecap = t.linecap),
          (this.linejoin = t.linejoin),
          this
        );
      });
    var bs = new Ye(),
      ws = new Ye(),
      _s = new pn(),
      Ms = new er(),
      Ss = new Xn();
    function Es(t, e, n) {
      1 === n &&
        console.error(
          "THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."
        ),
        Rn.call(this),
        (this.type = "Line"),
        (this.geometry = void 0 !== t ? t : new Hr()),
        (this.material =
          void 0 !== e ? e : new xs({ color: 16777215 * Math.random() }));
    }
    Es.prototype = Object.assign(Object.create(Rn.prototype), {
      constructor: Es,
      isLine: !0,
      computeLineDistances: function () {
        var t = this.geometry;
        if (t.isBufferGeometry)
          if (null === t.index) {
            for (
              var e = t.attributes.position, n = [0], r = 1, i = e.count;
              r < i;
              r++
            )
              bs.fromBufferAttribute(e, r - 1),
                ws.fromBufferAttribute(e, r),
                (n[r] = n[r - 1]),
                (n[r] += bs.distanceTo(ws));
            t.addAttribute("lineDistance", new Or(n, 1));
          } else
            console.warn(
              "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else if (t.isGeometry) {
          var o = t.vertices;
          (n = t.lineDistances)[0] = 0;
          for (r = 1, i = o.length; r < i; r++)
            (n[r] = n[r - 1]), (n[r] += o[r - 1].distanceTo(o[r]));
        }
        return this;
      },
      raycast: function (t, e) {
        var n = t.linePrecision,
          r = this.geometry,
          i = this.matrixWorld;
        if (
          (null === r.boundingSphere && r.computeBoundingSphere(),
          Ss.copy(r.boundingSphere),
          Ss.applyMatrix4(i),
          (Ss.radius += n),
          !1 !== t.ray.intersectsSphere(Ss))
        ) {
          _s.getInverse(i), Ms.copy(t.ray).applyMatrix4(_s);
          var o = n / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            a = o * o,
            s = new Ye(),
            c = new Ye(),
            u = new Ye(),
            l = new Ye(),
            h = this && this.isLineSegments ? 2 : 1;
          if (r.isBufferGeometry) {
            var p = r.index,
              f = r.attributes.position.array;
            if (null !== p)
              for (var d = p.array, m = 0, v = d.length - 1; m < v; m += h) {
                var g = d[m],
                  y = d[m + 1];
                if (
                  (s.fromArray(f, 3 * g),
                  c.fromArray(f, 3 * y),
                  !(Ms.distanceSqToSegment(s, c, l, u) > a))
                )
                  l.applyMatrix4(this.matrixWorld),
                    (w = t.ray.origin.distanceTo(l)) < t.near ||
                      w > t.far ||
                      e.push({
                        distance: w,
                        point: u.clone().applyMatrix4(this.matrixWorld),
                        index: m,
                        face: null,
                        faceIndex: null,
                        object: this,
                      });
              }
            else
              for (m = 0, v = f.length / 3 - 1; m < v; m += h) {
                if (
                  (s.fromArray(f, 3 * m),
                  c.fromArray(f, 3 * m + 3),
                  !(Ms.distanceSqToSegment(s, c, l, u) > a))
                )
                  l.applyMatrix4(this.matrixWorld),
                    (w = t.ray.origin.distanceTo(l)) < t.near ||
                      w > t.far ||
                      e.push({
                        distance: w,
                        point: u.clone().applyMatrix4(this.matrixWorld),
                        index: m,
                        face: null,
                        faceIndex: null,
                        object: this,
                      });
              }
          } else if (r.isGeometry) {
            var x = r.vertices,
              b = x.length;
            for (m = 0; m < b - 1; m += h) {
              var w;
              if (!(Ms.distanceSqToSegment(x[m], x[m + 1], l, u) > a))
                l.applyMatrix4(this.matrixWorld),
                  (w = t.ray.origin.distanceTo(l)) < t.near ||
                    w > t.far ||
                    e.push({
                      distance: w,
                      point: u.clone().applyMatrix4(this.matrixWorld),
                      index: m,
                      face: null,
                      faceIndex: null,
                      object: this,
                    });
            }
          }
        }
      },
      clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      },
    });
    var Ts = new Ye(),
      As = new Ye();
    function Ls(t, e) {
      Es.call(this, t, e), (this.type = "LineSegments");
    }
    function Ps(t, e) {
      Es.call(this, t, e), (this.type = "LineLoop");
    }
    function Rs(t) {
      _r.call(this),
        (this.type = "PointsMaterial"),
        (this.color = new vr(16777215)),
        (this.map = null),
        (this.size = 1),
        (this.sizeAttenuation = !0),
        (this.morphTargets = !1),
        this.setValues(t);
    }
    (Ls.prototype = Object.assign(Object.create(Es.prototype), {
      constructor: Ls,
      isLineSegments: !0,
      computeLineDistances: function () {
        var t = this.geometry;
        if (t.isBufferGeometry)
          if (null === t.index) {
            for (
              var e = t.attributes.position, n = [], r = 0, i = e.count;
              r < i;
              r += 2
            )
              Ts.fromBufferAttribute(e, r),
                As.fromBufferAttribute(e, r + 1),
                (n[r] = 0 === r ? 0 : n[r - 1]),
                (n[r + 1] = n[r] + Ts.distanceTo(As));
            t.addAttribute("lineDistance", new Or(n, 1));
          } else
            console.warn(
              "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else if (t.isGeometry) {
          var o = t.vertices;
          for (n = t.lineDistances, r = 0, i = o.length; r < i; r += 2)
            Ts.copy(o[r]),
              As.copy(o[r + 1]),
              (n[r] = 0 === r ? 0 : n[r - 1]),
              (n[r + 1] = n[r] + Ts.distanceTo(As));
        }
        return this;
      },
    })),
      (Ps.prototype = Object.assign(Object.create(Es.prototype), {
        constructor: Ps,
        isLineLoop: !0,
      })),
      (Rs.prototype = Object.create(_r.prototype)),
      (Rs.prototype.constructor = Rs),
      (Rs.prototype.isPointsMaterial = !0),
      (Rs.prototype.copy = function (t) {
        return (
          _r.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.size = t.size),
          (this.sizeAttenuation = t.sizeAttenuation),
          (this.morphTargets = t.morphTargets),
          this
        );
      });
    var Cs = new pn(),
      Os = new er(),
      Is = new Xn(),
      Ns = new Ye();
    function Ds(t, e) {
      Rn.call(this),
        (this.type = "Points"),
        (this.geometry = void 0 !== t ? t : new Hr()),
        (this.material =
          void 0 !== e ? e : new Rs({ color: 16777215 * Math.random() })),
        this.updateMorphTargets();
    }
    function zs(t, e, n, r, i, o, a) {
      var s = Os.distanceSqToPoint(t);
      if (s < n) {
        var c = new Ye();
        Os.closestPointToPoint(t, c), c.applyMatrix4(r);
        var u = i.ray.origin.distanceTo(c);
        if (u < i.near || u > i.far) return;
        o.push({
          distance: u,
          distanceToRay: Math.sqrt(s),
          point: c,
          index: e,
          face: null,
          object: a,
        });
      }
    }
    function Fs(t, e, n, r, i, o, a, s, c) {
      tn.call(this, t, e, n, r, i, o, a, s, c),
        (this.format = void 0 !== a ? a : Wt),
        (this.minFilter = void 0 !== o ? o : Pt),
        (this.magFilter = void 0 !== i ? i : Pt),
        (this.generateMipmaps = !1);
    }
    function Us(t, e, n, r, i, o, a, s, c, u, l, h) {
      tn.call(this, null, o, a, s, c, u, r, i, l, h),
        (this.image = { width: e, height: n }),
        (this.mipmaps = t),
        (this.flipY = !1),
        (this.generateMipmaps = !1);
    }
    function Bs(t, e, n, r, i, o, a, s, c) {
      tn.call(this, t, e, n, r, i, o, a, s, c), (this.needsUpdate = !0);
    }
    function Gs(t, e, n, r, i, o, a, s, c, u) {
      if ((u = void 0 !== u ? u : Jt) !== Jt && u !== Zt)
        throw new Error(
          "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
        );
      void 0 === n && u === Jt && (n = Dt),
        void 0 === n && u === Zt && (n = Ht),
        tn.call(this, null, r, i, o, a, s, u, n, c),
        (this.image = { width: t, height: e }),
        (this.magFilter = void 0 !== a ? a : Tt),
        (this.minFilter = void 0 !== s ? s : Tt),
        (this.flipY = !1),
        (this.generateMipmaps = !1);
    }
    function js(t) {
      Hr.call(this), (this.type = "WireframeGeometry");
      var e,
        n,
        r,
        i,
        o,
        a,
        s,
        c,
        u,
        l,
        h = [],
        p = [0, 0],
        f = {},
        d = ["a", "b", "c"];
      if (t && t.isGeometry) {
        var m = t.faces;
        for (e = 0, r = m.length; e < r; e++) {
          var v = m[e];
          for (n = 0; n < 3; n++)
            (s = v[d[n]]),
              (c = v[d[(n + 1) % 3]]),
              (p[0] = Math.min(s, c)),
              (p[1] = Math.max(s, c)),
              void 0 === f[(u = p[0] + "," + p[1])] &&
                (f[u] = { index1: p[0], index2: p[1] });
        }
        for (u in f)
          (a = f[u]),
            (l = t.vertices[a.index1]),
            h.push(l.x, l.y, l.z),
            (l = t.vertices[a.index2]),
            h.push(l.x, l.y, l.z);
      } else if (t && t.isBufferGeometry) {
        var g, y, x, b, w, _, M;
        if (((l = new Ye()), null !== t.index)) {
          for (
            g = t.attributes.position,
              y = t.index,
              0 === (x = t.groups).length &&
                (x = [{ start: 0, count: y.count, materialIndex: 0 }]),
              i = 0,
              o = x.length;
            i < o;
            ++i
          )
            for (e = w = (b = x[i]).start, r = w + b.count; e < r; e += 3)
              for (n = 0; n < 3; n++)
                (s = y.getX(e + n)),
                  (c = y.getX(e + ((n + 1) % 3))),
                  (p[0] = Math.min(s, c)),
                  (p[1] = Math.max(s, c)),
                  void 0 === f[(u = p[0] + "," + p[1])] &&
                    (f[u] = { index1: p[0], index2: p[1] });
          for (u in f)
            (a = f[u]),
              l.fromBufferAttribute(g, a.index1),
              h.push(l.x, l.y, l.z),
              l.fromBufferAttribute(g, a.index2),
              h.push(l.x, l.y, l.z);
        } else
          for (e = 0, r = (g = t.attributes.position).count / 3; e < r; e++)
            for (n = 0; n < 3; n++)
              (_ = 3 * e + n),
                l.fromBufferAttribute(g, _),
                h.push(l.x, l.y, l.z),
                (M = 3 * e + ((n + 1) % 3)),
                l.fromBufferAttribute(g, M),
                h.push(l.x, l.y, l.z);
      }
      this.addAttribute("position", new Or(h, 3));
    }
    function Vs(t, e, n) {
      di.call(this),
        (this.type = "ParametricGeometry"),
        (this.parameters = { func: t, slices: e, stacks: n }),
        this.fromBufferGeometry(new Hs(t, e, n)),
        this.mergeVertices();
    }
    function Hs(t, e, n) {
      Hr.call(this),
        (this.type = "ParametricBufferGeometry"),
        (this.parameters = { func: t, slices: e, stacks: n });
      var r,
        i,
        o = [],
        a = [],
        s = [],
        c = [],
        u = new Ye(),
        l = new Ye(),
        h = new Ye(),
        p = new Ye(),
        f = new Ye();
      t.length < 3 &&
        console.error(
          "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
        );
      var d = e + 1;
      for (r = 0; r <= n; r++) {
        var m = r / n;
        for (i = 0; i <= e; i++) {
          var v = i / e;
          t(v, m, l),
            a.push(l.x, l.y, l.z),
            v - 1e-5 >= 0
              ? (t(v - 1e-5, m, h), p.subVectors(l, h))
              : (t(v + 1e-5, m, h), p.subVectors(h, l)),
            m - 1e-5 >= 0
              ? (t(v, m - 1e-5, h), f.subVectors(l, h))
              : (t(v, m + 1e-5, h), f.subVectors(h, l)),
            u.crossVectors(p, f).normalize(),
            s.push(u.x, u.y, u.z),
            c.push(v, m);
        }
      }
      for (r = 0; r < n; r++)
        for (i = 0; i < e; i++) {
          var g = r * d + i,
            y = r * d + i + 1,
            x = (r + 1) * d + i + 1,
            b = (r + 1) * d + i;
          o.push(g, y, b), o.push(y, x, b);
        }
      this.setIndex(o),
        this.addAttribute("position", new Or(a, 3)),
        this.addAttribute("normal", new Or(s, 3)),
        this.addAttribute("uv", new Or(c, 2));
    }
    function ks(t, e, n, r) {
      di.call(this),
        (this.type = "PolyhedronGeometry"),
        (this.parameters = { vertices: t, indices: e, radius: n, detail: r }),
        this.fromBufferGeometry(new Ws(t, e, n, r)),
        this.mergeVertices();
    }
    function Ws(t, e, n, r) {
      Hr.call(this),
        (this.type = "PolyhedronBufferGeometry"),
        (this.parameters = { vertices: t, indices: e, radius: n, detail: r }),
        (n = n || 1);
      var i = [],
        o = [];
      function a(t, e, n, r) {
        var i,
          o,
          a = Math.pow(2, r),
          c = [];
        for (i = 0; i <= a; i++) {
          c[i] = [];
          var u = t.clone().lerp(n, i / a),
            l = e.clone().lerp(n, i / a),
            h = a - i;
          for (o = 0; o <= h; o++)
            c[i][o] = 0 === o && i === a ? u : u.clone().lerp(l, o / h);
        }
        for (i = 0; i < a; i++)
          for (o = 0; o < 2 * (a - i) - 1; o++) {
            var p = Math.floor(o / 2);
            o % 2 == 0
              ? (s(c[i][p + 1]), s(c[i + 1][p]), s(c[i][p]))
              : (s(c[i][p + 1]), s(c[i + 1][p + 1]), s(c[i + 1][p]));
          }
      }
      function s(t) {
        i.push(t.x, t.y, t.z);
      }
      function c(e, n) {
        var r = 3 * e;
        (n.x = t[r + 0]), (n.y = t[r + 1]), (n.z = t[r + 2]);
      }
      function u(t, e, n, r) {
        r < 0 && 1 === t.x && (o[e] = t.x - 1),
          0 === n.x && 0 === n.z && (o[e] = r / 2 / Math.PI + 0.5);
      }
      function l(t) {
        return Math.atan2(t.z, -t.x);
      }
      !(function (t) {
        for (
          var n = new Ye(), r = new Ye(), i = new Ye(), o = 0;
          o < e.length;
          o += 3
        )
          c(e[o + 0], n), c(e[o + 1], r), c(e[o + 2], i), a(n, r, i, t);
      })((r = r || 0)),
        (function (t) {
          for (var e = new Ye(), n = 0; n < i.length; n += 3)
            (e.x = i[n + 0]),
              (e.y = i[n + 1]),
              (e.z = i[n + 2]),
              e.normalize().multiplyScalar(t),
              (i[n + 0] = e.x),
              (i[n + 1] = e.y),
              (i[n + 2] = e.z);
        })(n),
        (function () {
          for (var t = new Ye(), e = 0; e < i.length; e += 3) {
            (t.x = i[e + 0]), (t.y = i[e + 1]), (t.z = i[e + 2]);
            var n = l(t) / 2 / Math.PI + 0.5,
              r =
                ((a = t),
                Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI +
                  0.5);
            o.push(n, 1 - r);
          }
          var a;
          (function () {
            for (
              var t = new Ye(),
                e = new Ye(),
                n = new Ye(),
                r = new Ye(),
                a = new ke(),
                s = new ke(),
                c = new ke(),
                h = 0,
                p = 0;
              h < i.length;
              h += 9, p += 6
            ) {
              t.set(i[h + 0], i[h + 1], i[h + 2]),
                e.set(i[h + 3], i[h + 4], i[h + 5]),
                n.set(i[h + 6], i[h + 7], i[h + 8]),
                a.set(o[p + 0], o[p + 1]),
                s.set(o[p + 2], o[p + 3]),
                c.set(o[p + 4], o[p + 5]),
                r.copy(t).add(e).add(n).divideScalar(3);
              var f = l(r);
              u(a, p + 0, t, f), u(s, p + 2, e, f), u(c, p + 4, n, f);
            }
          })(),
            (function () {
              for (var t = 0; t < o.length; t += 6) {
                var e = o[t + 0],
                  n = o[t + 2],
                  r = o[t + 4],
                  i = Math.max(e, n, r),
                  a = Math.min(e, n, r);
                i > 0.9 &&
                  a < 0.1 &&
                  (e < 0.2 && (o[t + 0] += 1),
                  n < 0.2 && (o[t + 2] += 1),
                  r < 0.2 && (o[t + 4] += 1));
              }
            })();
        })(),
        this.addAttribute("position", new Or(i, 3)),
        this.addAttribute("normal", new Or(i.slice(), 3)),
        this.addAttribute("uv", new Or(o, 2)),
        0 === r ? this.computeVertexNormals() : this.normalizeNormals();
    }
    function qs(t, e) {
      di.call(this),
        (this.type = "TetrahedronGeometry"),
        (this.parameters = { radius: t, detail: e }),
        this.fromBufferGeometry(new Xs(t, e)),
        this.mergeVertices();
    }
    function Xs(t, e) {
      Ws.call(
        this,
        [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
        [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
        t,
        e
      ),
        (this.type = "TetrahedronBufferGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    function Ys(t, e) {
      di.call(this),
        (this.type = "OctahedronGeometry"),
        (this.parameters = { radius: t, detail: e }),
        this.fromBufferGeometry(new Js(t, e)),
        this.mergeVertices();
    }
    function Js(t, e) {
      Ws.call(
        this,
        [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
        [
          0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4,
          2,
        ],
        t,
        e
      ),
        (this.type = "OctahedronBufferGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    function Zs(t, e) {
      di.call(this),
        (this.type = "IcosahedronGeometry"),
        (this.parameters = { radius: t, detail: e }),
        this.fromBufferGeometry(new Qs(t, e)),
        this.mergeVertices();
    }
    function Qs(t, e) {
      var n = (1 + Math.sqrt(5)) / 2,
        r = [
          -1,
          n,
          0,
          1,
          n,
          0,
          -1,
          -n,
          0,
          1,
          -n,
          0,
          0,
          -1,
          n,
          0,
          1,
          n,
          0,
          -1,
          -n,
          0,
          1,
          -n,
          n,
          0,
          -1,
          n,
          0,
          1,
          -n,
          0,
          -1,
          -n,
          0,
          1,
        ];
      Ws.call(
        this,
        r,
        [
          0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4,
          11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3,
          8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
        ],
        t,
        e
      ),
        (this.type = "IcosahedronBufferGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    function Ks(t, e) {
      di.call(this),
        (this.type = "DodecahedronGeometry"),
        (this.parameters = { radius: t, detail: e }),
        this.fromBufferGeometry(new $s(t, e)),
        this.mergeVertices();
    }
    function $s(t, e) {
      var n = (1 + Math.sqrt(5)) / 2,
        r = 1 / n,
        i = [
          -1,
          -1,
          -1,
          -1,
          -1,
          1,
          -1,
          1,
          -1,
          -1,
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          1,
          1,
          1,
          -1,
          1,
          1,
          1,
          0,
          -r,
          -n,
          0,
          -r,
          n,
          0,
          r,
          -n,
          0,
          r,
          n,
          -r,
          -n,
          0,
          -r,
          n,
          0,
          r,
          -n,
          0,
          r,
          n,
          0,
          -n,
          0,
          -r,
          n,
          0,
          -r,
          -n,
          0,
          r,
          n,
          0,
          r,
        ];
      Ws.call(
        this,
        i,
        [
          3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4,
          8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1,
          18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2,
          3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8,
          11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1,
          12, 14, 1, 14, 5, 1, 5, 9,
        ],
        t,
        e
      ),
        (this.type = "DodecahedronBufferGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    function tc(t, e, n, r, i, o) {
      di.call(this),
        (this.type = "TubeGeometry"),
        (this.parameters = {
          path: t,
          tubularSegments: e,
          radius: n,
          radialSegments: r,
          closed: i,
        }),
        void 0 !== o &&
          console.warn("THREE.TubeGeometry: taper has been removed.");
      var a = new ec(t, e, n, r, i);
      (this.tangents = a.tangents),
        (this.normals = a.normals),
        (this.binormals = a.binormals),
        this.fromBufferGeometry(a),
        this.mergeVertices();
    }
    function ec(t, e, n, r, i) {
      Hr.call(this),
        (this.type = "TubeBufferGeometry"),
        (this.parameters = {
          path: t,
          tubularSegments: e,
          radius: n,
          radialSegments: r,
          closed: i,
        }),
        (e = e || 64),
        (n = n || 1),
        (r = r || 8),
        (i = i || !1);
      var o = t.computeFrenetFrames(e, i);
      (this.tangents = o.tangents),
        (this.normals = o.normals),
        (this.binormals = o.binormals);
      var a,
        s,
        c = new Ye(),
        u = new Ye(),
        l = new ke(),
        h = new Ye(),
        p = [],
        f = [],
        d = [],
        m = [];
      function v(i) {
        h = t.getPointAt(i / e, h);
        var a = o.normals[i],
          l = o.binormals[i];
        for (s = 0; s <= r; s++) {
          var d = (s / r) * Math.PI * 2,
            m = Math.sin(d),
            v = -Math.cos(d);
          (u.x = v * a.x + m * l.x),
            (u.y = v * a.y + m * l.y),
            (u.z = v * a.z + m * l.z),
            u.normalize(),
            f.push(u.x, u.y, u.z),
            (c.x = h.x + n * u.x),
            (c.y = h.y + n * u.y),
            (c.z = h.z + n * u.z),
            p.push(c.x, c.y, c.z);
        }
      }
      !(function () {
        for (a = 0; a < e; a++) v(a);
        v(!1 === i ? e : 0),
          (function () {
            for (a = 0; a <= e; a++)
              for (s = 0; s <= r; s++)
                (l.x = a / e), (l.y = s / r), d.push(l.x, l.y);
          })(),
          (function () {
            for (s = 1; s <= e; s++)
              for (a = 1; a <= r; a++) {
                var t = (r + 1) * (s - 1) + (a - 1),
                  n = (r + 1) * s + (a - 1),
                  i = (r + 1) * s + a,
                  o = (r + 1) * (s - 1) + a;
                m.push(t, n, o), m.push(n, i, o);
              }
          })();
      })(),
        this.setIndex(m),
        this.addAttribute("position", new Or(p, 3)),
        this.addAttribute("normal", new Or(f, 3)),
        this.addAttribute("uv", new Or(d, 2));
    }
    function nc(t, e, n, r, i, o, a) {
      di.call(this),
        (this.type = "TorusKnotGeometry"),
        (this.parameters = {
          radius: t,
          tube: e,
          tubularSegments: n,
          radialSegments: r,
          p: i,
          q: o,
        }),
        void 0 !== a &&
          console.warn(
            "THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
          ),
        this.fromBufferGeometry(new rc(t, e, n, r, i, o)),
        this.mergeVertices();
    }
    function rc(t, e, n, r, i, o) {
      Hr.call(this),
        (this.type = "TorusKnotBufferGeometry"),
        (this.parameters = {
          radius: t,
          tube: e,
          tubularSegments: n,
          radialSegments: r,
          p: i,
          q: o,
        }),
        (t = t || 1),
        (e = e || 0.4),
        (n = Math.floor(n) || 64),
        (r = Math.floor(r) || 8),
        (i = i || 2),
        (o = o || 3);
      var a,
        s,
        c = [],
        u = [],
        l = [],
        h = [],
        p = new Ye(),
        f = new Ye(),
        d = new Ye(),
        m = new Ye(),
        v = new Ye(),
        g = new Ye(),
        y = new Ye();
      for (a = 0; a <= n; ++a) {
        var x = (a / n) * i * Math.PI * 2;
        for (
          A(x, i, o, t, d),
            A(x + 0.01, i, o, t, m),
            g.subVectors(m, d),
            y.addVectors(m, d),
            v.crossVectors(g, y),
            y.crossVectors(v, g),
            v.normalize(),
            y.normalize(),
            s = 0;
          s <= r;
          ++s
        ) {
          var b = (s / r) * Math.PI * 2,
            w = -e * Math.cos(b),
            _ = e * Math.sin(b);
          (p.x = d.x + (w * y.x + _ * v.x)),
            (p.y = d.y + (w * y.y + _ * v.y)),
            (p.z = d.z + (w * y.z + _ * v.z)),
            u.push(p.x, p.y, p.z),
            f.subVectors(p, d).normalize(),
            l.push(f.x, f.y, f.z),
            h.push(a / n),
            h.push(s / r);
        }
      }
      for (s = 1; s <= n; s++)
        for (a = 1; a <= r; a++) {
          var M = (r + 1) * (s - 1) + (a - 1),
            S = (r + 1) * s + (a - 1),
            E = (r + 1) * s + a,
            T = (r + 1) * (s - 1) + a;
          c.push(M, S, T), c.push(S, E, T);
        }
      function A(t, e, n, r, i) {
        var o = Math.cos(t),
          a = Math.sin(t),
          s = (n / e) * t,
          c = Math.cos(s);
        (i.x = r * (2 + c) * 0.5 * o),
          (i.y = r * (2 + c) * a * 0.5),
          (i.z = r * Math.sin(s) * 0.5);
      }
      this.setIndex(c),
        this.addAttribute("position", new Or(u, 3)),
        this.addAttribute("normal", new Or(l, 3)),
        this.addAttribute("uv", new Or(h, 2));
    }
    function ic(t, e, n, r, i) {
      di.call(this),
        (this.type = "TorusGeometry"),
        (this.parameters = {
          radius: t,
          tube: e,
          radialSegments: n,
          tubularSegments: r,
          arc: i,
        }),
        this.fromBufferGeometry(new oc(t, e, n, r, i)),
        this.mergeVertices();
    }
    function oc(t, e, n, r, i) {
      Hr.call(this),
        (this.type = "TorusBufferGeometry"),
        (this.parameters = {
          radius: t,
          tube: e,
          radialSegments: n,
          tubularSegments: r,
          arc: i,
        }),
        (t = t || 1),
        (e = e || 0.4),
        (n = Math.floor(n) || 8),
        (r = Math.floor(r) || 6),
        (i = i || 2 * Math.PI);
      var o,
        a,
        s = [],
        c = [],
        u = [],
        l = [],
        h = new Ye(),
        p = new Ye(),
        f = new Ye();
      for (o = 0; o <= n; o++)
        for (a = 0; a <= r; a++) {
          var d = (a / r) * i,
            m = (o / n) * Math.PI * 2;
          (p.x = (t + e * Math.cos(m)) * Math.cos(d)),
            (p.y = (t + e * Math.cos(m)) * Math.sin(d)),
            (p.z = e * Math.sin(m)),
            c.push(p.x, p.y, p.z),
            (h.x = t * Math.cos(d)),
            (h.y = t * Math.sin(d)),
            f.subVectors(p, h).normalize(),
            u.push(f.x, f.y, f.z),
            l.push(a / r),
            l.push(o / n);
        }
      for (o = 1; o <= n; o++)
        for (a = 1; a <= r; a++) {
          var v = (r + 1) * o + a - 1,
            g = (r + 1) * (o - 1) + a - 1,
            y = (r + 1) * (o - 1) + a,
            x = (r + 1) * o + a;
          s.push(v, g, x), s.push(g, y, x);
        }
      this.setIndex(s),
        this.addAttribute("position", new Or(c, 3)),
        this.addAttribute("normal", new Or(u, 3)),
        this.addAttribute("uv", new Or(l, 2));
    }
    (Ds.prototype = Object.assign(Object.create(Rn.prototype), {
      constructor: Ds,
      isPoints: !0,
      raycast: function (t, e) {
        var n = this.geometry,
          r = this.matrixWorld,
          i = t.params.Points.threshold;
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          Is.copy(n.boundingSphere),
          Is.applyMatrix4(r),
          (Is.radius += i),
          !1 !== t.ray.intersectsSphere(Is))
        ) {
          Cs.getInverse(r), Os.copy(t.ray).applyMatrix4(Cs);
          var o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            a = o * o;
          if (n.isBufferGeometry) {
            var s = n.index,
              c = n.attributes.position.array;
            if (null !== s)
              for (var u = s.array, l = 0, h = u.length; l < h; l++) {
                var p = u[l];
                Ns.fromArray(c, 3 * p), zs(Ns, p, a, r, t, e, this);
              }
            else {
              l = 0;
              for (var f = c.length / 3; l < f; l++)
                Ns.fromArray(c, 3 * l), zs(Ns, l, a, r, t, e, this);
            }
          } else {
            var d = n.vertices;
            for (l = 0, f = d.length; l < f; l++) zs(d[l], l, a, r, t, e, this);
          }
        }
      },
      updateMorphTargets: function () {
        var t,
          e,
          n,
          r = this.geometry;
        if (r.isBufferGeometry) {
          var i = r.morphAttributes,
            o = Object.keys(i);
          if (o.length > 0) {
            var a = i[o[0]];
            if (void 0 !== a)
              for (
                this.morphTargetInfluences = [],
                  this.morphTargetDictionary = {},
                  t = 0,
                  e = a.length;
                t < e;
                t++
              )
                (n = a[t].name || String(t)),
                  this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = t);
          }
        } else {
          var s = r.morphTargets;
          void 0 !== s &&
            s.length > 0 &&
            console.error(
              "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
      },
      clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      },
    })),
      (Fs.prototype = Object.assign(Object.create(tn.prototype), {
        constructor: Fs,
        isVideoTexture: !0,
        update: function () {
          var t = this.image;
          t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
        },
      })),
      (Us.prototype = Object.create(tn.prototype)),
      (Us.prototype.constructor = Us),
      (Us.prototype.isCompressedTexture = !0),
      (Bs.prototype = Object.create(tn.prototype)),
      (Bs.prototype.constructor = Bs),
      (Bs.prototype.isCanvasTexture = !0),
      (Gs.prototype = Object.create(tn.prototype)),
      (Gs.prototype.constructor = Gs),
      (Gs.prototype.isDepthTexture = !0),
      (js.prototype = Object.create(Hr.prototype)),
      (js.prototype.constructor = js),
      (Vs.prototype = Object.create(di.prototype)),
      (Vs.prototype.constructor = Vs),
      (Hs.prototype = Object.create(Hr.prototype)),
      (Hs.prototype.constructor = Hs),
      (ks.prototype = Object.create(di.prototype)),
      (ks.prototype.constructor = ks),
      (Ws.prototype = Object.create(Hr.prototype)),
      (Ws.prototype.constructor = Ws),
      (qs.prototype = Object.create(di.prototype)),
      (qs.prototype.constructor = qs),
      (Xs.prototype = Object.create(Ws.prototype)),
      (Xs.prototype.constructor = Xs),
      (Ys.prototype = Object.create(di.prototype)),
      (Ys.prototype.constructor = Ys),
      (Js.prototype = Object.create(Ws.prototype)),
      (Js.prototype.constructor = Js),
      (Zs.prototype = Object.create(di.prototype)),
      (Zs.prototype.constructor = Zs),
      (Qs.prototype = Object.create(Ws.prototype)),
      (Qs.prototype.constructor = Qs),
      (Ks.prototype = Object.create(di.prototype)),
      (Ks.prototype.constructor = Ks),
      ($s.prototype = Object.create(Ws.prototype)),
      ($s.prototype.constructor = $s),
      (tc.prototype = Object.create(di.prototype)),
      (tc.prototype.constructor = tc),
      (ec.prototype = Object.create(Hr.prototype)),
      (ec.prototype.constructor = ec),
      (ec.prototype.toJSON = function () {
        var t = Hr.prototype.toJSON.call(this);
        return (t.path = this.parameters.path.toJSON()), t;
      }),
      (nc.prototype = Object.create(di.prototype)),
      (nc.prototype.constructor = nc),
      (rc.prototype = Object.create(Hr.prototype)),
      (rc.prototype.constructor = rc),
      (ic.prototype = Object.create(di.prototype)),
      (ic.prototype.constructor = ic),
      (oc.prototype = Object.create(Hr.prototype)),
      (oc.prototype.constructor = oc);
    var ac = function (t, e, n) {
      n = n || 2;
      var r,
        i,
        o,
        a,
        s,
        c,
        u,
        l = e && e.length,
        h = l ? e[0] * n : t.length,
        p = sc(t, 0, h, n, !0),
        f = [];
      if (!p || p.next === p.prev) return f;
      if (
        (l &&
          (p = (function (t, e, n, r) {
            var i,
              o,
              a,
              s,
              c,
              u = [];
            for (i = 0, o = e.length; i < o; i++)
              (a = e[i] * r),
                (s = i < o - 1 ? e[i + 1] * r : t.length),
                (c = sc(t, a, s, r, !1)) === c.next && (c.steiner = !0),
                u.push(gc(c));
            for (u.sort(dc), i = 0; i < u.length; i++)
              mc(u[i], n), (n = cc(n, n.next));
            return n;
          })(t, e, p, n)),
        t.length > 80 * n)
      ) {
        (r = o = t[0]), (i = a = t[1]);
        for (var d = n; d < h; d += n)
          (s = t[d]) < r && (r = s),
            (c = t[d + 1]) < i && (i = c),
            s > o && (o = s),
            c > a && (a = c);
        u = 0 !== (u = Math.max(o - r, a - i)) ? 1 / u : 0;
      }
      return uc(p, f, n, r, i, u), f;
    };
    function sc(t, e, n, r, i) {
      var o, a;
      if (
        i ===
        (function (t, e, n, r) {
          for (var i = 0, o = e, a = n - r; o < n; o += r)
            (i += (t[a] - t[o]) * (t[o + 1] + t[a + 1])), (a = o);
          return i;
        })(t, e, n, r) >
          0
      )
        for (o = e; o < n; o += r) a = Ec(o, t[o], t[o + 1], a);
      else for (o = n - r; o >= e; o -= r) a = Ec(o, t[o], t[o + 1], a);
      return a && wc(a, a.next) && (Tc(a), (a = a.next)), a;
    }
    function cc(t, e) {
      if (!t) return t;
      e || (e = t);
      var n,
        r = t;
      do {
        if (
          ((n = !1),
          r.steiner || (!wc(r, r.next) && 0 !== bc(r.prev, r, r.next)))
        )
          r = r.next;
        else {
          if ((Tc(r), (r = e = r.prev) === r.next)) break;
          n = !0;
        }
      } while (n || r !== e);
      return e;
    }
    function uc(t, e, n, r, i, o, a) {
      if (t) {
        !a &&
          o &&
          (function (t, e, n, r) {
            var i = t;
            do {
              null === i.z && (i.z = vc(i.x, i.y, e, n, r)),
                (i.prevZ = i.prev),
                (i.nextZ = i.next),
                (i = i.next);
            } while (i !== t);
            (i.prevZ.nextZ = null),
              (i.prevZ = null),
              (function (t) {
                var e,
                  n,
                  r,
                  i,
                  o,
                  a,
                  s,
                  c,
                  u = 1;
                do {
                  for (n = t, t = null, o = null, a = 0; n; ) {
                    for (
                      a++, r = n, s = 0, e = 0;
                      e < u && (s++, (r = r.nextZ));
                      e++
                    );
                    for (c = u; s > 0 || (c > 0 && r); )
                      0 !== s && (0 === c || !r || n.z <= r.z)
                        ? ((i = n), (n = n.nextZ), s--)
                        : ((i = r), (r = r.nextZ), c--),
                        o ? (o.nextZ = i) : (t = i),
                        (i.prevZ = o),
                        (o = i);
                    n = r;
                  }
                  (o.nextZ = null), (u *= 2);
                } while (a > 1);
              })(i);
          })(t, r, i, o);
        for (var s, c, u = t; t.prev !== t.next; )
          if (((s = t.prev), (c = t.next), o ? hc(t, r, i, o) : lc(t)))
            e.push(s.i / n),
              e.push(t.i / n),
              e.push(c.i / n),
              Tc(t),
              (t = c.next),
              (u = c.next);
          else if ((t = c) === u) {
            a
              ? 1 === a
                ? uc((t = pc(t, e, n)), e, n, r, i, o, 2)
                : 2 === a && fc(t, e, n, r, i, o)
              : uc(cc(t), e, n, r, i, o, 1);
            break;
          }
      }
    }
    function lc(t) {
      var e = t.prev,
        n = t,
        r = t.next;
      if (bc(e, n, r) >= 0) return !1;
      for (var i = t.next.next; i !== t.prev; ) {
        if (
          yc(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) &&
          bc(i.prev, i, i.next) >= 0
        )
          return !1;
        i = i.next;
      }
      return !0;
    }
    function hc(t, e, n, r) {
      var i = t.prev,
        o = t,
        a = t.next;
      if (bc(i, o, a) >= 0) return !1;
      for (
        var s = i.x < o.x ? (i.x < a.x ? i.x : a.x) : o.x < a.x ? o.x : a.x,
          c = i.y < o.y ? (i.y < a.y ? i.y : a.y) : o.y < a.y ? o.y : a.y,
          u = i.x > o.x ? (i.x > a.x ? i.x : a.x) : o.x > a.x ? o.x : a.x,
          l = i.y > o.y ? (i.y > a.y ? i.y : a.y) : o.y > a.y ? o.y : a.y,
          h = vc(s, c, e, n, r),
          p = vc(u, l, e, n, r),
          f = t.prevZ,
          d = t.nextZ;
        f && f.z >= h && d && d.z <= p;

      ) {
        if (
          f !== t.prev &&
          f !== t.next &&
          yc(i.x, i.y, o.x, o.y, a.x, a.y, f.x, f.y) &&
          bc(f.prev, f, f.next) >= 0
        )
          return !1;
        if (
          ((f = f.prevZ),
          d !== t.prev &&
            d !== t.next &&
            yc(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) &&
            bc(d.prev, d, d.next) >= 0)
        )
          return !1;
        d = d.nextZ;
      }
      for (; f && f.z >= h; ) {
        if (
          f !== t.prev &&
          f !== t.next &&
          yc(i.x, i.y, o.x, o.y, a.x, a.y, f.x, f.y) &&
          bc(f.prev, f, f.next) >= 0
        )
          return !1;
        f = f.prevZ;
      }
      for (; d && d.z <= p; ) {
        if (
          d !== t.prev &&
          d !== t.next &&
          yc(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) &&
          bc(d.prev, d, d.next) >= 0
        )
          return !1;
        d = d.nextZ;
      }
      return !0;
    }
    function pc(t, e, n) {
      var r = t;
      do {
        var i = r.prev,
          o = r.next.next;
        !wc(i, o) &&
          _c(i, r, r.next, o) &&
          Mc(i, o) &&
          Mc(o, i) &&
          (e.push(i.i / n),
          e.push(r.i / n),
          e.push(o.i / n),
          Tc(r),
          Tc(r.next),
          (r = t = o)),
          (r = r.next);
      } while (r !== t);
      return r;
    }
    function fc(t, e, n, r, i, o) {
      var a = t;
      do {
        for (var s = a.next.next; s !== a.prev; ) {
          if (a.i !== s.i && xc(a, s)) {
            var c = Sc(a, s);
            return (
              (a = cc(a, a.next)),
              (c = cc(c, c.next)),
              uc(a, e, n, r, i, o),
              void uc(c, e, n, r, i, o)
            );
          }
          s = s.next;
        }
        a = a.next;
      } while (a !== t);
    }
    function dc(t, e) {
      return t.x - e.x;
    }
    function mc(t, e) {
      if (
        (e = (function (t, e) {
          var n,
            r = e,
            i = t.x,
            o = t.y,
            a = -1 / 0;
          do {
            if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
              var s = r.x + ((o - r.y) * (r.next.x - r.x)) / (r.next.y - r.y);
              if (s <= i && s > a) {
                if (((a = s), s === i)) {
                  if (o === r.y) return r;
                  if (o === r.next.y) return r.next;
                }
                n = r.x < r.next.x ? r : r.next;
              }
            }
            r = r.next;
          } while (r !== e);
          if (!n) return null;
          if (i === a) return n.prev;
          var c,
            u = n,
            l = n.x,
            h = n.y,
            p = 1 / 0;
          r = n.next;
          for (; r !== u; )
            i >= r.x &&
              r.x >= l &&
              i !== r.x &&
              yc(o < h ? i : a, o, l, h, o < h ? a : i, o, r.x, r.y) &&
              ((c = Math.abs(o - r.y) / (i - r.x)) < p ||
                (c === p && r.x > n.x)) &&
              Mc(r, t) &&
              ((n = r), (p = c)),
              (r = r.next);
          return n;
        })(t, e))
      ) {
        var n = Sc(e, t);
        cc(n, n.next);
      }
    }
    function vc(t, e, n, r, i) {
      return (
        (t =
          1431655765 &
          ((t =
            858993459 &
            ((t =
              252645135 &
              ((t = 16711935 & ((t = 32767 * (t - n) * i) | (t << 8))) |
                (t << 4))) |
              (t << 2))) |
            (t << 1))) |
        ((e =
          1431655765 &
          ((e =
            858993459 &
            ((e =
              252645135 &
              ((e = 16711935 & ((e = 32767 * (e - r) * i) | (e << 8))) |
                (e << 4))) |
              (e << 2))) |
            (e << 1))) <<
          1)
      );
    }
    function gc(t) {
      var e = t,
        n = t;
      do {
        (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
      } while (e !== t);
      return n;
    }
    function yc(t, e, n, r, i, o, a, s) {
      return (
        (i - a) * (e - s) - (t - a) * (o - s) >= 0 &&
        (t - a) * (r - s) - (n - a) * (e - s) >= 0 &&
        (n - a) * (o - s) - (i - a) * (r - s) >= 0
      );
    }
    function xc(t, e) {
      return (
        t.next.i !== e.i &&
        t.prev.i !== e.i &&
        !(function (t, e) {
          var n = t;
          do {
            if (
              n.i !== t.i &&
              n.next.i !== t.i &&
              n.i !== e.i &&
              n.next.i !== e.i &&
              _c(n, n.next, t, e)
            )
              return !0;
            n = n.next;
          } while (n !== t);
          return !1;
        })(t, e) &&
        Mc(t, e) &&
        Mc(e, t) &&
        (function (t, e) {
          var n = t,
            r = !1,
            i = (t.x + e.x) / 2,
            o = (t.y + e.y) / 2;
          do {
            n.y > o != n.next.y > o &&
              n.next.y !== n.y &&
              i < ((n.next.x - n.x) * (o - n.y)) / (n.next.y - n.y) + n.x &&
              (r = !r),
              (n = n.next);
          } while (n !== t);
          return r;
        })(t, e)
      );
    }
    function bc(t, e, n) {
      return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
    }
    function wc(t, e) {
      return t.x === e.x && t.y === e.y;
    }
    function _c(t, e, n, r) {
      return (
        !!((wc(t, n) && wc(e, r)) || (wc(t, r) && wc(n, e))) ||
        (bc(t, e, n) > 0 != bc(t, e, r) > 0 &&
          bc(n, r, t) > 0 != bc(n, r, e) > 0)
      );
    }
    function Mc(t, e) {
      return bc(t.prev, t, t.next) < 0
        ? bc(t, e, t.next) >= 0 && bc(t, t.prev, e) >= 0
        : bc(t, e, t.prev) < 0 || bc(t, t.next, e) < 0;
    }
    function Sc(t, e) {
      var n = new Ac(t.i, t.x, t.y),
        r = new Ac(e.i, e.x, e.y),
        i = t.next,
        o = e.prev;
      return (
        (t.next = e),
        (e.prev = t),
        (n.next = i),
        (i.prev = n),
        (r.next = n),
        (n.prev = r),
        (o.next = r),
        (r.prev = o),
        r
      );
    }
    function Ec(t, e, n, r) {
      var i = new Ac(t, e, n);
      return (
        r
          ? ((i.next = r.next), (i.prev = r), (r.next.prev = i), (r.next = i))
          : ((i.prev = i), (i.next = i)),
        i
      );
    }
    function Tc(t) {
      (t.next.prev = t.prev),
        (t.prev.next = t.next),
        t.prevZ && (t.prevZ.nextZ = t.nextZ),
        t.nextZ && (t.nextZ.prevZ = t.prevZ);
    }
    function Ac(t, e, n) {
      (this.i = t),
        (this.x = e),
        (this.y = n),
        (this.prev = null),
        (this.next = null),
        (this.z = null),
        (this.prevZ = null),
        (this.nextZ = null),
        (this.steiner = !1);
    }
    var Lc = {
      area: function (t) {
        for (var e = t.length, n = 0, r = e - 1, i = 0; i < e; r = i++)
          n += t[r].x * t[i].y - t[i].x * t[r].y;
        return 0.5 * n;
      },
      isClockWise: function (t) {
        return Lc.area(t) < 0;
      },
      triangulateShape: function (t, e) {
        var n = [],
          r = [],
          i = [];
        Pc(t), Rc(n, t);
        var o = t.length;
        e.forEach(Pc);
        for (var a = 0; a < e.length; a++)
          r.push(o), (o += e[a].length), Rc(n, e[a]);
        var s = ac(n, r);
        for (a = 0; a < s.length; a += 3) i.push(s.slice(a, a + 3));
        return i;
      },
    };
    function Pc(t) {
      var e = t.length;
      e > 2 && t[e - 1].equals(t[0]) && t.pop();
    }
    function Rc(t, e) {
      for (var n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
    }
    function Cc(t, e) {
      di.call(this),
        (this.type = "ExtrudeGeometry"),
        (this.parameters = { shapes: t, options: e }),
        this.fromBufferGeometry(new Oc(t, e)),
        this.mergeVertices();
    }
    function Oc(t, e) {
      Hr.call(this),
        (this.type = "ExtrudeBufferGeometry"),
        (this.parameters = { shapes: t, options: e }),
        (t = Array.isArray(t) ? t : [t]);
      for (var n = this, r = [], i = [], o = 0, a = t.length; o < a; o++) {
        s(t[o]);
      }
      function s(t) {
        var o = [],
          a = void 0 !== e.curveSegments ? e.curveSegments : 12,
          s = void 0 !== e.steps ? e.steps : 1,
          c = void 0 !== e.depth ? e.depth : 100,
          u = void 0 === e.bevelEnabled || e.bevelEnabled,
          l = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
          h = void 0 !== e.bevelSize ? e.bevelSize : l - 2,
          p = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
          f = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
          d = e.extrudePath,
          m = void 0 !== e.UVGenerator ? e.UVGenerator : Ic;
        void 0 !== e.amount &&
          (console.warn(
            "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
          ),
          (c = e.amount));
        var v,
          g,
          y,
          x,
          b,
          w,
          _,
          M,
          S = !1;
        d &&
          ((v = d.getSpacedPoints(s)),
          (S = !0),
          (u = !1),
          (g = d.computeFrenetFrames(s, !1)),
          (y = new Ye()),
          (x = new Ye()),
          (b = new Ye())),
          u || ((f = 0), (l = 0), (h = 0), (p = 0));
        var E = t.extractPoints(a),
          T = E.shape,
          A = E.holes;
        if (!Lc.isClockWise(T))
          for (T = T.reverse(), _ = 0, M = A.length; _ < M; _++)
            (w = A[_]), Lc.isClockWise(w) && (A[_] = w.reverse());
        var L = Lc.triangulateShape(T, A),
          P = T;
        for (_ = 0, M = A.length; _ < M; _++) (w = A[_]), (T = T.concat(w));
        function R(t, e, n) {
          return (
            e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
            e.clone().multiplyScalar(n).add(t)
          );
        }
        var C,
          O,
          I,
          N,
          D,
          z,
          F = T.length,
          U = L.length;
        function B(t, e, n) {
          var r,
            i,
            o,
            a = t.x - e.x,
            s = t.y - e.y,
            c = n.x - t.x,
            u = n.y - t.y,
            l = a * a + s * s,
            h = a * u - s * c;
          if (Math.abs(h) > Number.EPSILON) {
            var p = Math.sqrt(l),
              f = Math.sqrt(c * c + u * u),
              d = e.x - s / p,
              m = e.y + a / p,
              v =
                ((n.x - u / f - d) * u - (n.y + c / f - m) * c) /
                (a * u - s * c),
              g = (r = d + a * v - t.x) * r + (i = m + s * v - t.y) * i;
            if (g <= 2) return new ke(r, i);
            o = Math.sqrt(g / 2);
          } else {
            var y = !1;
            a > Number.EPSILON
              ? c > Number.EPSILON && (y = !0)
              : a < -Number.EPSILON
              ? c < -Number.EPSILON && (y = !0)
              : Math.sign(s) === Math.sign(u) && (y = !0),
              y
                ? ((r = -s), (i = a), (o = Math.sqrt(l)))
                : ((r = a), (i = s), (o = Math.sqrt(l / 2)));
          }
          return new ke(r / o, i / o);
        }
        for (
          var G = [], j = 0, V = P.length, H = V - 1, k = j + 1;
          j < V;
          j++, H++, k++
        )
          H === V && (H = 0), k === V && (k = 0), (G[j] = B(P[j], P[H], P[k]));
        var W,
          q,
          X = [],
          Y = G.concat();
        for (_ = 0, M = A.length; _ < M; _++) {
          for (
            w = A[_], W = [], j = 0, H = (V = w.length) - 1, k = j + 1;
            j < V;
            j++, H++, k++
          )
            H === V && (H = 0),
              k === V && (k = 0),
              (W[j] = B(w[j], w[H], w[k]));
          X.push(W), (Y = Y.concat(W));
        }
        for (C = 0; C < f; C++) {
          for (
            I = C / f,
              N = l * Math.cos((I * Math.PI) / 2),
              O = h * Math.sin((I * Math.PI) / 2) + p,
              j = 0,
              V = P.length;
            j < V;
            j++
          )
            Z((D = R(P[j], G[j], O)).x, D.y, -N);
          for (_ = 0, M = A.length; _ < M; _++)
            for (w = A[_], W = X[_], j = 0, V = w.length; j < V; j++)
              Z((D = R(w[j], W[j], O)).x, D.y, -N);
        }
        for (O = h + p, j = 0; j < F; j++)
          (D = u ? R(T[j], Y[j], O) : T[j]),
            S
              ? (x.copy(g.normals[0]).multiplyScalar(D.x),
                y.copy(g.binormals[0]).multiplyScalar(D.y),
                b.copy(v[0]).add(x).add(y),
                Z(b.x, b.y, b.z))
              : Z(D.x, D.y, 0);
        for (q = 1; q <= s; q++)
          for (j = 0; j < F; j++)
            (D = u ? R(T[j], Y[j], O) : T[j]),
              S
                ? (x.copy(g.normals[q]).multiplyScalar(D.x),
                  y.copy(g.binormals[q]).multiplyScalar(D.y),
                  b.copy(v[q]).add(x).add(y),
                  Z(b.x, b.y, b.z))
                : Z(D.x, D.y, (c / s) * q);
        for (C = f - 1; C >= 0; C--) {
          for (
            I = C / f,
              N = l * Math.cos((I * Math.PI) / 2),
              O = h * Math.sin((I * Math.PI) / 2) + p,
              j = 0,
              V = P.length;
            j < V;
            j++
          )
            Z((D = R(P[j], G[j], O)).x, D.y, c + N);
          for (_ = 0, M = A.length; _ < M; _++)
            for (w = A[_], W = X[_], j = 0, V = w.length; j < V; j++)
              (D = R(w[j], W[j], O)),
                S
                  ? Z(D.x, D.y + v[s - 1].y, v[s - 1].x + N)
                  : Z(D.x, D.y, c + N);
        }
        function J(t, e) {
          var n, r;
          for (j = t.length; --j >= 0; ) {
            (n = j), (r = j - 1) < 0 && (r = t.length - 1);
            var i = 0,
              o = s + 2 * f;
            for (i = 0; i < o; i++) {
              var a = F * i,
                c = F * (i + 1);
              K(e + n + a, e + r + a, e + r + c, e + n + c);
            }
          }
        }
        function Z(t, e, n) {
          o.push(t), o.push(e), o.push(n);
        }
        function Q(t, e, i) {
          $(t), $(e), $(i);
          var o = r.length / 3,
            a = m.generateTopUV(n, r, o - 3, o - 2, o - 1);
          tt(a[0]), tt(a[1]), tt(a[2]);
        }
        function K(t, e, i, o) {
          $(t), $(e), $(o), $(e), $(i), $(o);
          var a = r.length / 3,
            s = m.generateSideWallUV(n, r, a - 6, a - 3, a - 2, a - 1);
          tt(s[0]), tt(s[1]), tt(s[3]), tt(s[1]), tt(s[2]), tt(s[3]);
        }
        function $(t) {
          r.push(o[3 * t + 0]), r.push(o[3 * t + 1]), r.push(o[3 * t + 2]);
        }
        function tt(t) {
          i.push(t.x), i.push(t.y);
        }
        !(function () {
          var t = r.length / 3;
          if (u) {
            var e = 0,
              i = F * e;
            for (j = 0; j < U; j++) Q((z = L[j])[2] + i, z[1] + i, z[0] + i);
            for (i = F * (e = s + 2 * f), j = 0; j < U; j++)
              Q((z = L[j])[0] + i, z[1] + i, z[2] + i);
          } else {
            for (j = 0; j < U; j++) Q((z = L[j])[2], z[1], z[0]);
            for (j = 0; j < U; j++)
              Q((z = L[j])[0] + F * s, z[1] + F * s, z[2] + F * s);
          }
          n.addGroup(t, r.length / 3 - t, 0);
        })(),
          (function () {
            var t = r.length / 3,
              e = 0;
            for (J(P, e), e += P.length, _ = 0, M = A.length; _ < M; _++)
              J((w = A[_]), e), (e += w.length);
            n.addGroup(t, r.length / 3 - t, 1);
          })();
      }
      this.addAttribute("position", new Or(r, 3)),
        this.addAttribute("uv", new Or(i, 2)),
        this.computeVertexNormals();
    }
    (Cc.prototype = Object.create(di.prototype)),
      (Cc.prototype.constructor = Cc),
      (Cc.prototype.toJSON = function () {
        var t = di.prototype.toJSON.call(this);
        return Nc(this.parameters.shapes, this.parameters.options, t);
      }),
      (Oc.prototype = Object.create(Hr.prototype)),
      (Oc.prototype.constructor = Oc),
      (Oc.prototype.toJSON = function () {
        var t = Hr.prototype.toJSON.call(this);
        return Nc(this.parameters.shapes, this.parameters.options, t);
      });
    var Ic = {
      generateTopUV: function (t, e, n, r, i) {
        var o = e[3 * n],
          a = e[3 * n + 1],
          s = e[3 * r],
          c = e[3 * r + 1],
          u = e[3 * i],
          l = e[3 * i + 1];
        return [new ke(o, a), new ke(s, c), new ke(u, l)];
      },
      generateSideWallUV: function (t, e, n, r, i, o) {
        var a = e[3 * n],
          s = e[3 * n + 1],
          c = e[3 * n + 2],
          u = e[3 * r],
          l = e[3 * r + 1],
          h = e[3 * r + 2],
          p = e[3 * i],
          f = e[3 * i + 1],
          d = e[3 * i + 2],
          m = e[3 * o],
          v = e[3 * o + 1],
          g = e[3 * o + 2];
        return Math.abs(s - l) < 0.01
          ? [
              new ke(a, 1 - c),
              new ke(u, 1 - h),
              new ke(p, 1 - d),
              new ke(m, 1 - g),
            ]
          : [
              new ke(s, 1 - c),
              new ke(l, 1 - h),
              new ke(f, 1 - d),
              new ke(v, 1 - g),
            ];
      },
    };
    function Nc(t, e, n) {
      if (((n.shapes = []), Array.isArray(t)))
        for (var r = 0, i = t.length; r < i; r++) {
          var o = t[r];
          n.shapes.push(o.uuid);
        }
      else n.shapes.push(t.uuid);
      return (
        void 0 !== e.extrudePath &&
          (n.options.extrudePath = e.extrudePath.toJSON()),
        n
      );
    }
    function Dc(t, e) {
      di.call(this),
        (this.type = "TextGeometry"),
        (this.parameters = { text: t, parameters: e }),
        this.fromBufferGeometry(new zc(t, e)),
        this.mergeVertices();
    }
    function zc(t, e) {
      var n = (e = e || {}).font;
      if (!n || !n.isFont)
        return (
          console.error(
            "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
          ),
          new di()
        );
      var r = n.generateShapes(t, e.size);
      (e.depth = void 0 !== e.height ? e.height : 50),
        void 0 === e.bevelThickness && (e.bevelThickness = 10),
        void 0 === e.bevelSize && (e.bevelSize = 8),
        void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
        Oc.call(this, r, e),
        (this.type = "TextBufferGeometry");
    }
    function Fc(t, e, n, r, i, o, a) {
      di.call(this),
        (this.type = "SphereGeometry"),
        (this.parameters = {
          radius: t,
          widthSegments: e,
          heightSegments: n,
          phiStart: r,
          phiLength: i,
          thetaStart: o,
          thetaLength: a,
        }),
        this.fromBufferGeometry(new Uc(t, e, n, r, i, o, a)),
        this.mergeVertices();
    }
    function Uc(t, e, n, r, i, o, a) {
      Hr.call(this),
        (this.type = "SphereBufferGeometry"),
        (this.parameters = {
          radius: t,
          widthSegments: e,
          heightSegments: n,
          phiStart: r,
          phiLength: i,
          thetaStart: o,
          thetaLength: a,
        }),
        (t = t || 1),
        (e = Math.max(3, Math.floor(e) || 8)),
        (n = Math.max(2, Math.floor(n) || 6)),
        (r = void 0 !== r ? r : 0),
        (i = void 0 !== i ? i : 2 * Math.PI),
        (o = void 0 !== o ? o : 0),
        (a = void 0 !== a ? a : Math.PI);
      var s,
        c,
        u = Math.min(o + a, Math.PI),
        l = 0,
        h = [],
        p = new Ye(),
        f = new Ye(),
        d = [],
        m = [],
        v = [],
        g = [];
      for (c = 0; c <= n; c++) {
        var y = [],
          x = c / n,
          b = 0;
        for (
          0 == c && 0 == o
            ? (b = 0.5 / e)
            : c == n && u == Math.PI && (b = -0.5 / e),
            s = 0;
          s <= e;
          s++
        ) {
          var w = s / e;
          (p.x = -t * Math.cos(r + w * i) * Math.sin(o + x * a)),
            (p.y = t * Math.cos(o + x * a)),
            (p.z = t * Math.sin(r + w * i) * Math.sin(o + x * a)),
            m.push(p.x, p.y, p.z),
            f.copy(p).normalize(),
            v.push(f.x, f.y, f.z),
            g.push(w + b, 1 - x),
            y.push(l++);
        }
        h.push(y);
      }
      for (c = 0; c < n; c++)
        for (s = 0; s < e; s++) {
          var _ = h[c][s + 1],
            M = h[c][s],
            S = h[c + 1][s],
            E = h[c + 1][s + 1];
          (0 !== c || o > 0) && d.push(_, M, E),
            (c !== n - 1 || u < Math.PI) && d.push(M, S, E);
        }
      this.setIndex(d),
        this.addAttribute("position", new Or(m, 3)),
        this.addAttribute("normal", new Or(v, 3)),
        this.addAttribute("uv", new Or(g, 2));
    }
    function Bc(t, e, n, r, i, o) {
      di.call(this),
        (this.type = "RingGeometry"),
        (this.parameters = {
          innerRadius: t,
          outerRadius: e,
          thetaSegments: n,
          phiSegments: r,
          thetaStart: i,
          thetaLength: o,
        }),
        this.fromBufferGeometry(new Gc(t, e, n, r, i, o)),
        this.mergeVertices();
    }
    function Gc(t, e, n, r, i, o) {
      Hr.call(this),
        (this.type = "RingBufferGeometry"),
        (this.parameters = {
          innerRadius: t,
          outerRadius: e,
          thetaSegments: n,
          phiSegments: r,
          thetaStart: i,
          thetaLength: o,
        }),
        (t = t || 0.5),
        (e = e || 1),
        (i = void 0 !== i ? i : 0),
        (o = void 0 !== o ? o : 2 * Math.PI),
        (n = void 0 !== n ? Math.max(3, n) : 8);
      var a,
        s,
        c,
        u = [],
        l = [],
        h = [],
        p = [],
        f = t,
        d = (e - t) / (r = void 0 !== r ? Math.max(1, r) : 1),
        m = new Ye(),
        v = new ke();
      for (s = 0; s <= r; s++) {
        for (c = 0; c <= n; c++)
          (a = i + (c / n) * o),
            (m.x = f * Math.cos(a)),
            (m.y = f * Math.sin(a)),
            l.push(m.x, m.y, m.z),
            h.push(0, 0, 1),
            (v.x = (m.x / e + 1) / 2),
            (v.y = (m.y / e + 1) / 2),
            p.push(v.x, v.y);
        f += d;
      }
      for (s = 0; s < r; s++) {
        var g = s * (n + 1);
        for (c = 0; c < n; c++) {
          var y = (a = c + g),
            x = a + n + 1,
            b = a + n + 2,
            w = a + 1;
          u.push(y, x, w), u.push(x, b, w);
        }
      }
      this.setIndex(u),
        this.addAttribute("position", new Or(l, 3)),
        this.addAttribute("normal", new Or(h, 3)),
        this.addAttribute("uv", new Or(p, 2));
    }
    function jc(t, e, n, r) {
      di.call(this),
        (this.type = "LatheGeometry"),
        (this.parameters = {
          points: t,
          segments: e,
          phiStart: n,
          phiLength: r,
        }),
        this.fromBufferGeometry(new Vc(t, e, n, r)),
        this.mergeVertices();
    }
    function Vc(t, e, n, r) {
      Hr.call(this),
        (this.type = "LatheBufferGeometry"),
        (this.parameters = {
          points: t,
          segments: e,
          phiStart: n,
          phiLength: r,
        }),
        (e = Math.floor(e) || 12),
        (n = n || 0),
        (r = r || 2 * Math.PI),
        (r = He.clamp(r, 0, 2 * Math.PI));
      var i,
        o,
        a,
        s = [],
        c = [],
        u = [],
        l = 1 / e,
        h = new Ye(),
        p = new ke();
      for (o = 0; o <= e; o++) {
        var f = n + o * l * r,
          d = Math.sin(f),
          m = Math.cos(f);
        for (a = 0; a <= t.length - 1; a++)
          (h.x = t[a].x * d),
            (h.y = t[a].y),
            (h.z = t[a].x * m),
            c.push(h.x, h.y, h.z),
            (p.x = o / e),
            (p.y = a / (t.length - 1)),
            u.push(p.x, p.y);
      }
      for (o = 0; o < e; o++)
        for (a = 0; a < t.length - 1; a++) {
          var v = (i = a + o * t.length),
            g = i + t.length,
            y = i + t.length + 1,
            x = i + 1;
          s.push(v, g, x), s.push(g, y, x);
        }
      if (
        (this.setIndex(s),
        this.addAttribute("position", new Or(c, 3)),
        this.addAttribute("uv", new Or(u, 2)),
        this.computeVertexNormals(),
        r === 2 * Math.PI)
      ) {
        var b = this.attributes.normal.array,
          w = new Ye(),
          _ = new Ye(),
          M = new Ye();
        for (i = e * t.length * 3, o = 0, a = 0; o < t.length; o++, a += 3)
          (w.x = b[a + 0]),
            (w.y = b[a + 1]),
            (w.z = b[a + 2]),
            (_.x = b[i + a + 0]),
            (_.y = b[i + a + 1]),
            (_.z = b[i + a + 2]),
            M.addVectors(w, _).normalize(),
            (b[a + 0] = b[i + a + 0] = M.x),
            (b[a + 1] = b[i + a + 1] = M.y),
            (b[a + 2] = b[i + a + 2] = M.z);
      }
    }
    function Hc(t, e) {
      di.call(this),
        (this.type = "ShapeGeometry"),
        "object" == typeof e &&
          (console.warn(
            "THREE.ShapeGeometry: Options parameter has been removed."
          ),
          (e = e.curveSegments)),
        (this.parameters = { shapes: t, curveSegments: e }),
        this.fromBufferGeometry(new kc(t, e)),
        this.mergeVertices();
    }
    function kc(t, e) {
      Hr.call(this),
        (this.type = "ShapeBufferGeometry"),
        (this.parameters = { shapes: t, curveSegments: e }),
        (e = e || 12);
      var n = [],
        r = [],
        i = [],
        o = [],
        a = 0,
        s = 0;
      if (!1 === Array.isArray(t)) u(t);
      else
        for (var c = 0; c < t.length; c++)
          u(t[c]), this.addGroup(a, s, c), (a += s), (s = 0);
      function u(t) {
        var a,
          c,
          u,
          l = r.length / 3,
          h = t.extractPoints(e),
          p = h.shape,
          f = h.holes;
        for (
          !1 === Lc.isClockWise(p) && (p = p.reverse()), a = 0, c = f.length;
          a < c;
          a++
        )
          (u = f[a]), !0 === Lc.isClockWise(u) && (f[a] = u.reverse());
        var d = Lc.triangulateShape(p, f);
        for (a = 0, c = f.length; a < c; a++) (u = f[a]), (p = p.concat(u));
        for (a = 0, c = p.length; a < c; a++) {
          var m = p[a];
          r.push(m.x, m.y, 0), i.push(0, 0, 1), o.push(m.x, m.y);
        }
        for (a = 0, c = d.length; a < c; a++) {
          var v = d[a],
            g = v[0] + l,
            y = v[1] + l,
            x = v[2] + l;
          n.push(g, y, x), (s += 3);
        }
      }
      this.setIndex(n),
        this.addAttribute("position", new Or(r, 3)),
        this.addAttribute("normal", new Or(i, 3)),
        this.addAttribute("uv", new Or(o, 2));
    }
    function Wc(t, e) {
      if (((e.shapes = []), Array.isArray(t)))
        for (var n = 0, r = t.length; n < r; n++) {
          var i = t[n];
          e.shapes.push(i.uuid);
        }
      else e.shapes.push(t.uuid);
      return e;
    }
    function qc(t, e) {
      Hr.call(this),
        (this.type = "EdgesGeometry"),
        (this.parameters = { thresholdAngle: e }),
        (e = void 0 !== e ? e : 1);
      var n,
        r,
        i,
        o,
        a = [],
        s = Math.cos(He.DEG2RAD * e),
        c = [0, 0],
        u = {},
        l = ["a", "b", "c"];
      t.isBufferGeometry
        ? (o = new di()).fromBufferGeometry(t)
        : (o = t.clone()),
        o.mergeVertices(),
        o.computeFaceNormals();
      for (var h = o.vertices, p = o.faces, f = 0, d = p.length; f < d; f++)
        for (var m = p[f], v = 0; v < 3; v++)
          (n = m[l[v]]),
            (r = m[l[(v + 1) % 3]]),
            (c[0] = Math.min(n, r)),
            (c[1] = Math.max(n, r)),
            void 0 === u[(i = c[0] + "," + c[1])]
              ? (u[i] = { index1: c[0], index2: c[1], face1: f, face2: void 0 })
              : (u[i].face2 = f);
      for (i in u) {
        var g = u[i];
        if (
          void 0 === g.face2 ||
          p[g.face1].normal.dot(p[g.face2].normal) <= s
        ) {
          var y = h[g.index1];
          a.push(y.x, y.y, y.z), (y = h[g.index2]), a.push(y.x, y.y, y.z);
        }
      }
      this.addAttribute("position", new Or(a, 3));
    }
    function Xc(t, e, n, r, i, o, a, s) {
      di.call(this),
        (this.type = "CylinderGeometry"),
        (this.parameters = {
          radiusTop: t,
          radiusBottom: e,
          height: n,
          radialSegments: r,
          heightSegments: i,
          openEnded: o,
          thetaStart: a,
          thetaLength: s,
        }),
        this.fromBufferGeometry(new Yc(t, e, n, r, i, o, a, s)),
        this.mergeVertices();
    }
    function Yc(t, e, n, r, i, o, a, s) {
      Hr.call(this),
        (this.type = "CylinderBufferGeometry"),
        (this.parameters = {
          radiusTop: t,
          radiusBottom: e,
          height: n,
          radialSegments: r,
          heightSegments: i,
          openEnded: o,
          thetaStart: a,
          thetaLength: s,
        });
      var c = this;
      (t = void 0 !== t ? t : 1),
        (e = void 0 !== e ? e : 1),
        (n = n || 1),
        (r = Math.floor(r) || 8),
        (i = Math.floor(i) || 1),
        (o = void 0 !== o && o),
        (a = void 0 !== a ? a : 0),
        (s = void 0 !== s ? s : 2 * Math.PI);
      var u = [],
        l = [],
        h = [],
        p = [],
        f = 0,
        d = [],
        m = n / 2,
        v = 0;
      function g(n) {
        var i,
          o,
          d,
          g = new ke(),
          y = new Ye(),
          x = 0,
          b = !0 === n ? t : e,
          w = !0 === n ? 1 : -1;
        for (o = f, i = 1; i <= r; i++)
          l.push(0, m * w, 0), h.push(0, w, 0), p.push(0.5, 0.5), f++;
        for (d = f, i = 0; i <= r; i++) {
          var _ = (i / r) * s + a,
            M = Math.cos(_),
            S = Math.sin(_);
          (y.x = b * S),
            (y.y = m * w),
            (y.z = b * M),
            l.push(y.x, y.y, y.z),
            h.push(0, w, 0),
            (g.x = 0.5 * M + 0.5),
            (g.y = 0.5 * S * w + 0.5),
            p.push(g.x, g.y),
            f++;
        }
        for (i = 0; i < r; i++) {
          var E = o + i,
            T = d + i;
          !0 === n ? u.push(T, T + 1, E) : u.push(T + 1, T, E), (x += 3);
        }
        c.addGroup(v, x, !0 === n ? 1 : 2), (v += x);
      }
      !(function () {
        var o,
          g,
          y = new Ye(),
          x = new Ye(),
          b = 0,
          w = (e - t) / n;
        for (g = 0; g <= i; g++) {
          var _ = [],
            M = g / i,
            S = M * (e - t) + t;
          for (o = 0; o <= r; o++) {
            var E = o / r,
              T = E * s + a,
              A = Math.sin(T),
              L = Math.cos(T);
            (x.x = S * A),
              (x.y = -M * n + m),
              (x.z = S * L),
              l.push(x.x, x.y, x.z),
              y.set(A, w, L).normalize(),
              h.push(y.x, y.y, y.z),
              p.push(E, 1 - M),
              _.push(f++);
          }
          d.push(_);
        }
        for (o = 0; o < r; o++)
          for (g = 0; g < i; g++) {
            var P = d[g][o],
              R = d[g + 1][o],
              C = d[g + 1][o + 1],
              O = d[g][o + 1];
            u.push(P, R, O), u.push(R, C, O), (b += 6);
          }
        c.addGroup(v, b, 0), (v += b);
      })(),
        !1 === o && (t > 0 && g(!0), e > 0 && g(!1)),
        this.setIndex(u),
        this.addAttribute("position", new Or(l, 3)),
        this.addAttribute("normal", new Or(h, 3)),
        this.addAttribute("uv", new Or(p, 2));
    }
    function Jc(t, e, n, r, i, o, a) {
      Xc.call(this, 0, t, e, n, r, i, o, a),
        (this.type = "ConeGeometry"),
        (this.parameters = {
          radius: t,
          height: e,
          radialSegments: n,
          heightSegments: r,
          openEnded: i,
          thetaStart: o,
          thetaLength: a,
        });
    }
    function Zc(t, e, n, r, i, o, a) {
      Yc.call(this, 0, t, e, n, r, i, o, a),
        (this.type = "ConeBufferGeometry"),
        (this.parameters = {
          radius: t,
          height: e,
          radialSegments: n,
          heightSegments: r,
          openEnded: i,
          thetaStart: o,
          thetaLength: a,
        });
    }
    function Qc(t, e, n, r) {
      di.call(this),
        (this.type = "CircleGeometry"),
        (this.parameters = {
          radius: t,
          segments: e,
          thetaStart: n,
          thetaLength: r,
        }),
        this.fromBufferGeometry(new Kc(t, e, n, r)),
        this.mergeVertices();
    }
    function Kc(t, e, n, r) {
      Hr.call(this),
        (this.type = "CircleBufferGeometry"),
        (this.parameters = {
          radius: t,
          segments: e,
          thetaStart: n,
          thetaLength: r,
        }),
        (t = t || 1),
        (e = void 0 !== e ? Math.max(3, e) : 8),
        (n = void 0 !== n ? n : 0),
        (r = void 0 !== r ? r : 2 * Math.PI);
      var i,
        o,
        a = [],
        s = [],
        c = [],
        u = [],
        l = new Ye(),
        h = new ke();
      for (
        s.push(0, 0, 0), c.push(0, 0, 1), u.push(0.5, 0.5), o = 0, i = 3;
        o <= e;
        o++, i += 3
      ) {
        var p = n + (o / e) * r;
        (l.x = t * Math.cos(p)),
          (l.y = t * Math.sin(p)),
          s.push(l.x, l.y, l.z),
          c.push(0, 0, 1),
          (h.x = (s[i] / t + 1) / 2),
          (h.y = (s[i + 1] / t + 1) / 2),
          u.push(h.x, h.y);
      }
      for (i = 1; i <= e; i++) a.push(i, i + 1, 0);
      this.setIndex(a),
        this.addAttribute("position", new Or(s, 3)),
        this.addAttribute("normal", new Or(c, 3)),
        this.addAttribute("uv", new Or(u, 2));
    }
    (Dc.prototype = Object.create(di.prototype)),
      (Dc.prototype.constructor = Dc),
      (zc.prototype = Object.create(Oc.prototype)),
      (zc.prototype.constructor = zc),
      (Fc.prototype = Object.create(di.prototype)),
      (Fc.prototype.constructor = Fc),
      (Uc.prototype = Object.create(Hr.prototype)),
      (Uc.prototype.constructor = Uc),
      (Bc.prototype = Object.create(di.prototype)),
      (Bc.prototype.constructor = Bc),
      (Gc.prototype = Object.create(Hr.prototype)),
      (Gc.prototype.constructor = Gc),
      (jc.prototype = Object.create(di.prototype)),
      (jc.prototype.constructor = jc),
      (Vc.prototype = Object.create(Hr.prototype)),
      (Vc.prototype.constructor = Vc),
      (Hc.prototype = Object.create(di.prototype)),
      (Hc.prototype.constructor = Hc),
      (Hc.prototype.toJSON = function () {
        var t = di.prototype.toJSON.call(this);
        return Wc(this.parameters.shapes, t);
      }),
      (kc.prototype = Object.create(Hr.prototype)),
      (kc.prototype.constructor = kc),
      (kc.prototype.toJSON = function () {
        var t = Hr.prototype.toJSON.call(this);
        return Wc(this.parameters.shapes, t);
      }),
      (qc.prototype = Object.create(Hr.prototype)),
      (qc.prototype.constructor = qc),
      (Xc.prototype = Object.create(di.prototype)),
      (Xc.prototype.constructor = Xc),
      (Yc.prototype = Object.create(Hr.prototype)),
      (Yc.prototype.constructor = Yc),
      (Jc.prototype = Object.create(Xc.prototype)),
      (Jc.prototype.constructor = Jc),
      (Zc.prototype = Object.create(Yc.prototype)),
      (Zc.prototype.constructor = Zc),
      (Qc.prototype = Object.create(di.prototype)),
      (Qc.prototype.constructor = Qc),
      (Kc.prototype = Object.create(Hr.prototype)),
      (Kc.prototype.constructor = Kc);
    var $c = Object.freeze({
      WireframeGeometry: js,
      ParametricGeometry: Vs,
      ParametricBufferGeometry: Hs,
      TetrahedronGeometry: qs,
      TetrahedronBufferGeometry: Xs,
      OctahedronGeometry: Ys,
      OctahedronBufferGeometry: Js,
      IcosahedronGeometry: Zs,
      IcosahedronBufferGeometry: Qs,
      DodecahedronGeometry: Ks,
      DodecahedronBufferGeometry: $s,
      PolyhedronGeometry: ks,
      PolyhedronBufferGeometry: Ws,
      TubeGeometry: tc,
      TubeBufferGeometry: ec,
      TorusKnotGeometry: nc,
      TorusKnotBufferGeometry: rc,
      TorusGeometry: ic,
      TorusBufferGeometry: oc,
      TextGeometry: Dc,
      TextBufferGeometry: zc,
      SphereGeometry: Fc,
      SphereBufferGeometry: Uc,
      RingGeometry: Bc,
      RingBufferGeometry: Gc,
      PlaneGeometry: Gi,
      PlaneBufferGeometry: ji,
      LatheGeometry: jc,
      LatheBufferGeometry: Vc,
      ShapeGeometry: Hc,
      ShapeBufferGeometry: kc,
      ExtrudeGeometry: Cc,
      ExtrudeBufferGeometry: Oc,
      EdgesGeometry: qc,
      ConeGeometry: Jc,
      ConeBufferGeometry: Zc,
      CylinderGeometry: Xc,
      CylinderBufferGeometry: Yc,
      CircleGeometry: Qc,
      CircleBufferGeometry: Kc,
      BoxGeometry: class extends di {
        constructor(t, e, n, r, i, o) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: t,
              height: e,
              depth: n,
              widthSegments: r,
              heightSegments: i,
              depthSegments: o,
            }),
            this.fromBufferGeometry(new mi(t, e, n, r, i, o)),
            this.mergeVertices();
        }
      },
      BoxBufferGeometry: mi,
    });
    function tu(t) {
      _r.call(this),
        (this.type = "ShadowMaterial"),
        (this.color = new vr(0)),
        (this.transparent = !0),
        this.setValues(t);
    }
    function eu(t) {
      bi.call(this, t), (this.type = "RawShaderMaterial");
    }
    function nu(t) {
      _r.call(this),
        (this.defines = { STANDARD: "" }),
        (this.type = "MeshStandardMaterial"),
        (this.color = new vr(16777215)),
        (this.roughness = 0.5),
        (this.metalness = 0.5),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new vr(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = ze),
        (this.normalScale = new ke(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.roughnessMap = null),
        (this.metalnessMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.envMapIntensity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function ru(t) {
      nu.call(this),
        (this.defines = { STANDARD: "", PHYSICAL: "" }),
        (this.type = "MeshPhysicalMaterial"),
        (this.reflectivity = 0.5),
        (this.clearcoat = 0),
        (this.clearcoatRoughness = 0),
        (this.sheen = null),
        (this.clearcoatNormalScale = new ke(1, 1)),
        (this.clearcoatNormalMap = null),
        (this.transparency = 0),
        this.setValues(t);
    }
    function iu(t) {
      _r.call(this),
        (this.type = "MeshPhongMaterial"),
        (this.color = new vr(16777215)),
        (this.specular = new vr(1118481)),
        (this.shininess = 30),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new vr(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = ze),
        (this.normalScale = new ke(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = st),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function ou(t) {
      iu.call(this),
        (this.defines = { TOON: "" }),
        (this.type = "MeshToonMaterial"),
        (this.gradientMap = null),
        this.setValues(t);
    }
    function au(t) {
      _r.call(this),
        (this.type = "MeshNormalMaterial"),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = ze),
        (this.normalScale = new ke(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function su(t) {
      _r.call(this),
        (this.type = "MeshLambertMaterial"),
        (this.color = new vr(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new vr(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = st),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function cu(t) {
      _r.call(this),
        (this.defines = { MATCAP: "" }),
        (this.type = "MeshMatcapMaterial"),
        (this.color = new vr(16777215)),
        (this.matcap = null),
        (this.map = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = ze),
        (this.normalScale = new ke(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.alphaMap = null),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function uu(t) {
      xs.call(this),
        (this.type = "LineDashedMaterial"),
        (this.scale = 1),
        (this.dashSize = 3),
        (this.gapSize = 1),
        this.setValues(t);
    }
    (tu.prototype = Object.create(_r.prototype)),
      (tu.prototype.constructor = tu),
      (tu.prototype.isShadowMaterial = !0),
      (tu.prototype.copy = function (t) {
        return _r.prototype.copy.call(this, t), this.color.copy(t.color), this;
      }),
      (eu.prototype = Object.create(bi.prototype)),
      (eu.prototype.constructor = eu),
      (eu.prototype.isRawShaderMaterial = !0),
      (nu.prototype = Object.create(_r.prototype)),
      (nu.prototype.constructor = nu),
      (nu.prototype.isMeshStandardMaterial = !0),
      (nu.prototype.copy = function (t) {
        return (
          _r.prototype.copy.call(this, t),
          (this.defines = { STANDARD: "" }),
          this.color.copy(t.color),
          (this.roughness = t.roughness),
          (this.metalness = t.metalness),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          this.emissive.copy(t.emissive),
          (this.emissiveMap = t.emissiveMap),
          (this.emissiveIntensity = t.emissiveIntensity),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          (this.normalMapType = t.normalMapType),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.roughnessMap = t.roughnessMap),
          (this.metalnessMap = t.metalnessMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.envMapIntensity = t.envMapIntensity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      (ru.prototype = Object.create(nu.prototype)),
      (ru.prototype.constructor = ru),
      (ru.prototype.isMeshPhysicalMaterial = !0),
      (ru.prototype.copy = function (t) {
        return (
          nu.prototype.copy.call(this, t),
          (this.defines = { STANDARD: "", PHYSICAL: "" }),
          (this.reflectivity = t.reflectivity),
          (this.clearcoat = t.clearcoat),
          (this.clearcoatRoughness = t.clearcoatRoughness),
          t.sheen
            ? (this.sheen = (this.sheen || new vr()).copy(t.sheen))
            : (this.sheen = null),
          (this.clearcoatNormalMap = t.clearcoatNormalMap),
          this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
          (this.transparency = t.transparency),
          this
        );
      }),
      (iu.prototype = Object.create(_r.prototype)),
      (iu.prototype.constructor = iu),
      (iu.prototype.isMeshPhongMaterial = !0),
      (iu.prototype.copy = function (t) {
        return (
          _r.prototype.copy.call(this, t),
          this.color.copy(t.color),
          this.specular.copy(t.specular),
          (this.shininess = t.shininess),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          this.emissive.copy(t.emissive),
          (this.emissiveMap = t.emissiveMap),
          (this.emissiveIntensity = t.emissiveIntensity),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          (this.normalMapType = t.normalMapType),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.specularMap = t.specularMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.combine = t.combine),
          (this.reflectivity = t.reflectivity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      (ou.prototype = Object.create(iu.prototype)),
      (ou.prototype.constructor = ou),
      (ou.prototype.isMeshToonMaterial = !0),
      (ou.prototype.copy = function (t) {
        return (
          iu.prototype.copy.call(this, t),
          (this.gradientMap = t.gradientMap),
          this
        );
      }),
      (au.prototype = Object.create(_r.prototype)),
      (au.prototype.constructor = au),
      (au.prototype.isMeshNormalMaterial = !0),
      (au.prototype.copy = function (t) {
        return (
          _r.prototype.copy.call(this, t),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          (this.normalMapType = t.normalMapType),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      (su.prototype = Object.create(_r.prototype)),
      (su.prototype.constructor = su),
      (su.prototype.isMeshLambertMaterial = !0),
      (su.prototype.copy = function (t) {
        return (
          _r.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          this.emissive.copy(t.emissive),
          (this.emissiveMap = t.emissiveMap),
          (this.emissiveIntensity = t.emissiveIntensity),
          (this.specularMap = t.specularMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.combine = t.combine),
          (this.reflectivity = t.reflectivity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      (cu.prototype = Object.create(_r.prototype)),
      (cu.prototype.constructor = cu),
      (cu.prototype.isMeshMatcapMaterial = !0),
      (cu.prototype.copy = function (t) {
        return (
          _r.prototype.copy.call(this, t),
          (this.defines = { MATCAP: "" }),
          this.color.copy(t.color),
          (this.matcap = t.matcap),
          (this.map = t.map),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          (this.normalMapType = t.normalMapType),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.alphaMap = t.alphaMap),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      (uu.prototype = Object.create(xs.prototype)),
      (uu.prototype.constructor = uu),
      (uu.prototype.isLineDashedMaterial = !0),
      (uu.prototype.copy = function (t) {
        return (
          xs.prototype.copy.call(this, t),
          (this.scale = t.scale),
          (this.dashSize = t.dashSize),
          (this.gapSize = t.gapSize),
          this
        );
      });
    var lu = Object.freeze({
        ShadowMaterial: tu,
        SpriteMaterial: Ja,
        RawShaderMaterial: eu,
        ShaderMaterial: bi,
        PointsMaterial: Rs,
        MeshPhysicalMaterial: ru,
        MeshStandardMaterial: nu,
        MeshPhongMaterial: iu,
        MeshToonMaterial: ou,
        MeshNormalMaterial: au,
        MeshLambertMaterial: su,
        MeshDepthMaterial: Ta,
        MeshDistanceMaterial: Aa,
        MeshBasicMaterial: Mr,
        MeshMatcapMaterial: cu,
        LineDashedMaterial: uu,
        LineBasicMaterial: xs,
        Material: _r,
      }),
      hu = {
        arraySlice: function (t, e, n) {
          return hu.isTypedArray(t)
            ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
            : t.slice(e, n);
        },
        convertArray: function (t, e, n) {
          return !t || (!n && t.constructor === e)
            ? t
            : "number" == typeof e.BYTES_PER_ELEMENT
            ? new e(t)
            : Array.prototype.slice.call(t);
        },
        isTypedArray: function (t) {
          return ArrayBuffer.isView(t) && !(t instanceof DataView);
        },
        getKeyframeOrder: function (t) {
          for (var e = t.length, n = new Array(e), r = 0; r !== e; ++r)
            n[r] = r;
          return (
            n.sort(function (e, n) {
              return t[e] - t[n];
            }),
            n
          );
        },
        sortedArray: function (t, e, n) {
          for (
            var r = t.length, i = new t.constructor(r), o = 0, a = 0;
            a !== r;
            ++o
          )
            for (var s = n[o] * e, c = 0; c !== e; ++c) i[a++] = t[s + c];
          return i;
        },
        flattenJSON: function (t, e, n, r) {
          for (var i = 1, o = t[0]; void 0 !== o && void 0 === o[r]; )
            o = t[i++];
          if (void 0 !== o) {
            var a = o[r];
            if (void 0 !== a)
              if (Array.isArray(a))
                do {
                  void 0 !== (a = o[r]) && (e.push(o.time), n.push.apply(n, a)),
                    (o = t[i++]);
                } while (void 0 !== o);
              else if (void 0 !== a.toArray)
                do {
                  void 0 !== (a = o[r]) &&
                    (e.push(o.time), a.toArray(n, n.length)),
                    (o = t[i++]);
                } while (void 0 !== o);
              else
                do {
                  void 0 !== (a = o[r]) && (e.push(o.time), n.push(a)),
                    (o = t[i++]);
                } while (void 0 !== o);
          }
        },
      };
    function pu(t, e, n, r) {
      (this.parameterPositions = t),
        (this._cachedIndex = 0),
        (this.resultBuffer = void 0 !== r ? r : new e.constructor(n)),
        (this.sampleValues = e),
        (this.valueSize = n);
    }
    function fu(t, e, n, r) {
      pu.call(this, t, e, n, r),
        (this._weightPrev = -0),
        (this._offsetPrev = -0),
        (this._weightNext = -0),
        (this._offsetNext = -0);
    }
    function du(t, e, n, r) {
      pu.call(this, t, e, n, r);
    }
    function mu(t, e, n, r) {
      pu.call(this, t, e, n, r);
    }
    function vu(t, e, n, r) {
      if (void 0 === t)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (void 0 === e || 0 === e.length)
        throw new Error(
          "THREE.KeyframeTrack: no keyframes in track named " + t
        );
      (this.name = t),
        (this.times = hu.convertArray(e, this.TimeBufferType)),
        (this.values = hu.convertArray(n, this.ValueBufferType)),
        this.setInterpolation(r || this.DefaultInterpolation);
    }
    function gu(t, e, n) {
      vu.call(this, t, e, n);
    }
    function yu(t, e, n, r) {
      vu.call(this, t, e, n, r);
    }
    function xu(t, e, n, r) {
      vu.call(this, t, e, n, r);
    }
    function bu(t, e, n, r) {
      pu.call(this, t, e, n, r);
    }
    function wu(t, e, n, r) {
      vu.call(this, t, e, n, r);
    }
    function _u(t, e, n, r) {
      vu.call(this, t, e, n, r);
    }
    function Mu(t, e, n, r) {
      vu.call(this, t, e, n, r);
    }
    function Su(t, e, n) {
      (this.name = t),
        (this.tracks = n),
        (this.duration = void 0 !== e ? e : -1),
        (this.uuid = He.generateUUID()),
        this.duration < 0 && this.resetDuration();
    }
    function Eu(t) {
      if (void 0 === t.type)
        throw new Error(
          "THREE.KeyframeTrack: track type undefined, can not parse"
        );
      var e = (function (t) {
        switch (t.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return xu;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return Mu;
          case "color":
            return yu;
          case "quaternion":
            return wu;
          case "bool":
          case "boolean":
            return gu;
          case "string":
            return _u;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
      })(t.type);
      if (void 0 === t.times) {
        var n = [],
          r = [];
        hu.flattenJSON(t.keys, n, r, "value"), (t.times = n), (t.values = r);
      }
      return void 0 !== e.parse
        ? e.parse(t)
        : new e(t.name, t.times, t.values, t.interpolation);
    }
    Object.assign(pu.prototype, {
      evaluate: function (t) {
        var e = this.parameterPositions,
          n = this._cachedIndex,
          r = e[n],
          i = e[n - 1];
        t: {
          e: {
            var o;
            n: {
              r: if (!(t < r)) {
                for (var a = n + 2; ; ) {
                  if (void 0 === r) {
                    if (t < i) break r;
                    return (
                      (n = e.length),
                      (this._cachedIndex = n),
                      this.afterEnd_(n - 1, t, i)
                    );
                  }
                  if (n === a) break;
                  if (((i = r), t < (r = e[++n]))) break e;
                }
                o = e.length;
                break n;
              }
              if (t >= i) break t;
              var s = e[1];
              t < s && ((n = 2), (i = s));
              for (a = n - 2; ; ) {
                if (void 0 === i)
                  return (this._cachedIndex = 0), this.beforeStart_(0, t, r);
                if (n === a) break;
                if (((r = i), t >= (i = e[--n - 1]))) break e;
              }
              (o = n), (n = 0);
            }
            for (; n < o; ) {
              var c = (n + o) >>> 1;
              t < e[c] ? (o = c) : (n = c + 1);
            }
            if (((r = e[n]), void 0 === (i = e[n - 1])))
              return (this._cachedIndex = 0), this.beforeStart_(0, t, r);
            if (void 0 === r)
              return (
                (n = e.length),
                (this._cachedIndex = n),
                this.afterEnd_(n - 1, i, t)
              );
          }
          (this._cachedIndex = n), this.intervalChanged_(n, i, r);
        }
        return this.interpolate_(n, i, t, r);
      },
      settings: null,
      DefaultSettings_: {},
      getSettings_: function () {
        return this.settings || this.DefaultSettings_;
      },
      copySampleValue_: function (t) {
        for (
          var e = this.resultBuffer,
            n = this.sampleValues,
            r = this.valueSize,
            i = t * r,
            o = 0;
          o !== r;
          ++o
        )
          e[o] = n[i + o];
        return e;
      },
      interpolate_: function () {
        throw new Error("call to abstract method");
      },
      intervalChanged_: function () {},
    }),
      Object.assign(pu.prototype, {
        beforeStart_: pu.prototype.copySampleValue_,
        afterEnd_: pu.prototype.copySampleValue_,
      }),
      (fu.prototype = Object.assign(Object.create(pu.prototype), {
        constructor: fu,
        DefaultSettings_: { endingStart: _e, endingEnd: _e },
        intervalChanged_: function (t, e, n) {
          var r = this.parameterPositions,
            i = t - 2,
            o = t + 1,
            a = r[i],
            s = r[o];
          if (void 0 === a)
            switch (this.getSettings_().endingStart) {
              case 2401:
                (i = t), (a = 2 * e - n);
                break;
              case 2402:
                a = e + r[(i = r.length - 2)] - r[i + 1];
                break;
              default:
                (i = t), (a = n);
            }
          if (void 0 === s)
            switch (this.getSettings_().endingEnd) {
              case 2401:
                (o = t), (s = 2 * n - e);
                break;
              case 2402:
                (o = 1), (s = n + r[1] - r[0]);
                break;
              default:
                (o = t - 1), (s = e);
            }
          var c = 0.5 * (n - e),
            u = this.valueSize;
          (this._weightPrev = c / (e - a)),
            (this._weightNext = c / (s - n)),
            (this._offsetPrev = i * u),
            (this._offsetNext = o * u);
        },
        interpolate_: function (t, e, n, r) {
          for (
            var i = this.resultBuffer,
              o = this.sampleValues,
              a = this.valueSize,
              s = t * a,
              c = s - a,
              u = this._offsetPrev,
              l = this._offsetNext,
              h = this._weightPrev,
              p = this._weightNext,
              f = (n - e) / (r - e),
              d = f * f,
              m = d * f,
              v = -h * m + 2 * h * d - h * f,
              g = (1 + h) * m + (-1.5 - 2 * h) * d + (-0.5 + h) * f + 1,
              y = (-1 - p) * m + (1.5 + p) * d + 0.5 * f,
              x = p * m - p * d,
              b = 0;
            b !== a;
            ++b
          )
            i[b] = v * o[u + b] + g * o[c + b] + y * o[s + b] + x * o[l + b];
          return i;
        },
      })),
      (du.prototype = Object.assign(Object.create(pu.prototype), {
        constructor: du,
        interpolate_: function (t, e, n, r) {
          for (
            var i = this.resultBuffer,
              o = this.sampleValues,
              a = this.valueSize,
              s = t * a,
              c = s - a,
              u = (n - e) / (r - e),
              l = 1 - u,
              h = 0;
            h !== a;
            ++h
          )
            i[h] = o[c + h] * l + o[s + h] * u;
          return i;
        },
      })),
      (mu.prototype = Object.assign(Object.create(pu.prototype), {
        constructor: mu,
        interpolate_: function (t) {
          return this.copySampleValue_(t - 1);
        },
      })),
      Object.assign(vu, {
        toJSON: function (t) {
          var e,
            n = t.constructor;
          if (void 0 !== n.toJSON) e = n.toJSON(t);
          else {
            e = {
              name: t.name,
              times: hu.convertArray(t.times, Array),
              values: hu.convertArray(t.values, Array),
            };
            var r = t.getInterpolation();
            r !== t.DefaultInterpolation && (e.interpolation = r);
          }
          return (e.type = t.ValueTypeName), e;
        },
      }),
      Object.assign(vu.prototype, {
        constructor: vu,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function (t) {
          return new mu(this.times, this.values, this.getValueSize(), t);
        },
        InterpolantFactoryMethodLinear: function (t) {
          return new du(this.times, this.values, this.getValueSize(), t);
        },
        InterpolantFactoryMethodSmooth: function (t) {
          return new fu(this.times, this.values, this.getValueSize(), t);
        },
        setInterpolation: function (t) {
          var e;
          switch (t) {
            case 2300:
              e = this.InterpolantFactoryMethodDiscrete;
              break;
            case 2301:
              e = this.InterpolantFactoryMethodLinear;
              break;
            case 2302:
              e = this.InterpolantFactoryMethodSmooth;
          }
          if (void 0 === e) {
            var n =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (void 0 === this.createInterpolant) {
              if (t === this.DefaultInterpolation) throw new Error(n);
              this.setInterpolation(this.DefaultInterpolation);
            }
            return console.warn("THREE.KeyframeTrack:", n), this;
          }
          return (this.createInterpolant = e), this;
        },
        getInterpolation: function () {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return 2300;
            case this.InterpolantFactoryMethodLinear:
              return 2301;
            case this.InterpolantFactoryMethodSmooth:
              return 2302;
          }
        },
        getValueSize: function () {
          return this.values.length / this.times.length;
        },
        shift: function (t) {
          if (0 !== t)
            for (var e = this.times, n = 0, r = e.length; n !== r; ++n)
              e[n] += t;
          return this;
        },
        scale: function (t) {
          if (1 !== t)
            for (var e = this.times, n = 0, r = e.length; n !== r; ++n)
              e[n] *= t;
          return this;
        },
        trim: function (t, e) {
          for (
            var n = this.times, r = n.length, i = 0, o = r - 1;
            i !== r && n[i] < t;

          )
            ++i;
          for (; -1 !== o && n[o] > e; ) --o;
          if ((++o, 0 !== i || o !== r)) {
            i >= o && (i = (o = Math.max(o, 1)) - 1);
            var a = this.getValueSize();
            (this.times = hu.arraySlice(n, i, o)),
              (this.values = hu.arraySlice(this.values, i * a, o * a));
          }
          return this;
        },
        validate: function () {
          var t = !0,
            e = this.getValueSize();
          e - Math.floor(e) != 0 &&
            (console.error(
              "THREE.KeyframeTrack: Invalid value size in track.",
              this
            ),
            (t = !1));
          var n = this.times,
            r = this.values,
            i = n.length;
          0 === i &&
            (console.error("THREE.KeyframeTrack: Track is empty.", this),
            (t = !1));
          for (var o = null, a = 0; a !== i; a++) {
            var s = n[a];
            if ("number" == typeof s && isNaN(s)) {
              console.error(
                "THREE.KeyframeTrack: Time is not a valid number.",
                this,
                a,
                s
              ),
                (t = !1);
              break;
            }
            if (null !== o && o > s) {
              console.error(
                "THREE.KeyframeTrack: Out of order keys.",
                this,
                a,
                s,
                o
              ),
                (t = !1);
              break;
            }
            o = s;
          }
          if (void 0 !== r && hu.isTypedArray(r)) {
            a = 0;
            for (var c = r.length; a !== c; ++a) {
              var u = r[a];
              if (isNaN(u)) {
                console.error(
                  "THREE.KeyframeTrack: Value is not a valid number.",
                  this,
                  a,
                  u
                ),
                  (t = !1);
                break;
              }
            }
          }
          return t;
        },
        optimize: function () {
          for (
            var t = this.times,
              e = this.values,
              n = this.getValueSize(),
              r = 2302 === this.getInterpolation(),
              i = 1,
              o = t.length - 1,
              a = 1;
            a < o;
            ++a
          ) {
            var s = !1,
              c = t[a];
            if (c !== t[a + 1] && (1 !== a || c !== c[0]))
              if (r) s = !0;
              else
                for (var u = a * n, l = u - n, h = u + n, p = 0; p !== n; ++p) {
                  var f = e[u + p];
                  if (f !== e[l + p] || f !== e[h + p]) {
                    s = !0;
                    break;
                  }
                }
            if (s) {
              if (a !== i) {
                t[i] = t[a];
                var d = a * n,
                  m = i * n;
                for (p = 0; p !== n; ++p) e[m + p] = e[d + p];
              }
              ++i;
            }
          }
          if (o > 0) {
            t[i] = t[o];
            for (d = o * n, m = i * n, p = 0; p !== n; ++p) e[m + p] = e[d + p];
            ++i;
          }
          return (
            i !== t.length &&
              ((this.times = hu.arraySlice(t, 0, i)),
              (this.values = hu.arraySlice(e, 0, i * n))),
            this
          );
        },
        clone: function () {
          var t = hu.arraySlice(this.times, 0),
            e = hu.arraySlice(this.values, 0),
            n = new (0, this.constructor)(this.name, t, e);
          return (n.createInterpolant = this.createInterpolant), n;
        },
      }),
      (gu.prototype = Object.assign(Object.create(vu.prototype), {
        constructor: gu,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0,
      })),
      (yu.prototype = Object.assign(Object.create(vu.prototype), {
        constructor: yu,
        ValueTypeName: "color",
      })),
      (xu.prototype = Object.assign(Object.create(vu.prototype), {
        constructor: xu,
        ValueTypeName: "number",
      })),
      (bu.prototype = Object.assign(Object.create(pu.prototype), {
        constructor: bu,
        interpolate_: function (t, e, n, r) {
          for (
            var i = this.resultBuffer,
              o = this.sampleValues,
              a = this.valueSize,
              s = t * a,
              c = (n - e) / (r - e),
              u = s + a;
            s !== u;
            s += 4
          )
            We.slerpFlat(i, 0, o, s - a, o, s, c);
          return i;
        },
      })),
      (wu.prototype = Object.assign(Object.create(vu.prototype), {
        constructor: wu,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function (t) {
          return new bu(this.times, this.values, this.getValueSize(), t);
        },
        InterpolantFactoryMethodSmooth: void 0,
      })),
      (_u.prototype = Object.assign(Object.create(vu.prototype), {
        constructor: _u,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0,
      })),
      (Mu.prototype = Object.assign(Object.create(vu.prototype), {
        constructor: Mu,
        ValueTypeName: "vector",
      })),
      Object.assign(Su, {
        parse: function (t) {
          for (
            var e = [], n = t.tracks, r = 1 / (t.fps || 1), i = 0, o = n.length;
            i !== o;
            ++i
          )
            e.push(Eu(n[i]).scale(r));
          return new Su(t.name, t.duration, e);
        },
        toJSON: function (t) {
          for (
            var e = [],
              n = t.tracks,
              r = {
                name: t.name,
                duration: t.duration,
                tracks: e,
                uuid: t.uuid,
              },
              i = 0,
              o = n.length;
            i !== o;
            ++i
          )
            e.push(vu.toJSON(n[i]));
          return r;
        },
        CreateFromMorphTargetSequence: function (t, e, n, r) {
          for (var i = e.length, o = [], a = 0; a < i; a++) {
            var s = [],
              c = [];
            s.push((a + i - 1) % i, a, (a + 1) % i), c.push(0, 1, 0);
            var u = hu.getKeyframeOrder(s);
            (s = hu.sortedArray(s, 1, u)),
              (c = hu.sortedArray(c, 1, u)),
              r || 0 !== s[0] || (s.push(i), c.push(c[0])),
              o.push(
                new xu(".morphTargetInfluences[" + e[a].name + "]", s, c).scale(
                  1 / n
                )
              );
          }
          return new Su(t, -1, o);
        },
        findByName: function (t, e) {
          var n = t;
          if (!Array.isArray(t)) {
            var r = t;
            n = (r.geometry && r.geometry.animations) || r.animations;
          }
          for (var i = 0; i < n.length; i++) if (n[i].name === e) return n[i];
          return null;
        },
        CreateClipsFromMorphTargetSequences: function (t, e, n) {
          for (
            var r = {}, i = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length;
            o < a;
            o++
          ) {
            var s = t[o],
              c = s.name.match(i);
            if (c && c.length > 1) {
              var u = r[(h = c[1])];
              u || (r[h] = u = []), u.push(s);
            }
          }
          var l = [];
          for (var h in r)
            l.push(Su.CreateFromMorphTargetSequence(h, r[h], e, n));
          return l;
        },
        parseAnimation: function (t, e) {
          if (!t)
            return (
              console.error(
                "THREE.AnimationClip: No animation in JSONLoader data."
              ),
              null
            );
          for (
            var n = function (t, e, n, r, i) {
                if (0 !== n.length) {
                  var o = [],
                    a = [];
                  hu.flattenJSON(n, o, a, r),
                    0 !== o.length && i.push(new t(e, o, a));
                }
              },
              r = [],
              i = t.name || "default",
              o = t.length || -1,
              a = t.fps || 30,
              s = t.hierarchy || [],
              c = 0;
            c < s.length;
            c++
          ) {
            var u = s[c].keys;
            if (u && 0 !== u.length)
              if (u[0].morphTargets) {
                for (var l = {}, h = 0; h < u.length; h++)
                  if (u[h].morphTargets)
                    for (var p = 0; p < u[h].morphTargets.length; p++)
                      l[u[h].morphTargets[p]] = -1;
                for (var f in l) {
                  var d = [],
                    m = [];
                  for (p = 0; p !== u[h].morphTargets.length; ++p) {
                    var v = u[h];
                    d.push(v.time), m.push(v.morphTarget === f ? 1 : 0);
                  }
                  r.push(new xu(".morphTargetInfluence[" + f + "]", d, m));
                }
                o = l.length * (a || 1);
              } else {
                var g = ".bones[" + e[c].name + "]";
                n(Mu, g + ".position", u, "pos", r),
                  n(wu, g + ".quaternion", u, "rot", r),
                  n(Mu, g + ".scale", u, "scl", r);
              }
          }
          return 0 === r.length ? null : new Su(i, o, r);
        },
      }),
      Object.assign(Su.prototype, {
        resetDuration: function () {
          for (var t = 0, e = 0, n = this.tracks.length; e !== n; ++e) {
            var r = this.tracks[e];
            t = Math.max(t, r.times[r.times.length - 1]);
          }
          return (this.duration = t), this;
        },
        trim: function () {
          for (var t = 0; t < this.tracks.length; t++)
            this.tracks[t].trim(0, this.duration);
          return this;
        },
        validate: function () {
          for (var t = !0, e = 0; e < this.tracks.length; e++)
            t = t && this.tracks[e].validate();
          return t;
        },
        optimize: function () {
          for (var t = 0; t < this.tracks.length; t++)
            this.tracks[t].optimize();
          return this;
        },
        clone: function () {
          for (var t = [], e = 0; e < this.tracks.length; e++)
            t.push(this.tracks[e].clone());
          return new Su(this.name, this.duration, t);
        },
      });
    var Tu = {
      enabled: !1,
      files: {},
      add: function (t, e) {
        !1 !== this.enabled && (this.files[t] = e);
      },
      get: function (t) {
        if (!1 !== this.enabled) return this.files[t];
      },
      remove: function (t) {
        delete this.files[t];
      },
      clear: function () {
        this.files = {};
      },
    };
    function Au(t, e, n) {
      var r = this,
        i = !1,
        o = 0,
        a = 0,
        s = void 0,
        c = [];
      (this.onStart = void 0),
        (this.onLoad = t),
        (this.onProgress = e),
        (this.onError = n),
        (this.itemStart = function (t) {
          a++, !1 === i && void 0 !== r.onStart && r.onStart(t, o, a), (i = !0);
        }),
        (this.itemEnd = function (t) {
          o++,
            void 0 !== r.onProgress && r.onProgress(t, o, a),
            o === a && ((i = !1), void 0 !== r.onLoad && r.onLoad());
        }),
        (this.itemError = function (t) {
          void 0 !== r.onError && r.onError(t);
        }),
        (this.resolveURL = function (t) {
          return s ? s(t) : t;
        }),
        (this.setURLModifier = function (t) {
          return (s = t), this;
        }),
        (this.addHandler = function (t, e) {
          return c.push(t, e), this;
        }),
        (this.removeHandler = function (t) {
          var e = c.indexOf(t);
          return -1 !== e && c.splice(e, 2), this;
        }),
        (this.getHandler = function (t) {
          for (var e = 0, n = c.length; e < n; e += 2) {
            var r = c[e],
              i = c[e + 1];
            if (r.test(t)) return i;
          }
          return null;
        });
    }
    var Lu = new Au();
    function Pu(t) {
      (this.manager = void 0 !== t ? t : Lu),
        (this.crossOrigin = "anonymous"),
        (this.path = ""),
        (this.resourcePath = "");
    }
    Object.assign(Pu.prototype, {
      load: function () {},
      parse: function () {},
      setCrossOrigin: function (t) {
        return (this.crossOrigin = t), this;
      },
      setPath: function (t) {
        return (this.path = t), this;
      },
      setResourcePath: function (t) {
        return (this.resourcePath = t), this;
      },
    });
    var Ru = {};
    function Cu(t) {
      Pu.call(this, t);
    }
    function Ou(t) {
      Pu.call(this, t);
    }
    function Iu(t) {
      Pu.call(this, t);
    }
    function Nu(t) {
      Pu.call(this, t);
    }
    function Du(t) {
      Pu.call(this, t);
    }
    function zu(t) {
      Pu.call(this, t);
    }
    function Fu(t) {
      Pu.call(this, t);
    }
    function Uu() {
      (this.type = "Curve"), (this.arcLengthDivisions = 200);
    }
    function Bu(t, e, n, r, i, o, a, s) {
      Uu.call(this),
        (this.type = "EllipseCurve"),
        (this.aX = t || 0),
        (this.aY = e || 0),
        (this.xRadius = n || 1),
        (this.yRadius = r || 1),
        (this.aStartAngle = i || 0),
        (this.aEndAngle = o || 2 * Math.PI),
        (this.aClockwise = a || !1),
        (this.aRotation = s || 0);
    }
    function Gu(t, e, n, r, i, o) {
      Bu.call(this, t, e, n, n, r, i, o), (this.type = "ArcCurve");
    }
    function ju() {
      var t = 0,
        e = 0,
        n = 0,
        r = 0;
      function i(i, o, a, s) {
        (t = i),
          (e = a),
          (n = -3 * i + 3 * o - 2 * a - s),
          (r = 2 * i - 2 * o + a + s);
      }
      return {
        initCatmullRom: function (t, e, n, r, o) {
          i(e, n, o * (n - t), o * (r - e));
        },
        initNonuniformCatmullRom: function (t, e, n, r, o, a, s) {
          var c = (e - t) / o - (n - t) / (o + a) + (n - e) / a,
            u = (n - e) / a - (r - e) / (a + s) + (r - n) / s;
          i(e, n, (c *= a), (u *= a));
        },
        calc: function (i) {
          var o = i * i;
          return t + e * i + n * o + r * (o * i);
        },
      };
    }
    (Cu.prototype = Object.assign(Object.create(Pu.prototype), {
      constructor: Cu,
      load: function (t, e, n, r) {
        void 0 === t && (t = ""),
          void 0 !== this.path && (t = this.path + t),
          (t = this.manager.resolveURL(t));
        var i = this,
          o = Tu.get(t);
        if (void 0 !== o)
          return (
            i.manager.itemStart(t),
            setTimeout(function () {
              e && e(o), i.manager.itemEnd(t);
            }, 0),
            o
          );
        if (void 0 === Ru[t]) {
          var a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
          if (a) {
            var s = a[1],
              c = !!a[2],
              u = a[3];
            (u = decodeURIComponent(u)), c && (u = atob(u));
            try {
              var l,
                h = (this.responseType || "").toLowerCase();
              switch (h) {
                case "arraybuffer":
                case "blob":
                  for (
                    var p = new Uint8Array(u.length), f = 0;
                    f < u.length;
                    f++
                  )
                    p[f] = u.charCodeAt(f);
                  l =
                    "blob" === h ? new Blob([p.buffer], { type: s }) : p.buffer;
                  break;
                case "document":
                  var d = new DOMParser();
                  l = d.parseFromString(u, s);
                  break;
                case "json":
                  l = JSON.parse(u);
                  break;
                default:
                  l = u;
              }
              setTimeout(function () {
                e && e(l), i.manager.itemEnd(t);
              }, 0);
            } catch (e) {
              setTimeout(function () {
                r && r(e), i.manager.itemError(t), i.manager.itemEnd(t);
              }, 0);
            }
          } else {
            (Ru[t] = []), Ru[t].push({ onLoad: e, onProgress: n, onError: r });
            var m = new XMLHttpRequest();
            for (var v in (m.open("GET", t, !0),
            m.addEventListener(
              "load",
              function (e) {
                var n = this.response;
                Tu.add(t, n);
                var r = Ru[t];
                if ((delete Ru[t], 200 === this.status || 0 === this.status)) {
                  0 === this.status &&
                    console.warn("THREE.FileLoader: HTTP Status 0 received.");
                  for (var o = 0, a = r.length; o < a; o++) {
                    (s = r[o]).onLoad && s.onLoad(n);
                  }
                  i.manager.itemEnd(t);
                } else {
                  for (o = 0, a = r.length; o < a; o++) {
                    var s;
                    (s = r[o]).onError && s.onError(e);
                  }
                  i.manager.itemError(t), i.manager.itemEnd(t);
                }
              },
              !1
            ),
            m.addEventListener(
              "progress",
              function (e) {
                for (var n = Ru[t], r = 0, i = n.length; r < i; r++) {
                  var o = n[r];
                  o.onProgress && o.onProgress(e);
                }
              },
              !1
            ),
            m.addEventListener(
              "error",
              function (e) {
                var n = Ru[t];
                delete Ru[t];
                for (var r = 0, o = n.length; r < o; r++) {
                  var a = n[r];
                  a.onError && a.onError(e);
                }
                i.manager.itemError(t), i.manager.itemEnd(t);
              },
              !1
            ),
            m.addEventListener(
              "abort",
              function (e) {
                var n = Ru[t];
                delete Ru[t];
                for (var r = 0, o = n.length; r < o; r++) {
                  var a = n[r];
                  a.onError && a.onError(e);
                }
                i.manager.itemError(t), i.manager.itemEnd(t);
              },
              !1
            ),
            void 0 !== this.responseType &&
              (m.responseType = this.responseType),
            void 0 !== this.withCredentials &&
              (m.withCredentials = this.withCredentials),
            m.overrideMimeType &&
              m.overrideMimeType(
                void 0 !== this.mimeType ? this.mimeType : "text/plain"
              ),
            this.requestHeader))
              m.setRequestHeader(v, this.requestHeader[v]);
            m.send(null);
          }
          return i.manager.itemStart(t), m;
        }
        Ru[t].push({ onLoad: e, onProgress: n, onError: r });
      },
      setResponseType: function (t) {
        return (this.responseType = t), this;
      },
      setWithCredentials: function (t) {
        return (this.withCredentials = t), this;
      },
      setMimeType: function (t) {
        return (this.mimeType = t), this;
      },
      setRequestHeader: function (t) {
        return (this.requestHeader = t), this;
      },
    })),
      (Ou.prototype = Object.assign(Object.create(Pu.prototype), {
        constructor: Ou,
        load: function (t, e, n, r) {
          var i = this,
            o = new Cu(i.manager);
          o.setPath(i.path),
            o.load(
              t,
              function (t) {
                e(i.parse(JSON.parse(t)));
              },
              n,
              r
            );
        },
        parse: function (t) {
          for (var e = [], n = 0; n < t.length; n++) {
            var r = Su.parse(t[n]);
            e.push(r);
          }
          return e;
        },
      })),
      (Iu.prototype = Object.assign(Object.create(Pu.prototype), {
        constructor: Iu,
        load: function (t, e, n, r) {
          var i = this,
            o = [],
            a = new Us();
          a.image = o;
          var s = new Cu(this.manager);
          function c(c) {
            s.load(
              t[c],
              function (t) {
                var n = i.parse(t, !0);
                (o[c] = {
                  width: n.width,
                  height: n.height,
                  format: n.format,
                  mipmaps: n.mipmaps,
                }),
                  6 === (u += 1) &&
                    (1 === n.mipmapCount && (a.minFilter = Pt),
                    (a.format = n.format),
                    (a.needsUpdate = !0),
                    e && e(a));
              },
              n,
              r
            );
          }
          if (
            (s.setPath(this.path),
            s.setResponseType("arraybuffer"),
            Array.isArray(t))
          )
            for (var u = 0, l = 0, h = t.length; l < h; ++l) c(l);
          else
            s.load(
              t,
              function (t) {
                var n = i.parse(t, !0);
                if (n.isCubemap)
                  for (
                    var r = n.mipmaps.length / n.mipmapCount, s = 0;
                    s < r;
                    s++
                  ) {
                    o[s] = { mipmaps: [] };
                    for (var c = 0; c < n.mipmapCount; c++)
                      o[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + c]),
                        (o[s].format = n.format),
                        (o[s].width = n.width),
                        (o[s].height = n.height);
                  }
                else
                  (a.image.width = n.width),
                    (a.image.height = n.height),
                    (a.mipmaps = n.mipmaps);
                1 === n.mipmapCount && (a.minFilter = Pt),
                  (a.format = n.format),
                  (a.needsUpdate = !0),
                  e && e(a);
              },
              n,
              r
            );
          return a;
        },
      })),
      (Nu.prototype = Object.assign(Object.create(Pu.prototype), {
        constructor: Nu,
        load: function (t, e, n, r) {
          var i = this,
            o = new Ai(),
            a = new Cu(this.manager);
          return (
            a.setResponseType("arraybuffer"),
            a.setPath(this.path),
            a.load(
              t,
              function (t) {
                var n = i.parse(t);
                n &&
                  (void 0 !== n.image
                    ? (o.image = n.image)
                    : void 0 !== n.data &&
                      ((o.image.width = n.width),
                      (o.image.height = n.height),
                      (o.image.data = n.data)),
                  (o.wrapS = void 0 !== n.wrapS ? n.wrapS : St),
                  (o.wrapT = void 0 !== n.wrapT ? n.wrapT : St),
                  (o.magFilter = void 0 !== n.magFilter ? n.magFilter : Pt),
                  (o.minFilter = void 0 !== n.minFilter ? n.minFilter : Ct),
                  (o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
                  void 0 !== n.format && (o.format = n.format),
                  void 0 !== n.type && (o.type = n.type),
                  void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps),
                  1 === n.mipmapCount && (o.minFilter = Pt),
                  (o.needsUpdate = !0),
                  e && e(o, n));
              },
              n,
              r
            ),
            o
          );
        },
      })),
      (Du.prototype = Object.assign(Object.create(Pu.prototype), {
        constructor: Du,
        load: function (t, e, n, r) {
          void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t));
          var i = this,
            o = Tu.get(t);
          if (void 0 !== o)
            return (
              i.manager.itemStart(t),
              setTimeout(function () {
                e && e(o), i.manager.itemEnd(t);
              }, 0),
              o
            );
          var a = document.createElementNS(
            "http://www.w3.org/1999/xhtml",
            "img"
          );
          function s() {
            a.removeEventListener("load", s, !1),
              a.removeEventListener("error", c, !1),
              Tu.add(t, this),
              e && e(this),
              i.manager.itemEnd(t);
          }
          function c(e) {
            a.removeEventListener("load", s, !1),
              a.removeEventListener("error", c, !1),
              r && r(e),
              i.manager.itemError(t),
              i.manager.itemEnd(t);
          }
          return (
            a.addEventListener("load", s, !1),
            a.addEventListener("error", c, !1),
            "data:" !== t.substr(0, 5) &&
              void 0 !== this.crossOrigin &&
              (a.crossOrigin = this.crossOrigin),
            i.manager.itemStart(t),
            (a.src = t),
            a
          );
        },
      })),
      (zu.prototype = Object.assign(Object.create(Pu.prototype), {
        constructor: zu,
        load: function (t, e, n, r) {
          var i = new $i(),
            o = new Du(this.manager);
          o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
          var a = 0;
          function s(n) {
            o.load(
              t[n],
              function (t) {
                (i.images[n] = t),
                  6 === ++a && ((i.needsUpdate = !0), e && e(i));
              },
              void 0,
              r
            );
          }
          for (var c = 0; c < t.length; ++c) s(c);
          return i;
        },
      })),
      (Fu.prototype = Object.assign(Object.create(Pu.prototype), {
        constructor: Fu,
        load: function (t, e, n, r) {
          var i = new tn(),
            o = new Du(this.manager);
          return (
            o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path),
            o.load(
              t,
              function (n) {
                i.image = n;
                var r =
                  t.search(/\.jpe?g($|\?)/i) > 0 ||
                  0 === t.search(/^data\:image\/jpeg/);
                (i.format = r ? Wt : qt),
                  (i.needsUpdate = !0),
                  void 0 !== e && e(i);
              },
              n,
              r
            ),
            i
          );
        },
      })),
      Object.assign(Uu.prototype, {
        getPoint: function () {
          return (
            console.warn("THREE.Curve: .getPoint() not implemented."), null
          );
        },
        getPointAt: function (t, e) {
          var n = this.getUtoTmapping(t);
          return this.getPoint(n, e);
        },
        getPoints: function (t) {
          void 0 === t && (t = 5);
          for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
          return e;
        },
        getSpacedPoints: function (t) {
          void 0 === t && (t = 5);
          for (var e = [], n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
          return e;
        },
        getLength: function () {
          var t = this.getLengths();
          return t[t.length - 1];
        },
        getLengths: function (t) {
          if (
            (void 0 === t && (t = this.arcLengthDivisions),
            this.cacheArcLengths &&
              this.cacheArcLengths.length === t + 1 &&
              !this.needsUpdate)
          )
            return this.cacheArcLengths;
          this.needsUpdate = !1;
          var e,
            n,
            r = [],
            i = this.getPoint(0),
            o = 0;
          for (r.push(0), n = 1; n <= t; n++)
            (o += (e = this.getPoint(n / t)).distanceTo(i)), r.push(o), (i = e);
          return (this.cacheArcLengths = r), r;
        },
        updateArcLengths: function () {
          (this.needsUpdate = !0), this.getLengths();
        },
        getUtoTmapping: function (t, e) {
          var n,
            r = this.getLengths(),
            i = 0,
            o = r.length;
          n = e || t * r[o - 1];
          for (var a, s = 0, c = o - 1; s <= c; )
            if ((a = r[(i = Math.floor(s + (c - s) / 2))] - n) < 0) s = i + 1;
            else {
              if (!(a > 0)) {
                c = i;
                break;
              }
              c = i - 1;
            }
          if (r[(i = c)] === n) return i / (o - 1);
          var u = r[i];
          return (i + (n - u) / (r[i + 1] - u)) / (o - 1);
        },
        getTangent: function (t) {
          var e = t - 1e-4,
            n = t + 1e-4;
          e < 0 && (e = 0), n > 1 && (n = 1);
          var r = this.getPoint(e);
          return this.getPoint(n).clone().sub(r).normalize();
        },
        getTangentAt: function (t) {
          var e = this.getUtoTmapping(t);
          return this.getTangent(e);
        },
        computeFrenetFrames: function (t, e) {
          var n,
            r,
            i,
            o = new Ye(),
            a = [],
            s = [],
            c = [],
            u = new Ye(),
            l = new pn();
          for (n = 0; n <= t; n++)
            (r = n / t), (a[n] = this.getTangentAt(r)), a[n].normalize();
          (s[0] = new Ye()), (c[0] = new Ye());
          var h = Number.MAX_VALUE,
            p = Math.abs(a[0].x),
            f = Math.abs(a[0].y),
            d = Math.abs(a[0].z);
          for (
            p <= h && ((h = p), o.set(1, 0, 0)),
              f <= h && ((h = f), o.set(0, 1, 0)),
              d <= h && o.set(0, 0, 1),
              u.crossVectors(a[0], o).normalize(),
              s[0].crossVectors(a[0], u),
              c[0].crossVectors(a[0], s[0]),
              n = 1;
            n <= t;
            n++
          )
            (s[n] = s[n - 1].clone()),
              (c[n] = c[n - 1].clone()),
              u.crossVectors(a[n - 1], a[n]),
              u.length() > Number.EPSILON &&
                (u.normalize(),
                (i = Math.acos(He.clamp(a[n - 1].dot(a[n]), -1, 1))),
                s[n].applyMatrix4(l.makeRotationAxis(u, i))),
              c[n].crossVectors(a[n], s[n]);
          if (!0 === e)
            for (
              i = Math.acos(He.clamp(s[0].dot(s[t]), -1, 1)),
                i /= t,
                a[0].dot(u.crossVectors(s[0], s[t])) > 0 && (i = -i),
                n = 1;
              n <= t;
              n++
            )
              s[n].applyMatrix4(l.makeRotationAxis(a[n], i * n)),
                c[n].crossVectors(a[n], s[n]);
          return { tangents: a, normals: s, binormals: c };
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return (this.arcLengthDivisions = t.arcLengthDivisions), this;
        },
        toJSON: function () {
          var t = {
            metadata: {
              version: 4.5,
              type: "Curve",
              generator: "Curve.toJSON",
            },
          };
          return (
            (t.arcLengthDivisions = this.arcLengthDivisions),
            (t.type = this.type),
            t
          );
        },
        fromJSON: function (t) {
          return (this.arcLengthDivisions = t.arcLengthDivisions), this;
        },
      }),
      (Bu.prototype = Object.create(Uu.prototype)),
      (Bu.prototype.constructor = Bu),
      (Bu.prototype.isEllipseCurve = !0),
      (Bu.prototype.getPoint = function (t, e) {
        for (
          var n = e || new ke(),
            r = 2 * Math.PI,
            i = this.aEndAngle - this.aStartAngle,
            o = Math.abs(i) < Number.EPSILON;
          i < 0;

        )
          i += r;
        for (; i > r; ) i -= r;
        i < Number.EPSILON && (i = o ? 0 : r),
          !0 !== this.aClockwise || o || (i === r ? (i = -r) : (i -= r));
        var a = this.aStartAngle + t * i,
          s = this.aX + this.xRadius * Math.cos(a),
          c = this.aY + this.yRadius * Math.sin(a);
        if (0 !== this.aRotation) {
          var u = Math.cos(this.aRotation),
            l = Math.sin(this.aRotation),
            h = s - this.aX,
            p = c - this.aY;
          (s = h * u - p * l + this.aX), (c = h * l + p * u + this.aY);
        }
        return n.set(s, c);
      }),
      (Bu.prototype.copy = function (t) {
        return (
          Uu.prototype.copy.call(this, t),
          (this.aX = t.aX),
          (this.aY = t.aY),
          (this.xRadius = t.xRadius),
          (this.yRadius = t.yRadius),
          (this.aStartAngle = t.aStartAngle),
          (this.aEndAngle = t.aEndAngle),
          (this.aClockwise = t.aClockwise),
          (this.aRotation = t.aRotation),
          this
        );
      }),
      (Bu.prototype.toJSON = function () {
        var t = Uu.prototype.toJSON.call(this);
        return (
          (t.aX = this.aX),
          (t.aY = this.aY),
          (t.xRadius = this.xRadius),
          (t.yRadius = this.yRadius),
          (t.aStartAngle = this.aStartAngle),
          (t.aEndAngle = this.aEndAngle),
          (t.aClockwise = this.aClockwise),
          (t.aRotation = this.aRotation),
          t
        );
      }),
      (Bu.prototype.fromJSON = function (t) {
        return (
          Uu.prototype.fromJSON.call(this, t),
          (this.aX = t.aX),
          (this.aY = t.aY),
          (this.xRadius = t.xRadius),
          (this.yRadius = t.yRadius),
          (this.aStartAngle = t.aStartAngle),
          (this.aEndAngle = t.aEndAngle),
          (this.aClockwise = t.aClockwise),
          (this.aRotation = t.aRotation),
          this
        );
      }),
      (Gu.prototype = Object.create(Bu.prototype)),
      (Gu.prototype.constructor = Gu),
      (Gu.prototype.isArcCurve = !0);
    var Vu = new Ye(),
      Hu = new ju(),
      ku = new ju(),
      Wu = new ju();
    function qu(t, e, n, r) {
      Uu.call(this),
        (this.type = "CatmullRomCurve3"),
        (this.points = t || []),
        (this.closed = e || !1),
        (this.curveType = n || "centripetal"),
        (this.tension = r || 0.5);
    }
    function Xu(t, e, n, r, i) {
      var o = 0.5 * (r - e),
        a = 0.5 * (i - n),
        s = t * t;
      return (
        (2 * n - 2 * r + o + a) * (t * s) +
        (-3 * n + 3 * r - 2 * o - a) * s +
        o * t +
        n
      );
    }
    function Yu(t, e, n, r) {
      return (
        (function (t, e) {
          var n = 1 - t;
          return n * n * e;
        })(t, e) +
        (function (t, e) {
          return 2 * (1 - t) * t * e;
        })(t, n) +
        (function (t, e) {
          return t * t * e;
        })(t, r)
      );
    }
    function Ju(t, e, n, r, i) {
      return (
        (function (t, e) {
          var n = 1 - t;
          return n * n * n * e;
        })(t, e) +
        (function (t, e) {
          var n = 1 - t;
          return 3 * n * n * t * e;
        })(t, n) +
        (function (t, e) {
          return 3 * (1 - t) * t * t * e;
        })(t, r) +
        (function (t, e) {
          return t * t * t * e;
        })(t, i)
      );
    }
    function Zu(t, e, n, r) {
      Uu.call(this),
        (this.type = "CubicBezierCurve"),
        (this.v0 = t || new ke()),
        (this.v1 = e || new ke()),
        (this.v2 = n || new ke()),
        (this.v3 = r || new ke());
    }
    function Qu(t, e, n, r) {
      Uu.call(this),
        (this.type = "CubicBezierCurve3"),
        (this.v0 = t || new Ye()),
        (this.v1 = e || new Ye()),
        (this.v2 = n || new Ye()),
        (this.v3 = r || new Ye());
    }
    function Ku(t, e) {
      Uu.call(this),
        (this.type = "LineCurve"),
        (this.v1 = t || new ke()),
        (this.v2 = e || new ke());
    }
    function $u(t, e) {
      Uu.call(this),
        (this.type = "LineCurve3"),
        (this.v1 = t || new Ye()),
        (this.v2 = e || new Ye());
    }
    function tl(t, e, n) {
      Uu.call(this),
        (this.type = "QuadraticBezierCurve"),
        (this.v0 = t || new ke()),
        (this.v1 = e || new ke()),
        (this.v2 = n || new ke());
    }
    function el(t, e, n) {
      Uu.call(this),
        (this.type = "QuadraticBezierCurve3"),
        (this.v0 = t || new Ye()),
        (this.v1 = e || new Ye()),
        (this.v2 = n || new Ye());
    }
    function nl(t) {
      Uu.call(this), (this.type = "SplineCurve"), (this.points = t || []);
    }
    (qu.prototype = Object.create(Uu.prototype)),
      (qu.prototype.constructor = qu),
      (qu.prototype.isCatmullRomCurve3 = !0),
      (qu.prototype.getPoint = function (t, e) {
        var n,
          r,
          i,
          o,
          a = e || new Ye(),
          s = this.points,
          c = s.length,
          u = (c - (this.closed ? 0 : 1)) * t,
          l = Math.floor(u),
          h = u - l;
        if (
          (this.closed
            ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / c) + 1) * c)
            : 0 === h && l === c - 1 && ((l = c - 2), (h = 1)),
          this.closed || l > 0
            ? (n = s[(l - 1) % c])
            : (Vu.subVectors(s[0], s[1]).add(s[0]), (n = Vu)),
          (r = s[l % c]),
          (i = s[(l + 1) % c]),
          this.closed || l + 2 < c
            ? (o = s[(l + 2) % c])
            : (Vu.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]), (o = Vu)),
          "centripetal" === this.curveType || "chordal" === this.curveType)
        ) {
          var p = "chordal" === this.curveType ? 0.5 : 0.25,
            f = Math.pow(n.distanceToSquared(r), p),
            d = Math.pow(r.distanceToSquared(i), p),
            m = Math.pow(i.distanceToSquared(o), p);
          d < 1e-4 && (d = 1),
            f < 1e-4 && (f = d),
            m < 1e-4 && (m = d),
            Hu.initNonuniformCatmullRom(n.x, r.x, i.x, o.x, f, d, m),
            ku.initNonuniformCatmullRom(n.y, r.y, i.y, o.y, f, d, m),
            Wu.initNonuniformCatmullRom(n.z, r.z, i.z, o.z, f, d, m);
        } else
          "catmullrom" === this.curveType &&
            (Hu.initCatmullRom(n.x, r.x, i.x, o.x, this.tension),
            ku.initCatmullRom(n.y, r.y, i.y, o.y, this.tension),
            Wu.initCatmullRom(n.z, r.z, i.z, o.z, this.tension));
        return a.set(Hu.calc(h), ku.calc(h), Wu.calc(h)), a;
      }),
      (qu.prototype.copy = function (t) {
        Uu.prototype.copy.call(this, t), (this.points = []);
        for (var e = 0, n = t.points.length; e < n; e++) {
          var r = t.points[e];
          this.points.push(r.clone());
        }
        return (
          (this.closed = t.closed),
          (this.curveType = t.curveType),
          (this.tension = t.tension),
          this
        );
      }),
      (qu.prototype.toJSON = function () {
        var t = Uu.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, n = this.points.length; e < n; e++) {
          var r = this.points[e];
          t.points.push(r.toArray());
        }
        return (
          (t.closed = this.closed),
          (t.curveType = this.curveType),
          (t.tension = this.tension),
          t
        );
      }),
      (qu.prototype.fromJSON = function (t) {
        Uu.prototype.fromJSON.call(this, t), (this.points = []);
        for (var e = 0, n = t.points.length; e < n; e++) {
          var r = t.points[e];
          this.points.push(new Ye().fromArray(r));
        }
        return (
          (this.closed = t.closed),
          (this.curveType = t.curveType),
          (this.tension = t.tension),
          this
        );
      }),
      (Zu.prototype = Object.create(Uu.prototype)),
      (Zu.prototype.constructor = Zu),
      (Zu.prototype.isCubicBezierCurve = !0),
      (Zu.prototype.getPoint = function (t, e) {
        var n = e || new ke(),
          r = this.v0,
          i = this.v1,
          o = this.v2,
          a = this.v3;
        return n.set(Ju(t, r.x, i.x, o.x, a.x), Ju(t, r.y, i.y, o.y, a.y)), n;
      }),
      (Zu.prototype.copy = function (t) {
        return (
          Uu.prototype.copy.call(this, t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this.v3.copy(t.v3),
          this
        );
      }),
      (Zu.prototype.toJSON = function () {
        var t = Uu.prototype.toJSON.call(this);
        return (
          (t.v0 = this.v0.toArray()),
          (t.v1 = this.v1.toArray()),
          (t.v2 = this.v2.toArray()),
          (t.v3 = this.v3.toArray()),
          t
        );
      }),
      (Zu.prototype.fromJSON = function (t) {
        return (
          Uu.prototype.fromJSON.call(this, t),
          this.v0.fromArray(t.v0),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this.v3.fromArray(t.v3),
          this
        );
      }),
      (Qu.prototype = Object.create(Uu.prototype)),
      (Qu.prototype.constructor = Qu),
      (Qu.prototype.isCubicBezierCurve3 = !0),
      (Qu.prototype.getPoint = function (t, e) {
        var n = e || new Ye(),
          r = this.v0,
          i = this.v1,
          o = this.v2,
          a = this.v3;
        return (
          n.set(
            Ju(t, r.x, i.x, o.x, a.x),
            Ju(t, r.y, i.y, o.y, a.y),
            Ju(t, r.z, i.z, o.z, a.z)
          ),
          n
        );
      }),
      (Qu.prototype.copy = function (t) {
        return (
          Uu.prototype.copy.call(this, t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this.v3.copy(t.v3),
          this
        );
      }),
      (Qu.prototype.toJSON = function () {
        var t = Uu.prototype.toJSON.call(this);
        return (
          (t.v0 = this.v0.toArray()),
          (t.v1 = this.v1.toArray()),
          (t.v2 = this.v2.toArray()),
          (t.v3 = this.v3.toArray()),
          t
        );
      }),
      (Qu.prototype.fromJSON = function (t) {
        return (
          Uu.prototype.fromJSON.call(this, t),
          this.v0.fromArray(t.v0),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this.v3.fromArray(t.v3),
          this
        );
      }),
      (Ku.prototype = Object.create(Uu.prototype)),
      (Ku.prototype.constructor = Ku),
      (Ku.prototype.isLineCurve = !0),
      (Ku.prototype.getPoint = function (t, e) {
        var n = e || new ke();
        return (
          1 === t
            ? n.copy(this.v2)
            : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
          n
        );
      }),
      (Ku.prototype.getPointAt = function (t, e) {
        return this.getPoint(t, e);
      }),
      (Ku.prototype.getTangent = function () {
        return this.v2.clone().sub(this.v1).normalize();
      }),
      (Ku.prototype.copy = function (t) {
        return (
          Uu.prototype.copy.call(this, t),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this
        );
      }),
      (Ku.prototype.toJSON = function () {
        var t = Uu.prototype.toJSON.call(this);
        return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
      }),
      (Ku.prototype.fromJSON = function (t) {
        return (
          Uu.prototype.fromJSON.call(this, t),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this
        );
      }),
      ($u.prototype = Object.create(Uu.prototype)),
      ($u.prototype.constructor = $u),
      ($u.prototype.isLineCurve3 = !0),
      ($u.prototype.getPoint = function (t, e) {
        var n = e || new Ye();
        return (
          1 === t
            ? n.copy(this.v2)
            : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
          n
        );
      }),
      ($u.prototype.getPointAt = function (t, e) {
        return this.getPoint(t, e);
      }),
      ($u.prototype.copy = function (t) {
        return (
          Uu.prototype.copy.call(this, t),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this
        );
      }),
      ($u.prototype.toJSON = function () {
        var t = Uu.prototype.toJSON.call(this);
        return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
      }),
      ($u.prototype.fromJSON = function (t) {
        return (
          Uu.prototype.fromJSON.call(this, t),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this
        );
      }),
      (tl.prototype = Object.create(Uu.prototype)),
      (tl.prototype.constructor = tl),
      (tl.prototype.isQuadraticBezierCurve = !0),
      (tl.prototype.getPoint = function (t, e) {
        var n = e || new ke(),
          r = this.v0,
          i = this.v1,
          o = this.v2;
        return n.set(Yu(t, r.x, i.x, o.x), Yu(t, r.y, i.y, o.y)), n;
      }),
      (tl.prototype.copy = function (t) {
        return (
          Uu.prototype.copy.call(this, t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this
        );
      }),
      (tl.prototype.toJSON = function () {
        var t = Uu.prototype.toJSON.call(this);
        return (
          (t.v0 = this.v0.toArray()),
          (t.v1 = this.v1.toArray()),
          (t.v2 = this.v2.toArray()),
          t
        );
      }),
      (tl.prototype.fromJSON = function (t) {
        return (
          Uu.prototype.fromJSON.call(this, t),
          this.v0.fromArray(t.v0),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this
        );
      }),
      (el.prototype = Object.create(Uu.prototype)),
      (el.prototype.constructor = el),
      (el.prototype.isQuadraticBezierCurve3 = !0),
      (el.prototype.getPoint = function (t, e) {
        var n = e || new Ye(),
          r = this.v0,
          i = this.v1,
          o = this.v2;
        return (
          n.set(
            Yu(t, r.x, i.x, o.x),
            Yu(t, r.y, i.y, o.y),
            Yu(t, r.z, i.z, o.z)
          ),
          n
        );
      }),
      (el.prototype.copy = function (t) {
        return (
          Uu.prototype.copy.call(this, t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this
        );
      }),
      (el.prototype.toJSON = function () {
        var t = Uu.prototype.toJSON.call(this);
        return (
          (t.v0 = this.v0.toArray()),
          (t.v1 = this.v1.toArray()),
          (t.v2 = this.v2.toArray()),
          t
        );
      }),
      (el.prototype.fromJSON = function (t) {
        return (
          Uu.prototype.fromJSON.call(this, t),
          this.v0.fromArray(t.v0),
          this.v1.fromArray(t.v1),
          this.v2.fromArray(t.v2),
          this
        );
      }),
      (nl.prototype = Object.create(Uu.prototype)),
      (nl.prototype.constructor = nl),
      (nl.prototype.isSplineCurve = !0),
      (nl.prototype.getPoint = function (t, e) {
        var n = e || new ke(),
          r = this.points,
          i = (r.length - 1) * t,
          o = Math.floor(i),
          a = i - o,
          s = r[0 === o ? o : o - 1],
          c = r[o],
          u = r[o > r.length - 2 ? r.length - 1 : o + 1],
          l = r[o > r.length - 3 ? r.length - 1 : o + 2];
        return n.set(Xu(a, s.x, c.x, u.x, l.x), Xu(a, s.y, c.y, u.y, l.y)), n;
      }),
      (nl.prototype.copy = function (t) {
        Uu.prototype.copy.call(this, t), (this.points = []);
        for (var e = 0, n = t.points.length; e < n; e++) {
          var r = t.points[e];
          this.points.push(r.clone());
        }
        return this;
      }),
      (nl.prototype.toJSON = function () {
        var t = Uu.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, n = this.points.length; e < n; e++) {
          var r = this.points[e];
          t.points.push(r.toArray());
        }
        return t;
      }),
      (nl.prototype.fromJSON = function (t) {
        Uu.prototype.fromJSON.call(this, t), (this.points = []);
        for (var e = 0, n = t.points.length; e < n; e++) {
          var r = t.points[e];
          this.points.push(new ke().fromArray(r));
        }
        return this;
      });
    var rl = Object.freeze({
      ArcCurve: Gu,
      CatmullRomCurve3: qu,
      CubicBezierCurve: Zu,
      CubicBezierCurve3: Qu,
      EllipseCurve: Bu,
      LineCurve: Ku,
      LineCurve3: $u,
      QuadraticBezierCurve: tl,
      QuadraticBezierCurve3: el,
      SplineCurve: nl,
    });
    function il() {
      Uu.call(this),
        (this.type = "CurvePath"),
        (this.curves = []),
        (this.autoClose = !1);
    }
    function ol(t) {
      il.call(this),
        (this.type = "Path"),
        (this.currentPoint = new ke()),
        t && this.setFromPoints(t);
    }
    function al(t) {
      ol.call(this, t),
        (this.uuid = He.generateUUID()),
        (this.type = "Shape"),
        (this.holes = []);
    }
    function sl(t, e) {
      Rn.call(this),
        (this.type = "Light"),
        (this.color = new vr(t)),
        (this.intensity = void 0 !== e ? e : 1),
        (this.receiveShadow = void 0);
    }
    function cl(t, e, n) {
      sl.call(this, t, n),
        (this.type = "HemisphereLight"),
        (this.castShadow = void 0),
        this.position.copy(Rn.DefaultUp),
        this.updateMatrix(),
        (this.groundColor = new vr(e));
    }
    function ul(t) {
      (this.camera = t),
        (this.bias = 0),
        (this.radius = 1),
        (this.mapSize = new ke(512, 512)),
        (this.map = null),
        (this.mapPass = null),
        (this.matrix = new pn()),
        (this._frustum = new Ni()),
        (this._frameExtents = new ke(1, 1)),
        (this._viewportCount = 1),
        (this._viewports = [new en(0, 0, 1, 1)]);
    }
    function ll() {
      ul.call(this, new _i(50, 1, 0.5, 500));
    }
    function hl(t, e, n, r, i, o) {
      sl.call(this, t, e),
        (this.type = "SpotLight"),
        this.position.copy(Rn.DefaultUp),
        this.updateMatrix(),
        (this.target = new Rn()),
        Object.defineProperty(this, "power", {
          get: function () {
            return this.intensity * Math.PI;
          },
          set: function (t) {
            this.intensity = t / Math.PI;
          },
        }),
        (this.distance = void 0 !== n ? n : 0),
        (this.angle = void 0 !== r ? r : Math.PI / 3),
        (this.penumbra = void 0 !== i ? i : 0),
        (this.decay = void 0 !== o ? o : 1),
        (this.shadow = new ll());
    }
    function pl() {
      ul.call(this, new _i(90, 1, 0.5, 500)),
        (this._frameExtents = new ke(4, 2)),
        (this._viewportCount = 6),
        (this._viewports = [
          new en(2, 1, 1, 1),
          new en(0, 1, 1, 1),
          new en(3, 1, 1, 1),
          new en(1, 1, 1, 1),
          new en(3, 0, 1, 1),
          new en(1, 0, 1, 1),
        ]),
        (this._cubeDirections = [
          new Ye(1, 0, 0),
          new Ye(-1, 0, 0),
          new Ye(0, 0, 1),
          new Ye(0, 0, -1),
          new Ye(0, 1, 0),
          new Ye(0, -1, 0),
        ]),
        (this._cubeUps = [
          new Ye(0, 1, 0),
          new Ye(0, 1, 0),
          new Ye(0, 1, 0),
          new Ye(0, 1, 0),
          new Ye(0, 0, 1),
          new Ye(0, 0, -1),
        ]);
    }
    function fl(t, e, n, r) {
      sl.call(this, t, e),
        (this.type = "PointLight"),
        Object.defineProperty(this, "power", {
          get: function () {
            return 4 * this.intensity * Math.PI;
          },
          set: function (t) {
            this.intensity = t / (4 * Math.PI);
          },
        }),
        (this.distance = void 0 !== n ? n : 0),
        (this.decay = void 0 !== r ? r : 1),
        (this.shadow = new pl());
    }
    function dl(t, e, n, r, i, o) {
      wi.call(this),
        (this.type = "OrthographicCamera"),
        (this.zoom = 1),
        (this.view = null),
        (this.left = void 0 !== t ? t : -1),
        (this.right = void 0 !== e ? e : 1),
        (this.top = void 0 !== n ? n : 1),
        (this.bottom = void 0 !== r ? r : -1),
        (this.near = void 0 !== i ? i : 0.1),
        (this.far = void 0 !== o ? o : 2e3),
        this.updateProjectionMatrix();
    }
    function ml() {
      ul.call(this, new dl(-5, 5, 5, -5, 0.5, 500));
    }
    function vl(t, e) {
      sl.call(this, t, e),
        (this.type = "DirectionalLight"),
        this.position.copy(Rn.DefaultUp),
        this.updateMatrix(),
        (this.target = new Rn()),
        (this.shadow = new ml());
    }
    function gl(t, e) {
      sl.call(this, t, e),
        (this.type = "AmbientLight"),
        (this.castShadow = void 0);
    }
    function yl(t, e, n, r) {
      sl.call(this, t, e),
        (this.type = "RectAreaLight"),
        (this.width = void 0 !== n ? n : 10),
        (this.height = void 0 !== r ? r : 10);
    }
    function xl(t) {
      Pu.call(this, t), (this.textures = {});
    }
    (il.prototype = Object.assign(Object.create(Uu.prototype), {
      constructor: il,
      add: function (t) {
        this.curves.push(t);
      },
      closePath: function () {
        var t = this.curves[0].getPoint(0),
          e = this.curves[this.curves.length - 1].getPoint(1);
        t.equals(e) || this.curves.push(new Ku(e, t));
      },
      getPoint: function (t) {
        for (
          var e = t * this.getLength(), n = this.getCurveLengths(), r = 0;
          r < n.length;

        ) {
          if (n[r] >= e) {
            var i = n[r] - e,
              o = this.curves[r],
              a = o.getLength(),
              s = 0 === a ? 0 : 1 - i / a;
            return o.getPointAt(s);
          }
          r++;
        }
        return null;
      },
      getLength: function () {
        var t = this.getCurveLengths();
        return t[t.length - 1];
      },
      updateArcLengths: function () {
        (this.needsUpdate = !0),
          (this.cacheLengths = null),
          this.getCurveLengths();
      },
      getCurveLengths: function () {
        if (
          this.cacheLengths &&
          this.cacheLengths.length === this.curves.length
        )
          return this.cacheLengths;
        for (var t = [], e = 0, n = 0, r = this.curves.length; n < r; n++)
          (e += this.curves[n].getLength()), t.push(e);
        return (this.cacheLengths = t), t;
      },
      getSpacedPoints: function (t) {
        void 0 === t && (t = 40);
        for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
        return this.autoClose && e.push(e[0]), e;
      },
      getPoints: function (t) {
        t = t || 12;
        for (var e, n = [], r = 0, i = this.curves; r < i.length; r++)
          for (
            var o = i[r],
              a =
                o && o.isEllipseCurve
                  ? 2 * t
                  : o && (o.isLineCurve || o.isLineCurve3)
                  ? 1
                  : o && o.isSplineCurve
                  ? t * o.points.length
                  : t,
              s = o.getPoints(a),
              c = 0;
            c < s.length;
            c++
          ) {
            var u = s[c];
            (e && e.equals(u)) || (n.push(u), (e = u));
          }
        return (
          this.autoClose &&
            n.length > 1 &&
            !n[n.length - 1].equals(n[0]) &&
            n.push(n[0]),
          n
        );
      },
      copy: function (t) {
        Uu.prototype.copy.call(this, t), (this.curves = []);
        for (var e = 0, n = t.curves.length; e < n; e++) {
          var r = t.curves[e];
          this.curves.push(r.clone());
        }
        return (this.autoClose = t.autoClose), this;
      },
      toJSON: function () {
        var t = Uu.prototype.toJSON.call(this);
        (t.autoClose = this.autoClose), (t.curves = []);
        for (var e = 0, n = this.curves.length; e < n; e++) {
          var r = this.curves[e];
          t.curves.push(r.toJSON());
        }
        return t;
      },
      fromJSON: function (t) {
        Uu.prototype.fromJSON.call(this, t),
          (this.autoClose = t.autoClose),
          (this.curves = []);
        for (var e = 0, n = t.curves.length; e < n; e++) {
          var r = t.curves[e];
          this.curves.push(new rl[r.type]().fromJSON(r));
        }
        return this;
      },
    })),
      (ol.prototype = Object.assign(Object.create(il.prototype), {
        constructor: ol,
        setFromPoints: function (t) {
          this.moveTo(t[0].x, t[0].y);
          for (var e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
        },
        moveTo: function (t, e) {
          this.currentPoint.set(t, e);
        },
        lineTo: function (t, e) {
          var n = new Ku(this.currentPoint.clone(), new ke(t, e));
          this.curves.push(n), this.currentPoint.set(t, e);
        },
        quadraticCurveTo: function (t, e, n, r) {
          var i = new tl(this.currentPoint.clone(), new ke(t, e), new ke(n, r));
          this.curves.push(i), this.currentPoint.set(n, r);
        },
        bezierCurveTo: function (t, e, n, r, i, o) {
          var a = new Zu(
            this.currentPoint.clone(),
            new ke(t, e),
            new ke(n, r),
            new ke(i, o)
          );
          this.curves.push(a), this.currentPoint.set(i, o);
        },
        splineThru: function (t) {
          var e = new nl([this.currentPoint.clone()].concat(t));
          this.curves.push(e), this.currentPoint.copy(t[t.length - 1]);
        },
        arc: function (t, e, n, r, i, o) {
          var a = this.currentPoint.x,
            s = this.currentPoint.y;
          this.absarc(t + a, e + s, n, r, i, o);
        },
        absarc: function (t, e, n, r, i, o) {
          this.absellipse(t, e, n, n, r, i, o);
        },
        ellipse: function (t, e, n, r, i, o, a, s) {
          var c = this.currentPoint.x,
            u = this.currentPoint.y;
          this.absellipse(t + c, e + u, n, r, i, o, a, s);
        },
        absellipse: function (t, e, n, r, i, o, a, s) {
          var c = new Bu(t, e, n, r, i, o, a, s);
          if (this.curves.length > 0) {
            var u = c.getPoint(0);
            u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
          }
          this.curves.push(c);
          var l = c.getPoint(1);
          this.currentPoint.copy(l);
        },
        copy: function (t) {
          return (
            il.prototype.copy.call(this, t),
            this.currentPoint.copy(t.currentPoint),
            this
          );
        },
        toJSON: function () {
          var t = il.prototype.toJSON.call(this);
          return (t.currentPoint = this.currentPoint.toArray()), t;
        },
        fromJSON: function (t) {
          return (
            il.prototype.fromJSON.call(this, t),
            this.currentPoint.fromArray(t.currentPoint),
            this
          );
        },
      })),
      (al.prototype = Object.assign(Object.create(ol.prototype), {
        constructor: al,
        getPointsHoles: function (t) {
          for (var e = [], n = 0, r = this.holes.length; n < r; n++)
            e[n] = this.holes[n].getPoints(t);
          return e;
        },
        extractPoints: function (t) {
          return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
        },
        copy: function (t) {
          ol.prototype.copy.call(this, t), (this.holes = []);
          for (var e = 0, n = t.holes.length; e < n; e++) {
            var r = t.holes[e];
            this.holes.push(r.clone());
          }
          return this;
        },
        toJSON: function () {
          var t = ol.prototype.toJSON.call(this);
          (t.uuid = this.uuid), (t.holes = []);
          for (var e = 0, n = this.holes.length; e < n; e++) {
            var r = this.holes[e];
            t.holes.push(r.toJSON());
          }
          return t;
        },
        fromJSON: function (t) {
          ol.prototype.fromJSON.call(this, t),
            (this.uuid = t.uuid),
            (this.holes = []);
          for (var e = 0, n = t.holes.length; e < n; e++) {
            var r = t.holes[e];
            this.holes.push(new ol().fromJSON(r));
          }
          return this;
        },
      })),
      (sl.prototype = Object.assign(Object.create(Rn.prototype), {
        constructor: sl,
        isLight: !0,
        copy: function (t) {
          return (
            Rn.prototype.copy.call(this, t),
            this.color.copy(t.color),
            (this.intensity = t.intensity),
            this
          );
        },
        toJSON: function (t) {
          var e = Rn.prototype.toJSON.call(this, t);
          return (
            (e.object.color = this.color.getHex()),
            (e.object.intensity = this.intensity),
            void 0 !== this.groundColor &&
              (e.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (e.object.distance = this.distance),
            void 0 !== this.angle && (e.object.angle = this.angle),
            void 0 !== this.decay && (e.object.decay = this.decay),
            void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
            e
          );
        },
      })),
      (cl.prototype = Object.assign(Object.create(sl.prototype), {
        constructor: cl,
        isHemisphereLight: !0,
        copy: function (t) {
          return (
            sl.prototype.copy.call(this, t),
            this.groundColor.copy(t.groundColor),
            this
          );
        },
      })),
      Object.assign(ul.prototype, {
        _projScreenMatrix: new pn(),
        _lightPositionWorld: new Ye(),
        _lookTarget: new Ye(),
        getViewportCount: function () {
          return this._viewportCount;
        },
        getFrustum: function () {
          return this._frustum;
        },
        updateMatrices: function (t) {
          var e = this.camera,
            n = this.matrix,
            r = this._projScreenMatrix,
            i = this._lookTarget,
            o = this._lightPositionWorld;
          o.setFromMatrixPosition(t.matrixWorld),
            e.position.copy(o),
            i.setFromMatrixPosition(t.target.matrixWorld),
            e.lookAt(i),
            e.updateMatrixWorld(),
            r.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            this._frustum.setFromMatrix(r),
            n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            n.multiply(e.projectionMatrix),
            n.multiply(e.matrixWorldInverse);
        },
        getViewport: function (t) {
          return this._viewports[t];
        },
        getFrameExtents: function () {
          return this._frameExtents;
        },
        copy: function (t) {
          return (
            (this.camera = t.camera.clone()),
            (this.bias = t.bias),
            (this.radius = t.radius),
            this.mapSize.copy(t.mapSize),
            this
          );
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        toJSON: function () {
          var t = {};
          return (
            0 !== this.bias && (t.bias = this.bias),
            1 !== this.radius && (t.radius = this.radius),
            (512 === this.mapSize.x && 512 === this.mapSize.y) ||
              (t.mapSize = this.mapSize.toArray()),
            (t.camera = this.camera.toJSON(!1).object),
            delete t.camera.matrix,
            t
          );
        },
      }),
      (ll.prototype = Object.assign(Object.create(ul.prototype), {
        constructor: ll,
        isSpotLightShadow: !0,
        updateMatrices: function (t, e, n) {
          var r = this.camera,
            i = 2 * He.RAD2DEG * t.angle,
            o = this.mapSize.width / this.mapSize.height,
            a = t.distance || r.far;
          (i === r.fov && o === r.aspect && a === r.far) ||
            ((r.fov = i),
            (r.aspect = o),
            (r.far = a),
            r.updateProjectionMatrix()),
            ul.prototype.updateMatrices.call(this, t, e, n);
        },
      })),
      (hl.prototype = Object.assign(Object.create(sl.prototype), {
        constructor: hl,
        isSpotLight: !0,
        copy: function (t) {
          return (
            sl.prototype.copy.call(this, t),
            (this.distance = t.distance),
            (this.angle = t.angle),
            (this.penumbra = t.penumbra),
            (this.decay = t.decay),
            (this.target = t.target.clone()),
            (this.shadow = t.shadow.clone()),
            this
          );
        },
      })),
      (pl.prototype = Object.assign(Object.create(ul.prototype), {
        constructor: pl,
        isPointLightShadow: !0,
        updateMatrices: function (t, e, n) {
          var r = this.camera,
            i = this.matrix,
            o = this._lightPositionWorld,
            a = this._lookTarget,
            s = this._projScreenMatrix;
          o.setFromMatrixPosition(t.matrixWorld),
            r.position.copy(o),
            a.copy(r.position),
            a.add(this._cubeDirections[n]),
            r.up.copy(this._cubeUps[n]),
            r.lookAt(a),
            r.updateMatrixWorld(),
            i.makeTranslation(-o.x, -o.y, -o.z),
            s.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
            this._frustum.setFromMatrix(s);
        },
      })),
      (fl.prototype = Object.assign(Object.create(sl.prototype), {
        constructor: fl,
        isPointLight: !0,
        copy: function (t) {
          return (
            sl.prototype.copy.call(this, t),
            (this.distance = t.distance),
            (this.decay = t.decay),
            (this.shadow = t.shadow.clone()),
            this
          );
        },
      })),
      (dl.prototype = Object.assign(Object.create(wi.prototype), {
        constructor: dl,
        isOrthographicCamera: !0,
        copy: function (t, e) {
          return (
            wi.prototype.copy.call(this, t, e),
            (this.left = t.left),
            (this.right = t.right),
            (this.top = t.top),
            (this.bottom = t.bottom),
            (this.near = t.near),
            (this.far = t.far),
            (this.zoom = t.zoom),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            this
          );
        },
        setViewOffset: function (t, e, n, r, i, o) {
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = n),
            (this.view.offsetY = r),
            (this.view.width = i),
            (this.view.height = o),
            this.updateProjectionMatrix();
        },
        clearViewOffset: function () {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function () {
          var t = (this.right - this.left) / (2 * this.zoom),
            e = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            r = (this.top + this.bottom) / 2,
            i = n - t,
            o = n + t,
            a = r + e,
            s = r - e;
          if (null !== this.view && this.view.enabled) {
            var c = this.zoom / (this.view.width / this.view.fullWidth),
              u = this.zoom / (this.view.height / this.view.fullHeight),
              l = (this.right - this.left) / this.view.width,
              h = (this.top - this.bottom) / this.view.height;
            (o =
              (i += l * (this.view.offsetX / c)) + l * (this.view.width / c)),
              (s =
                (a -= h * (this.view.offsetY / u)) -
                h * (this.view.height / u));
          }
          this.projectionMatrix.makeOrthographic(
            i,
            o,
            a,
            s,
            this.near,
            this.far
          ),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix);
        },
        toJSON: function (t) {
          var e = Rn.prototype.toJSON.call(this, t);
          return (
            (e.object.zoom = this.zoom),
            (e.object.left = this.left),
            (e.object.right = this.right),
            (e.object.top = this.top),
            (e.object.bottom = this.bottom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            e
          );
        },
      })),
      (ml.prototype = Object.assign(Object.create(ul.prototype), {
        constructor: ml,
        isDirectionalLightShadow: !0,
        updateMatrices: function (t, e, n) {
          ul.prototype.updateMatrices.call(this, t, e, n);
        },
      })),
      (vl.prototype = Object.assign(Object.create(sl.prototype), {
        constructor: vl,
        isDirectionalLight: !0,
        copy: function (t) {
          return (
            sl.prototype.copy.call(this, t),
            (this.target = t.target.clone()),
            (this.shadow = t.shadow.clone()),
            this
          );
        },
      })),
      (gl.prototype = Object.assign(Object.create(sl.prototype), {
        constructor: gl,
        isAmbientLight: !0,
      })),
      (yl.prototype = Object.assign(Object.create(sl.prototype), {
        constructor: yl,
        isRectAreaLight: !0,
        copy: function (t) {
          return (
            sl.prototype.copy.call(this, t),
            (this.width = t.width),
            (this.height = t.height),
            this
          );
        },
        toJSON: function (t) {
          var e = sl.prototype.toJSON.call(this, t);
          return (
            (e.object.width = this.width), (e.object.height = this.height), e
          );
        },
      })),
      (xl.prototype = Object.assign(Object.create(Pu.prototype), {
        constructor: xl,
        load: function (t, e, n, r) {
          var i = this,
            o = new Cu(i.manager);
          o.setPath(i.path),
            o.load(
              t,
              function (t) {
                e(i.parse(JSON.parse(t)));
              },
              n,
              r
            );
        },
        parse: function (t) {
          var e = this.textures;
          function n(t) {
            return (
              void 0 === e[t] &&
                console.warn("THREE.MaterialLoader: Undefined texture", t),
              e[t]
            );
          }
          var r = new lu[t.type]();
          if (
            (void 0 !== t.uuid && (r.uuid = t.uuid),
            void 0 !== t.name && (r.name = t.name),
            void 0 !== t.color && r.color.setHex(t.color),
            void 0 !== t.roughness && (r.roughness = t.roughness),
            void 0 !== t.metalness && (r.metalness = t.metalness),
            void 0 !== t.sheen && (r.sheen = new vr().setHex(t.sheen)),
            void 0 !== t.emissive && r.emissive.setHex(t.emissive),
            void 0 !== t.specular && r.specular.setHex(t.specular),
            void 0 !== t.shininess && (r.shininess = t.shininess),
            void 0 !== t.clearcoat && (r.clearcoat = t.clearcoat),
            void 0 !== t.clearcoatRoughness &&
              (r.clearcoatRoughness = t.clearcoatRoughness),
            void 0 !== t.vertexColors && (r.vertexColors = t.vertexColors),
            void 0 !== t.fog && (r.fog = t.fog),
            void 0 !== t.flatShading && (r.flatShading = t.flatShading),
            void 0 !== t.blending && (r.blending = t.blending),
            void 0 !== t.combine && (r.combine = t.combine),
            void 0 !== t.side && (r.side = t.side),
            void 0 !== t.opacity && (r.opacity = t.opacity),
            void 0 !== t.transparent && (r.transparent = t.transparent),
            void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest),
            void 0 !== t.depthTest && (r.depthTest = t.depthTest),
            void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite),
            void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite),
            void 0 !== t.stencilWrite && (r.stencilWrite = t.stencilWrite),
            void 0 !== t.stencilWriteMask &&
              (r.stencilWriteMask = t.stencilWriteMask),
            void 0 !== t.stencilFunc && (r.stencilFunc = t.stencilFunc),
            void 0 !== t.stencilRef && (r.stencilRef = t.stencilRef),
            void 0 !== t.stencilFuncMask &&
              (r.stencilFuncMask = t.stencilFuncMask),
            void 0 !== t.stencilFail && (r.stencilFail = t.stencilFail),
            void 0 !== t.stencilZFail && (r.stencilZFail = t.stencilZFail),
            void 0 !== t.stencilZPass && (r.stencilZPass = t.stencilZPass),
            void 0 !== t.wireframe && (r.wireframe = t.wireframe),
            void 0 !== t.wireframeLinewidth &&
              (r.wireframeLinewidth = t.wireframeLinewidth),
            void 0 !== t.wireframeLinecap &&
              (r.wireframeLinecap = t.wireframeLinecap),
            void 0 !== t.wireframeLinejoin &&
              (r.wireframeLinejoin = t.wireframeLinejoin),
            void 0 !== t.rotation && (r.rotation = t.rotation),
            1 !== t.linewidth && (r.linewidth = t.linewidth),
            void 0 !== t.dashSize && (r.dashSize = t.dashSize),
            void 0 !== t.gapSize && (r.gapSize = t.gapSize),
            void 0 !== t.scale && (r.scale = t.scale),
            void 0 !== t.polygonOffset && (r.polygonOffset = t.polygonOffset),
            void 0 !== t.polygonOffsetFactor &&
              (r.polygonOffsetFactor = t.polygonOffsetFactor),
            void 0 !== t.polygonOffsetUnits &&
              (r.polygonOffsetUnits = t.polygonOffsetUnits),
            void 0 !== t.skinning && (r.skinning = t.skinning),
            void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets),
            void 0 !== t.morphNormals && (r.morphNormals = t.morphNormals),
            void 0 !== t.dithering && (r.dithering = t.dithering),
            void 0 !== t.visible && (r.visible = t.visible),
            void 0 !== t.toneMapped && (r.toneMapped = t.toneMapped),
            void 0 !== t.userData && (r.userData = t.userData),
            void 0 !== t.uniforms)
          )
            for (var i in t.uniforms) {
              var o = t.uniforms[i];
              switch (((r.uniforms[i] = {}), o.type)) {
                case "t":
                  r.uniforms[i].value = n(o.value);
                  break;
                case "c":
                  r.uniforms[i].value = new vr().setHex(o.value);
                  break;
                case "v2":
                  r.uniforms[i].value = new ke().fromArray(o.value);
                  break;
                case "v3":
                  r.uniforms[i].value = new Ye().fromArray(o.value);
                  break;
                case "v4":
                  r.uniforms[i].value = new en().fromArray(o.value);
                  break;
                case "m3":
                  r.uniforms[i].value = new Qe().fromArray(o.value);
                case "m4":
                  r.uniforms[i].value = new pn().fromArray(o.value);
                  break;
                default:
                  r.uniforms[i].value = o.value;
              }
            }
          if (
            (void 0 !== t.defines && (r.defines = t.defines),
            void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader),
            void 0 !== t.fragmentShader &&
              (r.fragmentShader = t.fragmentShader),
            void 0 !== t.extensions)
          )
            for (var a in t.extensions) r.extensions[a] = t.extensions[a];
          if (
            (void 0 !== t.shading && (r.flatShading = 1 === t.shading),
            void 0 !== t.size && (r.size = t.size),
            void 0 !== t.sizeAttenuation &&
              (r.sizeAttenuation = t.sizeAttenuation),
            void 0 !== t.map && (r.map = n(t.map)),
            void 0 !== t.matcap && (r.matcap = n(t.matcap)),
            void 0 !== t.alphaMap &&
              ((r.alphaMap = n(t.alphaMap)), (r.transparent = !0)),
            void 0 !== t.bumpMap && (r.bumpMap = n(t.bumpMap)),
            void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale),
            void 0 !== t.normalMap && (r.normalMap = n(t.normalMap)),
            void 0 !== t.normalMapType && (r.normalMapType = t.normalMapType),
            void 0 !== t.normalScale)
          ) {
            var s = t.normalScale;
            !1 === Array.isArray(s) && (s = [s, s]),
              (r.normalScale = new ke().fromArray(s));
          }
          return (
            void 0 !== t.displacementMap &&
              (r.displacementMap = n(t.displacementMap)),
            void 0 !== t.displacementScale &&
              (r.displacementScale = t.displacementScale),
            void 0 !== t.displacementBias &&
              (r.displacementBias = t.displacementBias),
            void 0 !== t.roughnessMap && (r.roughnessMap = n(t.roughnessMap)),
            void 0 !== t.metalnessMap && (r.metalnessMap = n(t.metalnessMap)),
            void 0 !== t.emissiveMap && (r.emissiveMap = n(t.emissiveMap)),
            void 0 !== t.emissiveIntensity &&
              (r.emissiveIntensity = t.emissiveIntensity),
            void 0 !== t.specularMap && (r.specularMap = n(t.specularMap)),
            void 0 !== t.envMap && (r.envMap = n(t.envMap)),
            void 0 !== t.envMapIntensity &&
              (r.envMapIntensity = t.envMapIntensity),
            void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity),
            void 0 !== t.refractionRatio &&
              (r.refractionRatio = t.refractionRatio),
            void 0 !== t.lightMap && (r.lightMap = n(t.lightMap)),
            void 0 !== t.lightMapIntensity &&
              (r.lightMapIntensity = t.lightMapIntensity),
            void 0 !== t.aoMap && (r.aoMap = n(t.aoMap)),
            void 0 !== t.aoMapIntensity &&
              (r.aoMapIntensity = t.aoMapIntensity),
            void 0 !== t.gradientMap && (r.gradientMap = n(t.gradientMap)),
            void 0 !== t.clearcoatNormalMap &&
              (r.clearcoatNormalMap = n(t.clearcoatNormalMap)),
            void 0 !== t.clearcoatNormalScale &&
              (r.clearcoatNormalScale = new ke().fromArray(
                t.clearcoatNormalScale
              )),
            r
          );
        },
        setTextures: function (t) {
          return (this.textures = t), this;
        },
      }));
    var bl = function (t) {
      var e = t.lastIndexOf("/");
      return -1 === e ? "./" : t.substr(0, e + 1);
    };
    function wl() {
      Hr.call(this),
        (this.type = "InstancedBufferGeometry"),
        (this.maxInstancedCount = void 0);
    }
    function _l(t, e, n, r) {
      "number" == typeof n &&
        ((r = n),
        (n = !1),
        console.error(
          "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
        )),
        Sr.call(this, t, e, n),
        (this.meshPerAttribute = r || 1);
    }
    function Ml(t) {
      Pu.call(this, t);
    }
    (wl.prototype = Object.assign(Object.create(Hr.prototype), {
      constructor: wl,
      isInstancedBufferGeometry: !0,
      copy: function (t) {
        return (
          Hr.prototype.copy.call(this, t),
          (this.maxInstancedCount = t.maxInstancedCount),
          this
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      toJSON: function () {
        var t = Hr.prototype.toJSON.call(this);
        return (
          (t.maxInstancedCount = this.maxInstancedCount),
          (t.isInstancedBufferGeometry = !0),
          t
        );
      },
    })),
      (_l.prototype = Object.assign(Object.create(Sr.prototype), {
        constructor: _l,
        isInstancedBufferAttribute: !0,
        copy: function (t) {
          return (
            Sr.prototype.copy.call(this, t),
            (this.meshPerAttribute = t.meshPerAttribute),
            this
          );
        },
        toJSON: function () {
          var t = Sr.prototype.toJSON.call(this);
          return (
            (t.meshPerAttribute = this.meshPerAttribute),
            (t.isInstancedBufferAttribute = !0),
            t
          );
        },
      })),
      (Ml.prototype = Object.assign(Object.create(Pu.prototype), {
        constructor: Ml,
        load: function (t, e, n, r) {
          var i = this,
            o = new Cu(i.manager);
          o.setPath(i.path),
            o.load(
              t,
              function (t) {
                e(i.parse(JSON.parse(t)));
              },
              n,
              r
            );
        },
        parse: function (t) {
          var e = t.isInstancedBufferGeometry ? new wl() : new Hr(),
            n = t.data.index;
          if (void 0 !== n) {
            var r = new Sl[n.type](n.array);
            e.setIndex(new Sr(r, 1));
          }
          var i = t.data.attributes;
          for (var o in i) {
            var a = i[o],
              s =
                ((r = new Sl[a.type](a.array)),
                new (a.isInstancedBufferAttribute ? _l : Sr)(
                  r,
                  a.itemSize,
                  a.normalized
                ));
            void 0 !== a.name && (s.name = a.name), e.addAttribute(o, s);
          }
          var c = t.data.morphAttributes;
          if (c)
            for (var o in c) {
              for (var u = c[o], l = [], h = 0, p = u.length; h < p; h++) {
                (a = u[h]),
                  (s = new Sr(
                    (r = new Sl[a.type](a.array)),
                    a.itemSize,
                    a.normalized
                  ));
                void 0 !== a.name && (s.name = a.name), l.push(s);
              }
              e.morphAttributes[o] = l;
            }
          var f = t.data.groups || t.data.drawcalls || t.data.offsets;
          if (void 0 !== f) {
            h = 0;
            for (var d = f.length; h !== d; ++h) {
              var m = f[h];
              e.addGroup(m.start, m.count, m.materialIndex);
            }
          }
          var v = t.data.boundingSphere;
          if (void 0 !== v) {
            var g = new Ye();
            void 0 !== v.center && g.fromArray(v.center),
              (e.boundingSphere = new Xn(g, v.radius));
          }
          return (
            t.name && (e.name = t.name),
            t.userData && (e.userData = t.userData),
            e
          );
        },
      }));
    var Sl = {
      Int8Array: Int8Array,
      Uint8Array: Uint8Array,
      Uint8ClampedArray:
        "undefined" != typeof Uint8ClampedArray
          ? Uint8ClampedArray
          : Uint8Array,
      Int16Array: Int16Array,
      Uint16Array: Uint16Array,
      Int32Array: Int32Array,
      Uint32Array: Uint32Array,
      Float32Array: Float32Array,
      Float64Array: Float64Array,
    };
    function El(t) {
      Pu.call(this, t);
    }
    El.prototype = Object.assign(Object.create(Pu.prototype), {
      constructor: El,
      load: function (t, e, n, r) {
        var i = this,
          o = "" === this.path ? bl(t) : this.path;
        this.resourcePath = this.resourcePath || o;
        var a = new Cu(i.manager);
        a.setPath(this.path),
          a.load(
            t,
            function (n) {
              var o = null;
              try {
                o = JSON.parse(n);
              } catch (e) {
                return (
                  void 0 !== r && r(e),
                  void console.error(
                    "THREE:ObjectLoader: Can't parse " + t + ".",
                    e.message
                  )
                );
              }
              var a = o.metadata;
              void 0 !== a &&
              void 0 !== a.type &&
              "geometry" !== a.type.toLowerCase()
                ? i.parse(o, e)
                : console.error("THREE.ObjectLoader: Can't load " + t);
            },
            n,
            r
          );
      },
      parse: function (t, e) {
        var n = this.parseShape(t.shapes),
          r = this.parseGeometries(t.geometries, n),
          i = this.parseImages(t.images, function () {
            void 0 !== e && e(s);
          }),
          o = this.parseTextures(t.textures, i),
          a = this.parseMaterials(t.materials, o),
          s = this.parseObject(t.object, r, a);
        return (
          t.animations && (s.animations = this.parseAnimations(t.animations)),
          (void 0 !== t.images && 0 !== t.images.length) ||
            (void 0 !== e && e(s)),
          s
        );
      },
      parseShape: function (t) {
        var e = {};
        if (void 0 !== t)
          for (var n = 0, r = t.length; n < r; n++) {
            var i = new al().fromJSON(t[n]);
            e[i.uuid] = i;
          }
        return e;
      },
      parseGeometries: function (t, e) {
        var n = {};
        if (void 0 !== t)
          for (var r = new Ml(), i = 0, o = t.length; i < o; i++) {
            var a,
              s = t[i];
            switch (s.type) {
              case "PlaneGeometry":
              case "PlaneBufferGeometry":
                a = new $c[s.type](
                  s.width,
                  s.height,
                  s.widthSegments,
                  s.heightSegments
                );
                break;
              case "BoxGeometry":
              case "BoxBufferGeometry":
              case "CubeGeometry":
                a = new $c[s.type](
                  s.width,
                  s.height,
                  s.depth,
                  s.widthSegments,
                  s.heightSegments,
                  s.depthSegments
                );
                break;
              case "CircleGeometry":
              case "CircleBufferGeometry":
                a = new $c[s.type](
                  s.radius,
                  s.segments,
                  s.thetaStart,
                  s.thetaLength
                );
                break;
              case "CylinderGeometry":
              case "CylinderBufferGeometry":
                a = new $c[s.type](
                  s.radiusTop,
                  s.radiusBottom,
                  s.height,
                  s.radialSegments,
                  s.heightSegments,
                  s.openEnded,
                  s.thetaStart,
                  s.thetaLength
                );
                break;
              case "ConeGeometry":
              case "ConeBufferGeometry":
                a = new $c[s.type](
                  s.radius,
                  s.height,
                  s.radialSegments,
                  s.heightSegments,
                  s.openEnded,
                  s.thetaStart,
                  s.thetaLength
                );
                break;
              case "SphereGeometry":
              case "SphereBufferGeometry":
                a = new $c[s.type](
                  s.radius,
                  s.widthSegments,
                  s.heightSegments,
                  s.phiStart,
                  s.phiLength,
                  s.thetaStart,
                  s.thetaLength
                );
                break;
              case "DodecahedronGeometry":
              case "DodecahedronBufferGeometry":
              case "IcosahedronGeometry":
              case "IcosahedronBufferGeometry":
              case "OctahedronGeometry":
              case "OctahedronBufferGeometry":
              case "TetrahedronGeometry":
              case "TetrahedronBufferGeometry":
                a = new $c[s.type](s.radius, s.detail);
                break;
              case "RingGeometry":
              case "RingBufferGeometry":
                a = new $c[s.type](
                  s.innerRadius,
                  s.outerRadius,
                  s.thetaSegments,
                  s.phiSegments,
                  s.thetaStart,
                  s.thetaLength
                );
                break;
              case "TorusGeometry":
              case "TorusBufferGeometry":
                a = new $c[s.type](
                  s.radius,
                  s.tube,
                  s.radialSegments,
                  s.tubularSegments,
                  s.arc
                );
                break;
              case "TorusKnotGeometry":
              case "TorusKnotBufferGeometry":
                a = new $c[s.type](
                  s.radius,
                  s.tube,
                  s.tubularSegments,
                  s.radialSegments,
                  s.p,
                  s.q
                );
                break;
              case "TubeGeometry":
              case "TubeBufferGeometry":
                a = new $c[s.type](
                  new rl[s.path.type]().fromJSON(s.path),
                  s.tubularSegments,
                  s.radius,
                  s.radialSegments,
                  s.closed
                );
                break;
              case "LatheGeometry":
              case "LatheBufferGeometry":
                a = new $c[s.type](
                  s.points,
                  s.segments,
                  s.phiStart,
                  s.phiLength
                );
                break;
              case "PolyhedronGeometry":
              case "PolyhedronBufferGeometry":
                a = new $c[s.type](s.vertices, s.indices, s.radius, s.details);
                break;
              case "ShapeGeometry":
              case "ShapeBufferGeometry":
                for (var c = [], u = 0, l = s.shapes.length; u < l; u++) {
                  var h = e[s.shapes[u]];
                  c.push(h);
                }
                a = new $c[s.type](c, s.curveSegments);
                break;
              case "ExtrudeGeometry":
              case "ExtrudeBufferGeometry":
                for (c = [], u = 0, l = s.shapes.length; u < l; u++) {
                  h = e[s.shapes[u]];
                  c.push(h);
                }
                var p = s.options.extrudePath;
                void 0 !== p &&
                  (s.options.extrudePath = new rl[p.type]().fromJSON(p)),
                  (a = new $c[s.type](c, s.options));
                break;
              case "BufferGeometry":
              case "InstancedBufferGeometry":
                a = r.parse(s);
                break;
              case "Geometry":
                if ("THREE" in window && "LegacyJSONLoader" in THREE)
                  a = new THREE.LegacyJSONLoader().parse(
                    s,
                    this.resourcePath
                  ).geometry;
                else
                  console.error(
                    'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".'
                  );
                break;
              default:
                console.warn(
                  'THREE.ObjectLoader: Unsupported geometry type "' +
                    s.type +
                    '"'
                );
                continue;
            }
            (a.uuid = s.uuid),
              void 0 !== s.name && (a.name = s.name),
              !0 === a.isBufferGeometry &&
                void 0 !== s.userData &&
                (a.userData = s.userData),
              (n[s.uuid] = a);
          }
        return n;
      },
      parseMaterials: function (t, e) {
        var n = {},
          r = {};
        if (void 0 !== t) {
          var i = new xl();
          i.setTextures(e);
          for (var o = 0, a = t.length; o < a; o++) {
            var s = t[o];
            if ("MultiMaterial" === s.type) {
              for (var c = [], u = 0; u < s.materials.length; u++) {
                var l = s.materials[u];
                void 0 === n[l.uuid] && (n[l.uuid] = i.parse(l)),
                  c.push(n[l.uuid]);
              }
              r[s.uuid] = c;
            } else
              void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)),
                (r[s.uuid] = n[s.uuid]);
          }
        }
        return r;
      },
      parseAnimations: function (t) {
        for (var e = [], n = 0; n < t.length; n++) {
          var r = t[n],
            i = Su.parse(r);
          void 0 !== r.uuid && (i.uuid = r.uuid), e.push(i);
        }
        return e;
      },
      parseImages: function (t, e) {
        var n = this,
          r = {};
        function i(t) {
          return (
            n.manager.itemStart(t),
            o.load(
              t,
              function () {
                n.manager.itemEnd(t);
              },
              void 0,
              function () {
                n.manager.itemError(t), n.manager.itemEnd(t);
              }
            )
          );
        }
        if (void 0 !== t && t.length > 0) {
          var o = new Du(new Au(e));
          o.setCrossOrigin(this.crossOrigin);
          for (var a = 0, s = t.length; a < s; a++) {
            var c = t[a],
              u = c.url;
            if (Array.isArray(u)) {
              r[c.uuid] = [];
              for (var l = 0, h = u.length; l < h; l++) {
                var p = u[l],
                  f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p)
                    ? p
                    : n.resourcePath + p;
                r[c.uuid].push(i(f));
              }
            } else {
              f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url)
                ? c.url
                : n.resourcePath + c.url;
              r[c.uuid] = i(f);
            }
          }
        }
        return r;
      },
      parseTextures: function (t, e) {
        function n(t, e) {
          return "number" == typeof t
            ? t
            : (console.warn(
                "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                t
              ),
              e[t]);
        }
        var r = {};
        if (void 0 !== t)
          for (var i = 0, o = t.length; i < o; i++) {
            var a,
              s = t[i];
            void 0 === s.image &&
              console.warn(
                'THREE.ObjectLoader: No "image" specified for',
                s.uuid
              ),
              void 0 === e[s.image] &&
                console.warn("THREE.ObjectLoader: Undefined image", s.image),
              ((a = Array.isArray(e[s.image])
                ? new $i(e[s.image])
                : new tn(e[s.image])).needsUpdate = !0),
              (a.uuid = s.uuid),
              void 0 !== s.name && (a.name = s.name),
              void 0 !== s.mapping && (a.mapping = n(s.mapping, Al)),
              void 0 !== s.offset && a.offset.fromArray(s.offset),
              void 0 !== s.repeat && a.repeat.fromArray(s.repeat),
              void 0 !== s.center && a.center.fromArray(s.center),
              void 0 !== s.rotation && (a.rotation = s.rotation),
              void 0 !== s.wrap &&
                ((a.wrapS = n(s.wrap[0], Ll)), (a.wrapT = n(s.wrap[1], Ll))),
              void 0 !== s.format && (a.format = s.format),
              void 0 !== s.type && (a.type = s.type),
              void 0 !== s.encoding && (a.encoding = s.encoding),
              void 0 !== s.minFilter && (a.minFilter = n(s.minFilter, Pl)),
              void 0 !== s.magFilter && (a.magFilter = n(s.magFilter, Pl)),
              void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy),
              void 0 !== s.flipY && (a.flipY = s.flipY),
              void 0 !== s.premultiplyAlpha &&
                (a.premultiplyAlpha = s.premultiplyAlpha),
              void 0 !== s.unpackAlignment &&
                (a.unpackAlignment = s.unpackAlignment),
              (r[s.uuid] = a);
          }
        return r;
      },
      parseObject: function (t, e, n) {
        var r;
        function i(t) {
          return (
            void 0 === e[t] &&
              console.warn("THREE.ObjectLoader: Undefined geometry", t),
            e[t]
          );
        }
        function o(t) {
          if (void 0 !== t) {
            if (Array.isArray(t)) {
              for (var e = [], r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                void 0 === n[o] &&
                  console.warn("THREE.ObjectLoader: Undefined material", o),
                  e.push(n[o]);
              }
              return e;
            }
            return (
              void 0 === n[t] &&
                console.warn("THREE.ObjectLoader: Undefined material", t),
              n[t]
            );
          }
        }
        switch (t.type) {
          case "Scene":
            (r = new Cn()),
              void 0 !== t.background &&
                Number.isInteger(t.background) &&
                (r.background = new vr(t.background)),
              void 0 !== t.fog &&
                ("Fog" === t.fog.type
                  ? (r.fog = new qa(t.fog.color, t.fog.near, t.fog.far))
                  : "FogExp2" === t.fog.type &&
                    (r.fog = new Wa(t.fog.color, t.fog.density)));
            break;
          case "PerspectiveCamera":
            (r = new _i(t.fov, t.aspect, t.near, t.far)),
              void 0 !== t.focus && (r.focus = t.focus),
              void 0 !== t.zoom && (r.zoom = t.zoom),
              void 0 !== t.filmGauge && (r.filmGauge = t.filmGauge),
              void 0 !== t.filmOffset && (r.filmOffset = t.filmOffset),
              void 0 !== t.view && (r.view = Object.assign({}, t.view));
            break;
          case "OrthographicCamera":
            (r = new dl(t.left, t.right, t.top, t.bottom, t.near, t.far)),
              void 0 !== t.zoom && (r.zoom = t.zoom),
              void 0 !== t.view && (r.view = Object.assign({}, t.view));
            break;
          case "AmbientLight":
            r = new gl(t.color, t.intensity);
            break;
          case "DirectionalLight":
            r = new vl(t.color, t.intensity);
            break;
          case "PointLight":
            r = new fl(t.color, t.intensity, t.distance, t.decay);
            break;
          case "RectAreaLight":
            r = new yl(t.color, t.intensity, t.width, t.height);
            break;
          case "SpotLight":
            r = new hl(
              t.color,
              t.intensity,
              t.distance,
              t.angle,
              t.penumbra,
              t.decay
            );
            break;
          case "HemisphereLight":
            r = new cl(t.color, t.groundColor, t.intensity);
            break;
          case "SkinnedMesh":
            console.warn(
              "THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
            );
          case "Mesh":
            var a = i(t.geometry),
              s = o(t.material);
            (r = a.bones && a.bones.length > 0 ? new fs(a, s) : new si(a, s)),
              void 0 !== t.drawMode && r.setDrawMode(t.drawMode);
            break;
          case "LOD":
            r = new ps();
            break;
          case "Line":
            r = new Es(i(t.geometry), o(t.material), t.mode);
            break;
          case "LineLoop":
            r = new Ps(i(t.geometry), o(t.material));
            break;
          case "LineSegments":
            r = new Ls(i(t.geometry), o(t.material));
            break;
          case "PointCloud":
          case "Points":
            r = new Ds(i(t.geometry), o(t.material));
            break;
          case "Sprite":
            r = new cs(o(t.material));
            break;
          case "Group":
            r = new za();
            break;
          default:
            r = new Rn();
        }
        if (
          ((r.uuid = t.uuid),
          void 0 !== t.name && (r.name = t.name),
          void 0 !== t.matrix
            ? (r.matrix.fromArray(t.matrix),
              void 0 !== t.matrixAutoUpdate &&
                (r.matrixAutoUpdate = t.matrixAutoUpdate),
              r.matrixAutoUpdate &&
                r.matrix.decompose(r.position, r.quaternion, r.scale))
            : (void 0 !== t.position && r.position.fromArray(t.position),
              void 0 !== t.rotation && r.rotation.fromArray(t.rotation),
              void 0 !== t.quaternion && r.quaternion.fromArray(t.quaternion),
              void 0 !== t.scale && r.scale.fromArray(t.scale)),
          void 0 !== t.castShadow && (r.castShadow = t.castShadow),
          void 0 !== t.receiveShadow && (r.receiveShadow = t.receiveShadow),
          t.shadow &&
            (void 0 !== t.shadow.bias && (r.shadow.bias = t.shadow.bias),
            void 0 !== t.shadow.radius && (r.shadow.radius = t.shadow.radius),
            void 0 !== t.shadow.mapSize &&
              r.shadow.mapSize.fromArray(t.shadow.mapSize),
            void 0 !== t.shadow.camera &&
              (r.shadow.camera = this.parseObject(t.shadow.camera))),
          void 0 !== t.visible && (r.visible = t.visible),
          void 0 !== t.frustumCulled && (r.frustumCulled = t.frustumCulled),
          void 0 !== t.renderOrder && (r.renderOrder = t.renderOrder),
          void 0 !== t.userData && (r.userData = t.userData),
          void 0 !== t.layers && (r.layers.mask = t.layers),
          void 0 !== t.children)
        )
          for (var c = t.children, u = 0; u < c.length; u++)
            r.add(this.parseObject(c[u], e, n));
        if ("LOD" === t.type)
          for (var l = t.levels, h = 0; h < l.length; h++) {
            var p = l[h],
              f = r.getObjectByProperty("uuid", p.object);
            void 0 !== f && r.addLevel(f, p.distance);
          }
        return r;
      },
    });
    var Tl,
      Al = {
        UVMapping: 300,
        CubeReflectionMapping: vt,
        CubeRefractionMapping: gt,
        EquirectangularReflectionMapping: yt,
        EquirectangularRefractionMapping: xt,
        SphericalReflectionMapping: bt,
        CubeUVReflectionMapping: wt,
        CubeUVRefractionMapping: _t,
      },
      Ll = {
        RepeatWrapping: Mt,
        ClampToEdgeWrapping: St,
        MirroredRepeatWrapping: Et,
      },
      Pl = {
        NearestFilter: Tt,
        NearestMipmapNearestFilter: At,
        NearestMipmapLinearFilter: Lt,
        LinearFilter: Pt,
        LinearMipmapNearestFilter: Rt,
        LinearMipmapLinearFilter: Ct,
      };
    function Rl(t) {
      "undefined" == typeof createImageBitmap &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
        "undefined" == typeof fetch &&
          console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        Pu.call(this, t),
        (this.options = void 0);
    }
    function Cl() {
      (this.type = "ShapePath"),
        (this.color = new vr()),
        (this.subPaths = []),
        (this.currentPath = null);
    }
    function Ol(t) {
      (this.type = "Font"), (this.data = t);
    }
    function Il(t, e, n, r, i) {
      var o = i.glyphs[t] || i.glyphs["?"];
      if (o) {
        var a,
          s,
          c,
          u,
          l,
          h,
          p,
          f,
          d = new Cl();
        if (o.o)
          for (
            var m = o._cachedOutline || (o._cachedOutline = o.o.split(" ")),
              v = 0,
              g = m.length;
            v < g;

          ) {
            switch (m[v++]) {
              case "m":
                (a = m[v++] * e + n), (s = m[v++] * e + r), d.moveTo(a, s);
                break;
              case "l":
                (a = m[v++] * e + n), (s = m[v++] * e + r), d.lineTo(a, s);
                break;
              case "q":
                (c = m[v++] * e + n),
                  (u = m[v++] * e + r),
                  (l = m[v++] * e + n),
                  (h = m[v++] * e + r),
                  d.quadraticCurveTo(l, h, c, u);
                break;
              case "b":
                (c = m[v++] * e + n),
                  (u = m[v++] * e + r),
                  (l = m[v++] * e + n),
                  (h = m[v++] * e + r),
                  (p = m[v++] * e + n),
                  (f = m[v++] * e + r),
                  d.bezierCurveTo(l, h, p, f, c, u);
            }
          }
        return { offsetX: o.ha * e, path: d };
      }
      console.error(
        'THREE.Font: character "' +
          t +
          '" does not exists in font family ' +
          i.familyName +
          "."
      );
    }
    function Nl(t) {
      Pu.call(this, t);
    }
    (Rl.prototype = Object.assign(Object.create(Pu.prototype), {
      constructor: Rl,
      setOptions: function (t) {
        return (this.options = t), this;
      },
      load: function (t, e, n, r) {
        void 0 === t && (t = ""),
          void 0 !== this.path && (t = this.path + t),
          (t = this.manager.resolveURL(t));
        var i = this,
          o = Tu.get(t);
        if (void 0 !== o)
          return (
            i.manager.itemStart(t),
            setTimeout(function () {
              e && e(o), i.manager.itemEnd(t);
            }, 0),
            o
          );
        fetch(t)
          .then(function (t) {
            return t.blob();
          })
          .then(function (t) {
            return void 0 === i.options
              ? createImageBitmap(t)
              : createImageBitmap(t, i.options);
          })
          .then(function (n) {
            Tu.add(t, n), e && e(n), i.manager.itemEnd(t);
          })
          .catch(function (e) {
            r && r(e), i.manager.itemError(t), i.manager.itemEnd(t);
          }),
          i.manager.itemStart(t);
      },
    })),
      Object.assign(Cl.prototype, {
        moveTo: function (t, e) {
          (this.currentPath = new ol()),
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(t, e);
        },
        lineTo: function (t, e) {
          this.currentPath.lineTo(t, e);
        },
        quadraticCurveTo: function (t, e, n, r) {
          this.currentPath.quadraticCurveTo(t, e, n, r);
        },
        bezierCurveTo: function (t, e, n, r, i, o) {
          this.currentPath.bezierCurveTo(t, e, n, r, i, o);
        },
        splineThru: function (t) {
          this.currentPath.splineThru(t);
        },
        toShapes: function (t, e) {
          function n(t) {
            for (var e = [], n = 0, r = t.length; n < r; n++) {
              var i = t[n],
                o = new al();
              (o.curves = i.curves), e.push(o);
            }
            return e;
          }
          function r(t, e) {
            for (var n = e.length, r = !1, i = n - 1, o = 0; o < n; i = o++) {
              var a = e[i],
                s = e[o],
                c = s.x - a.x,
                u = s.y - a.y;
              if (Math.abs(u) > Number.EPSILON) {
                if (
                  (u < 0 && ((a = e[o]), (c = -c), (s = e[i]), (u = -u)),
                  t.y < a.y || t.y > s.y)
                )
                  continue;
                if (t.y === a.y) {
                  if (t.x === a.x) return !0;
                } else {
                  var l = u * (t.x - a.x) - c * (t.y - a.y);
                  if (0 === l) return !0;
                  if (l < 0) continue;
                  r = !r;
                }
              } else {
                if (t.y !== a.y) continue;
                if ((s.x <= t.x && t.x <= a.x) || (a.x <= t.x && t.x <= s.x))
                  return !0;
              }
            }
            return r;
          }
          var i = Lc.isClockWise,
            o = this.subPaths;
          if (0 === o.length) return [];
          if (!0 === e) return n(o);
          var a,
            s,
            c,
            u = [];
          if (1 === o.length)
            return (s = o[0]), ((c = new al()).curves = s.curves), u.push(c), u;
          var l = !i(o[0].getPoints());
          l = t ? !l : l;
          var h,
            p,
            f = [],
            d = [],
            m = [],
            v = 0;
          (d[v] = void 0), (m[v] = []);
          for (var g = 0, y = o.length; g < y; g++)
            (a = i((h = (s = o[g]).getPoints()))),
              (a = t ? !a : a)
                ? (!l && d[v] && v++,
                  (d[v] = { s: new al(), p: h }),
                  (d[v].s.curves = s.curves),
                  l && v++,
                  (m[v] = []))
                : m[v].push({ h: s, p: h[0] });
          if (!d[0]) return n(o);
          if (d.length > 1) {
            for (var x = !1, b = [], w = 0, _ = d.length; w < _; w++) f[w] = [];
            for (w = 0, _ = d.length; w < _; w++)
              for (var M = m[w], S = 0; S < M.length; S++) {
                for (var E = M[S], T = !0, A = 0; A < d.length; A++)
                  r(E.p, d[A].p) &&
                    (w !== A && b.push({ froms: w, tos: A, hole: S }),
                    T ? ((T = !1), f[A].push(E)) : (x = !0));
                T && f[w].push(E);
              }
            b.length > 0 && (x || (m = f));
          }
          g = 0;
          for (var L = d.length; g < L; g++) {
            (c = d[g].s), u.push(c);
            for (var P = 0, R = (p = m[g]).length; P < R; P++)
              c.holes.push(p[P].h);
          }
          return u;
        },
      }),
      Object.assign(Ol.prototype, {
        isFont: !0,
        generateShapes: function (t, e) {
          void 0 === e && (e = 100);
          for (
            var n = [],
              r = (function (t, e, n) {
                for (
                  var r = Array.from ? Array.from(t) : String(t).split(""),
                    i = e / n.resolution,
                    o =
                      (n.boundingBox.yMax -
                        n.boundingBox.yMin +
                        n.underlineThickness) *
                      i,
                    a = [],
                    s = 0,
                    c = 0,
                    u = 0;
                  u < r.length;
                  u++
                ) {
                  var l = r[u];
                  if ("\n" === l) (s = 0), (c -= o);
                  else {
                    var h = Il(l, i, s, c, n);
                    (s += h.offsetX), a.push(h.path);
                  }
                }
                return a;
              })(t, e, this.data),
              i = 0,
              o = r.length;
            i < o;
            i++
          )
            Array.prototype.push.apply(n, r[i].toShapes());
          return n;
        },
      }),
      (Nl.prototype = Object.assign(Object.create(Pu.prototype), {
        constructor: Nl,
        load: function (t, e, n, r) {
          var i = this,
            o = new Cu(this.manager);
          o.setPath(this.path),
            o.load(
              t,
              function (t) {
                var n;
                try {
                  n = JSON.parse(t);
                } catch (e) {
                  console.warn(
                    "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
                  ),
                    (n = JSON.parse(t.substring(65, t.length - 2)));
                }
                var r = i.parse(n);
                e && e(r);
              },
              n,
              r
            );
        },
        parse: function (t) {
          return new Ol(t);
        },
      }));
    var Dl = {
      getContext: function () {
        return (
          void 0 === Tl &&
            (Tl = new (window.AudioContext || window.webkitAudioContext)()),
          Tl
        );
      },
      setContext: function (t) {
        Tl = t;
      },
    };
    function zl(t) {
      Pu.call(this, t);
    }
    function Fl() {
      this.coefficients = [];
      for (var t = 0; t < 9; t++) this.coefficients.push(new Ye());
    }
    function Ul(t, e) {
      sl.call(this, void 0, e), (this.sh = void 0 !== t ? t : new Fl());
    }
    function Bl(t, e, n) {
      Ul.call(this, void 0, n);
      var r = new vr().set(t),
        i = new vr().set(e),
        o = new Ye(r.r, r.g, r.b),
        a = new Ye(i.r, i.g, i.b),
        s = Math.sqrt(Math.PI),
        c = s * Math.sqrt(0.75);
      this.sh.coefficients[0].copy(o).add(a).multiplyScalar(s),
        this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c);
    }
    function Gl(t, e) {
      Ul.call(this, void 0, e);
      var n = new vr().set(t);
      this.sh.coefficients[0]
        .set(n.r, n.g, n.b)
        .multiplyScalar(2 * Math.sqrt(Math.PI));
    }
    (zl.prototype = Object.assign(Object.create(Pu.prototype), {
      constructor: zl,
      load: function (t, e, n, r) {
        var i = new Cu(this.manager);
        i.setResponseType("arraybuffer"),
          i.setPath(this.path),
          i.load(
            t,
            function (t) {
              var n = t.slice(0);
              Dl.getContext().decodeAudioData(n, function (t) {
                e(t);
              });
            },
            n,
            r
          );
      },
    })),
      Object.assign(Fl.prototype, {
        isSphericalHarmonics3: !0,
        set: function (t) {
          for (var e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
          return this;
        },
        zero: function () {
          for (var t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
          return this;
        },
        getAt: function (t, e) {
          var n = t.x,
            r = t.y,
            i = t.z,
            o = this.coefficients;
          return (
            e.copy(o[0]).multiplyScalar(0.282095),
            e.addScale(o[1], 0.488603 * r),
            e.addScale(o[2], 0.488603 * i),
            e.addScale(o[3], 0.488603 * n),
            e.addScale(o[4], n * r * 1.092548),
            e.addScale(o[5], r * i * 1.092548),
            e.addScale(o[6], 0.315392 * (3 * i * i - 1)),
            e.addScale(o[7], n * i * 1.092548),
            e.addScale(o[8], 0.546274 * (n * n - r * r)),
            e
          );
        },
        getIrradianceAt: function (t, e) {
          var n = t.x,
            r = t.y,
            i = t.z,
            o = this.coefficients;
          return (
            e.copy(o[0]).multiplyScalar(0.886227),
            e.addScale(o[1], 1.023328 * r),
            e.addScale(o[2], 1.023328 * i),
            e.addScale(o[3], 1.023328 * n),
            e.addScale(o[4], 0.858086 * n * r),
            e.addScale(o[5], 0.858086 * r * i),
            e.addScale(o[6], 0.743125 * i * i - 0.247708),
            e.addScale(o[7], 0.858086 * n * i),
            e.addScale(o[8], 0.429043 * (n * n - r * r)),
            e
          );
        },
        add: function (t) {
          for (var e = 0; e < 9; e++)
            this.coefficients[e].add(t.coefficients[e]);
          return this;
        },
        scale: function (t) {
          for (var e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
          return this;
        },
        lerp: function (t, e) {
          for (var n = 0; n < 9; n++)
            this.coefficients[n].lerp(t.coefficients[n], e);
          return this;
        },
        equals: function (t) {
          for (var e = 0; e < 9; e++)
            if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
          return !0;
        },
        copy: function (t) {
          return this.set(t.coefficients);
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        fromArray: function (t, e) {
          void 0 === e && (e = 0);
          for (var n = this.coefficients, r = 0; r < 9; r++)
            n[r].fromArray(t, e + 3 * r);
          return this;
        },
        toArray: function (t, e) {
          void 0 === t && (t = []), void 0 === e && (e = 0);
          for (var n = this.coefficients, r = 0; r < 9; r++)
            n[r].toArray(t, e + 3 * r);
          return t;
        },
      }),
      Object.assign(Fl, {
        getBasisAt: function (t, e) {
          var n = t.x,
            r = t.y,
            i = t.z;
          (e[0] = 0.282095),
            (e[1] = 0.488603 * r),
            (e[2] = 0.488603 * i),
            (e[3] = 0.488603 * n),
            (e[4] = 1.092548 * n * r),
            (e[5] = 1.092548 * r * i),
            (e[6] = 0.315392 * (3 * i * i - 1)),
            (e[7] = 1.092548 * n * i),
            (e[8] = 0.546274 * (n * n - r * r));
        },
      }),
      (Ul.prototype = Object.assign(Object.create(sl.prototype), {
        constructor: Ul,
        isLightProbe: !0,
        copy: function (t) {
          return (
            sl.prototype.copy.call(this, t),
            this.sh.copy(t.sh),
            (this.intensity = t.intensity),
            this
          );
        },
        toJSON: function (t) {
          return sl.prototype.toJSON.call(this, t);
        },
      })),
      (Bl.prototype = Object.assign(Object.create(Ul.prototype), {
        constructor: Bl,
        isHemisphereLightProbe: !0,
        copy: function (t) {
          return Ul.prototype.copy.call(this, t), this;
        },
        toJSON: function (t) {
          return Ul.prototype.toJSON.call(this, t);
        },
      })),
      (Gl.prototype = Object.assign(Object.create(Ul.prototype), {
        constructor: Gl,
        isAmbientLightProbe: !0,
        copy: function (t) {
          return Ul.prototype.copy.call(this, t), this;
        },
        toJSON: function (t) {
          return Ul.prototype.toJSON.call(this, t);
        },
      }));
    var jl = new pn(),
      Vl = new pn();
    function Hl(t) {
      (this.autoStart = void 0 === t || t),
        (this.startTime = 0),
        (this.oldTime = 0),
        (this.elapsedTime = 0),
        (this.running = !1);
    }
    Object.assign(
      function () {
        (this.type = "StereoCamera"),
          (this.aspect = 1),
          (this.eyeSep = 0.064),
          (this.cameraL = new _i()),
          this.cameraL.layers.enable(1),
          (this.cameraL.matrixAutoUpdate = !1),
          (this.cameraR = new _i()),
          this.cameraR.layers.enable(2),
          (this.cameraR.matrixAutoUpdate = !1),
          (this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null,
          });
      }.prototype,
      {
        update: function (t) {
          var e = this._cache;
          if (
            e.focus !== t.focus ||
            e.fov !== t.fov ||
            e.aspect !== t.aspect * this.aspect ||
            e.near !== t.near ||
            e.far !== t.far ||
            e.zoom !== t.zoom ||
            e.eyeSep !== this.eyeSep
          ) {
            (e.focus = t.focus),
              (e.fov = t.fov),
              (e.aspect = t.aspect * this.aspect),
              (e.near = t.near),
              (e.far = t.far),
              (e.zoom = t.zoom),
              (e.eyeSep = this.eyeSep);
            var n,
              r,
              i = t.projectionMatrix.clone(),
              o = e.eyeSep / 2,
              a = (o * e.near) / e.focus,
              s = (e.near * Math.tan(He.DEG2RAD * e.fov * 0.5)) / e.zoom;
            (Vl.elements[12] = -o),
              (jl.elements[12] = o),
              (n = -s * e.aspect + a),
              (r = s * e.aspect + a),
              (i.elements[0] = (2 * e.near) / (r - n)),
              (i.elements[8] = (r + n) / (r - n)),
              this.cameraL.projectionMatrix.copy(i),
              (n = -s * e.aspect - a),
              (r = s * e.aspect - a),
              (i.elements[0] = (2 * e.near) / (r - n)),
              (i.elements[8] = (r + n) / (r - n)),
              this.cameraR.projectionMatrix.copy(i);
          }
          this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Vl),
            this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(jl);
        },
      }
    ),
      Object.assign(Hl.prototype, {
        start: function () {
          (this.startTime = (
            "undefined" == typeof performance ? Date : performance
          ).now()),
            (this.oldTime = this.startTime),
            (this.elapsedTime = 0),
            (this.running = !0);
        },
        stop: function () {
          this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
        },
        getElapsedTime: function () {
          return this.getDelta(), this.elapsedTime;
        },
        getDelta: function () {
          var t = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            var e = (
              "undefined" == typeof performance ? Date : performance
            ).now();
            (t = (e - this.oldTime) / 1e3),
              (this.oldTime = e),
              (this.elapsedTime += t);
          }
          return t;
        },
      });
    var kl = new Ye(),
      Wl = new We(),
      ql = new Ye(),
      Xl = new Ye();
    function Yl() {
      Rn.call(this),
        (this.type = "AudioListener"),
        (this.context = Dl.getContext()),
        (this.gain = this.context.createGain()),
        this.gain.connect(this.context.destination),
        (this.filter = null),
        (this.timeDelta = 0),
        (this._clock = new Hl());
    }
    function Jl(t) {
      Rn.call(this),
        (this.type = "Audio"),
        (this.listener = t),
        (this.context = t.context),
        (this.gain = this.context.createGain()),
        this.gain.connect(t.getInput()),
        (this.autoplay = !1),
        (this.buffer = null),
        (this.detune = 0),
        (this.loop = !1),
        (this.startTime = 0),
        (this.offset = 0),
        (this.duration = void 0),
        (this.playbackRate = 1),
        (this.isPlaying = !1),
        (this.hasPlaybackControl = !0),
        (this.sourceType = "empty"),
        (this.filters = []);
    }
    (Yl.prototype = Object.assign(Object.create(Rn.prototype), {
      constructor: Yl,
      getInput: function () {
        return this.gain;
      },
      removeFilter: function () {
        return (
          null !== this.filter &&
            (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            (this.filter = null)),
          this
        );
      },
      getFilter: function () {
        return this.filter;
      },
      setFilter: function (t) {
        return (
          null !== this.filter
            ? (this.gain.disconnect(this.filter),
              this.filter.disconnect(this.context.destination))
            : this.gain.disconnect(this.context.destination),
          (this.filter = t),
          this.gain.connect(this.filter),
          this.filter.connect(this.context.destination),
          this
        );
      },
      getMasterVolume: function () {
        return this.gain.gain.value;
      },
      setMasterVolume: function (t) {
        return (
          this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
          this
        );
      },
      updateMatrixWorld: function (t) {
        Rn.prototype.updateMatrixWorld.call(this, t);
        var e = this.context.listener,
          n = this.up;
        if (
          ((this.timeDelta = this._clock.getDelta()),
          this.matrixWorld.decompose(kl, Wl, ql),
          Xl.set(0, 0, -1).applyQuaternion(Wl),
          e.positionX)
        ) {
          var r = this.context.currentTime + this.timeDelta;
          e.positionX.linearRampToValueAtTime(kl.x, r),
            e.positionY.linearRampToValueAtTime(kl.y, r),
            e.positionZ.linearRampToValueAtTime(kl.z, r),
            e.forwardX.linearRampToValueAtTime(Xl.x, r),
            e.forwardY.linearRampToValueAtTime(Xl.y, r),
            e.forwardZ.linearRampToValueAtTime(Xl.z, r),
            e.upX.linearRampToValueAtTime(n.x, r),
            e.upY.linearRampToValueAtTime(n.y, r),
            e.upZ.linearRampToValueAtTime(n.z, r);
        } else
          e.setPosition(kl.x, kl.y, kl.z),
            e.setOrientation(Xl.x, Xl.y, Xl.z, n.x, n.y, n.z);
      },
    })),
      (Jl.prototype = Object.assign(Object.create(Rn.prototype), {
        constructor: Jl,
        getOutput: function () {
          return this.gain;
        },
        setNodeSource: function (t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "audioNode"),
            (this.source = t),
            this.connect(),
            this
          );
        },
        setMediaElementSource: function (t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaNode"),
            (this.source = this.context.createMediaElementSource(t)),
            this.connect(),
            this
          );
        },
        setMediaStreamSource: function (t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "mediaStreamNode"),
            (this.source = this.context.createMediaStreamSource(t)),
            this.connect(),
            this
          );
        },
        setBuffer: function (t) {
          return (
            (this.buffer = t),
            (this.sourceType = "buffer"),
            this.autoplay && this.play(),
            this
          );
        },
        play: function () {
          if (!0 !== this.isPlaying) {
            if (!1 !== this.hasPlaybackControl) {
              var t = this.context.createBufferSource();
              return (
                (t.buffer = this.buffer),
                (t.loop = this.loop),
                (t.onended = this.onEnded.bind(this)),
                (this.startTime = this.context.currentTime),
                t.start(this.startTime, this.offset, this.duration),
                (this.isPlaying = !0),
                (this.source = t),
                this.setDetune(this.detune),
                this.setPlaybackRate(this.playbackRate),
                this.connect()
              );
            }
            console.warn("THREE.Audio: this Audio has no playback control.");
          } else console.warn("THREE.Audio: Audio is already playing.");
        },
        pause: function () {
          if (!1 !== this.hasPlaybackControl)
            return (
              !0 === this.isPlaying &&
                (this.source.stop(),
                (this.source.onended = null),
                (this.offset +=
                  (this.context.currentTime - this.startTime) *
                  this.playbackRate),
                (this.isPlaying = !1)),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        },
        stop: function () {
          if (!1 !== this.hasPlaybackControl)
            return (
              this.source.stop(),
              (this.source.onended = null),
              (this.offset = 0),
              (this.isPlaying = !1),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        },
        connect: function () {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (var t = 1, e = this.filters.length; t < e; t++)
              this.filters[t - 1].connect(this.filters[t]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return this;
        },
        disconnect: function () {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (var t = 1, e = this.filters.length; t < e; t++)
              this.filters[t - 1].disconnect(this.filters[t]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else this.source.disconnect(this.getOutput());
          return this;
        },
        getFilters: function () {
          return this.filters;
        },
        setFilters: function (t) {
          return (
            t || (t = []),
            !0 === this.isPlaying
              ? (this.disconnect(), (this.filters = t), this.connect())
              : (this.filters = t),
            this
          );
        },
        setDetune: function (t) {
          if (((this.detune = t), void 0 !== this.source.detune))
            return (
              !0 === this.isPlaying &&
                this.source.detune.setTargetAtTime(
                  this.detune,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
        },
        getDetune: function () {
          return this.detune;
        },
        getFilter: function () {
          return this.getFilters()[0];
        },
        setFilter: function (t) {
          return this.setFilters(t ? [t] : []);
        },
        setPlaybackRate: function (t) {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this.playbackRate = t),
              !0 === this.isPlaying &&
                this.source.playbackRate.setTargetAtTime(
                  this.playbackRate,
                  this.context.currentTime,
                  0.01
                ),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        },
        getPlaybackRate: function () {
          return this.playbackRate;
        },
        onEnded: function () {
          this.isPlaying = !1;
        },
        getLoop: function () {
          return !1 === this.hasPlaybackControl
            ? (console.warn("THREE.Audio: this Audio has no playback control."),
              !1)
            : this.loop;
        },
        setLoop: function (t) {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this.loop = t),
              !0 === this.isPlaying && (this.source.loop = this.loop),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        },
        getVolume: function () {
          return this.gain.gain.value;
        },
        setVolume: function (t) {
          return (
            this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
            this
          );
        },
      }));
    var Zl = new Ye(),
      Ql = new We(),
      Kl = new Ye(),
      $l = new Ye();
    function th(t) {
      Jl.call(this, t),
        (this.panner = this.context.createPanner()),
        (this.panner.panningModel = "HRTF"),
        this.panner.connect(this.gain);
    }
    function eh(t, e) {
      (this.analyser = t.context.createAnalyser()),
        (this.analyser.fftSize = void 0 !== e ? e : 2048),
        (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
        t.getOutput().connect(this.analyser);
    }
    function nh(t, e, n) {
      (this.binding = t), (this.valueSize = n);
      var r,
        i = Float64Array;
      switch (e) {
        case "quaternion":
          r = this._slerp;
          break;
        case "string":
        case "bool":
          (i = Array), (r = this._select);
          break;
        default:
          r = this._lerp;
      }
      (this.buffer = new i(4 * n)),
        (this._mixBufferRegion = r),
        (this.cumulativeWeight = 0),
        (this.useCount = 0),
        (this.referenceCount = 0);
    }
    (th.prototype = Object.assign(Object.create(Jl.prototype), {
      constructor: th,
      getOutput: function () {
        return this.panner;
      },
      getRefDistance: function () {
        return this.panner.refDistance;
      },
      setRefDistance: function (t) {
        return (this.panner.refDistance = t), this;
      },
      getRolloffFactor: function () {
        return this.panner.rolloffFactor;
      },
      setRolloffFactor: function (t) {
        return (this.panner.rolloffFactor = t), this;
      },
      getDistanceModel: function () {
        return this.panner.distanceModel;
      },
      setDistanceModel: function (t) {
        return (this.panner.distanceModel = t), this;
      },
      getMaxDistance: function () {
        return this.panner.maxDistance;
      },
      setMaxDistance: function (t) {
        return (this.panner.maxDistance = t), this;
      },
      setDirectionalCone: function (t, e, n) {
        return (
          (this.panner.coneInnerAngle = t),
          (this.panner.coneOuterAngle = e),
          (this.panner.coneOuterGain = n),
          this
        );
      },
      updateMatrixWorld: function (t) {
        if (
          (Rn.prototype.updateMatrixWorld.call(this, t),
          !0 !== this.hasPlaybackControl || !1 !== this.isPlaying)
        ) {
          this.matrixWorld.decompose(Zl, Ql, Kl),
            $l.set(0, 0, 1).applyQuaternion(Ql);
          var e = this.panner;
          if (e.positionX) {
            var n = this.context.currentTime + this.listener.timeDelta;
            e.positionX.linearRampToValueAtTime(Zl.x, n),
              e.positionY.linearRampToValueAtTime(Zl.y, n),
              e.positionZ.linearRampToValueAtTime(Zl.z, n),
              e.orientationX.linearRampToValueAtTime($l.x, n),
              e.orientationY.linearRampToValueAtTime($l.y, n),
              e.orientationZ.linearRampToValueAtTime($l.z, n);
          } else
            e.setPosition(Zl.x, Zl.y, Zl.z), e.setOrientation($l.x, $l.y, $l.z);
        }
      },
    })),
      Object.assign(eh.prototype, {
        getFrequencyData: function () {
          return this.analyser.getByteFrequencyData(this.data), this.data;
        },
        getAverageFrequency: function () {
          for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++)
            t += e[n];
          return t / e.length;
        },
      }),
      Object.assign(nh.prototype, {
        accumulate: function (t, e) {
          var n = this.buffer,
            r = this.valueSize,
            i = t * r + r,
            o = this.cumulativeWeight;
          if (0 === o) {
            for (var a = 0; a !== r; ++a) n[i + a] = n[a];
            o = e;
          } else {
            var s = e / (o += e);
            this._mixBufferRegion(n, i, 0, s, r);
          }
          this.cumulativeWeight = o;
        },
        apply: function (t) {
          var e = this.valueSize,
            n = this.buffer,
            r = t * e + e,
            i = this.cumulativeWeight,
            o = this.binding;
          if (((this.cumulativeWeight = 0), i < 1)) {
            var a = 3 * e;
            this._mixBufferRegion(n, r, a, 1 - i, e);
          }
          for (var s = e, c = e + e; s !== c; ++s)
            if (n[s] !== n[s + e]) {
              o.setValue(n, r);
              break;
            }
        },
        saveOriginalState: function () {
          var t = this.binding,
            e = this.buffer,
            n = this.valueSize,
            r = 3 * n;
          t.getValue(e, r);
          for (var i = n, o = r; i !== o; ++i) e[i] = e[r + (i % n)];
          this.cumulativeWeight = 0;
        },
        restoreOriginalState: function () {
          var t = 3 * this.valueSize;
          this.binding.setValue(this.buffer, t);
        },
        _select: function (t, e, n, r, i) {
          if (r >= 0.5) for (var o = 0; o !== i; ++o) t[e + o] = t[n + o];
        },
        _slerp: function (t, e, n, r) {
          We.slerpFlat(t, e, t, e, t, n, r);
        },
        _lerp: function (t, e, n, r, i) {
          for (var o = 1 - r, a = 0; a !== i; ++a) {
            var s = e + a;
            t[s] = t[s] * o + t[n + a] * r;
          }
        },
      });
    var rh = new RegExp("[\\[\\]\\.:\\/]", "g"),
      ih = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
      oh = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      ah = /(WCOD+)?/.source.replace("WCOD", ih),
      sh = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      ch = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      uh = new RegExp("^" + oh + ah + sh + ch + "$"),
      lh = ["material", "materials", "bones"];
    function hh(t, e, n) {
      var r = n || ph.parseTrackName(e);
      (this._targetGroup = t), (this._bindings = t.subscribe_(e, r));
    }
    function ph(t, e, n) {
      (this.path = e),
        (this.parsedPath = n || ph.parseTrackName(e)),
        (this.node = ph.findNode(t, this.parsedPath.nodeName) || t),
        (this.rootNode = t);
    }
    function fh(t, e, n) {
      (this._mixer = t), (this._clip = e), (this._localRoot = n || null);
      for (
        var r = e.tracks,
          i = r.length,
          o = new Array(i),
          a = { endingStart: _e, endingEnd: _e },
          s = 0;
        s !== i;
        ++s
      ) {
        var c = r[s].createInterpolant(null);
        (o[s] = c), (c.settings = a);
      }
      (this._interpolantSettings = a),
        (this._interpolants = o),
        (this._propertyBindings = new Array(i)),
        (this._cacheIndex = null),
        (this._byClipCacheIndex = null),
        (this._timeScaleInterpolant = null),
        (this._weightInterpolant = null),
        (this.loop = we),
        (this._loopCount = -1),
        (this._startTime = null),
        (this.time = 0),
        (this.timeScale = 1),
        (this._effectiveTimeScale = 1),
        (this.weight = 1),
        (this._effectiveWeight = 1),
        (this.repetitions = 1 / 0),
        (this.paused = !1),
        (this.enabled = !0),
        (this.clampWhenFinished = !1),
        (this.zeroSlopeAtStart = !0),
        (this.zeroSlopeAtEnd = !0);
    }
    function dh(t) {
      (this._root = t),
        this._initMemoryManager(),
        (this._accuIndex = 0),
        (this.time = 0),
        (this.timeScale = 1);
    }
    function mh(t) {
      "string" == typeof t &&
        (console.warn("THREE.Uniform: Type parameter is no longer needed."),
        (t = arguments[1])),
        (this.value = t);
    }
    function vh(t, e, n) {
      Xa.call(this, t, e), (this.meshPerAttribute = n || 1);
    }
    function gh(t, e) {
      return t.distance - e.distance;
    }
    function yh(t, e, n, r) {
      if (!1 !== t.visible && (t.raycast(e, n), !0 === r))
        for (var i = t.children, o = 0, a = i.length; o < a; o++)
          yh(i[o], e, n, !0);
    }
    Object.assign(hh.prototype, {
      getValue: function (t, e) {
        this.bind();
        var n = this._targetGroup.nCachedObjects_,
          r = this._bindings[n];
        void 0 !== r && r.getValue(t, e);
      },
      setValue: function (t, e) {
        for (
          var n = this._bindings,
            r = this._targetGroup.nCachedObjects_,
            i = n.length;
          r !== i;
          ++r
        )
          n[r].setValue(t, e);
      },
      bind: function () {
        for (
          var t = this._bindings,
            e = this._targetGroup.nCachedObjects_,
            n = t.length;
          e !== n;
          ++e
        )
          t[e].bind();
      },
      unbind: function () {
        for (
          var t = this._bindings,
            e = this._targetGroup.nCachedObjects_,
            n = t.length;
          e !== n;
          ++e
        )
          t[e].unbind();
      },
    }),
      Object.assign(ph, {
        Composite: hh,
        create: function (t, e, n) {
          return t && t.isAnimationObjectGroup
            ? new ph.Composite(t, e, n)
            : new ph(t, e, n);
        },
        sanitizeNodeName: function (t) {
          return t.replace(/\s/g, "_").replace(rh, "");
        },
        parseTrackName: function (t) {
          var e = uh.exec(t);
          if (!e)
            throw new Error("PropertyBinding: Cannot parse trackName: " + t);
          var n = {
              nodeName: e[2],
              objectName: e[3],
              objectIndex: e[4],
              propertyName: e[5],
              propertyIndex: e[6],
            },
            r = n.nodeName && n.nodeName.lastIndexOf(".");
          if (void 0 !== r && -1 !== r) {
            var i = n.nodeName.substring(r + 1);
            -1 !== lh.indexOf(i) &&
              ((n.nodeName = n.nodeName.substring(0, r)), (n.objectName = i));
          }
          if (null === n.propertyName || 0 === n.propertyName.length)
            throw new Error(
              "PropertyBinding: can not parse propertyName from trackName: " + t
            );
          return n;
        },
        findNode: function (t, e) {
          if (
            !e ||
            "" === e ||
            "root" === e ||
            "." === e ||
            -1 === e ||
            e === t.name ||
            e === t.uuid
          )
            return t;
          if (t.skeleton) {
            var n = t.skeleton.getBoneByName(e);
            if (void 0 !== n) return n;
          }
          if (t.children) {
            var r = function (t) {
                for (var n = 0; n < t.length; n++) {
                  var i = t[n];
                  if (i.name === e || i.uuid === e) return i;
                  var o = r(i.children);
                  if (o) return o;
                }
                return null;
              },
              i = r(t.children);
            if (i) return i;
          }
          return null;
        },
      }),
      Object.assign(ph.prototype, {
        _getValue_unavailable: function () {},
        _setValue_unavailable: function () {},
        BindingType: {
          Direct: 0,
          EntireArray: 1,
          ArrayElement: 2,
          HasFromToArray: 3,
        },
        Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
        GetterByBindingType: [
          function (t, e) {
            t[e] = this.node[this.propertyName];
          },
          function (t, e) {
            for (
              var n = this.resolvedProperty, r = 0, i = n.length;
              r !== i;
              ++r
            )
              t[e++] = n[r];
          },
          function (t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex];
          },
          function (t, e) {
            this.resolvedProperty.toArray(t, e);
          },
        ],
        SetterByBindingTypeAndVersioning: [
          [
            function (t, e) {
              this.targetObject[this.propertyName] = t[e];
            },
            function (t, e) {
              (this.targetObject[this.propertyName] = t[e]),
                (this.targetObject.needsUpdate = !0);
            },
            function (t, e) {
              (this.targetObject[this.propertyName] = t[e]),
                (this.targetObject.matrixWorldNeedsUpdate = !0);
            },
          ],
          [
            function (t, e) {
              for (
                var n = this.resolvedProperty, r = 0, i = n.length;
                r !== i;
                ++r
              )
                n[r] = t[e++];
            },
            function (t, e) {
              for (
                var n = this.resolvedProperty, r = 0, i = n.length;
                r !== i;
                ++r
              )
                n[r] = t[e++];
              this.targetObject.needsUpdate = !0;
            },
            function (t, e) {
              for (
                var n = this.resolvedProperty, r = 0, i = n.length;
                r !== i;
                ++r
              )
                n[r] = t[e++];
              this.targetObject.matrixWorldNeedsUpdate = !0;
            },
          ],
          [
            function (t, e) {
              this.resolvedProperty[this.propertyIndex] = t[e];
            },
            function (t, e) {
              (this.resolvedProperty[this.propertyIndex] = t[e]),
                (this.targetObject.needsUpdate = !0);
            },
            function (t, e) {
              (this.resolvedProperty[this.propertyIndex] = t[e]),
                (this.targetObject.matrixWorldNeedsUpdate = !0);
            },
          ],
          [
            function (t, e) {
              this.resolvedProperty.fromArray(t, e);
            },
            function (t, e) {
              this.resolvedProperty.fromArray(t, e),
                (this.targetObject.needsUpdate = !0);
            },
            function (t, e) {
              this.resolvedProperty.fromArray(t, e),
                (this.targetObject.matrixWorldNeedsUpdate = !0);
            },
          ],
        ],
        getValue: function (t, e) {
          this.bind(), this.getValue(t, e);
        },
        setValue: function (t, e) {
          this.bind(), this.setValue(t, e);
        },
        bind: function () {
          var t = this.node,
            e = this.parsedPath,
            n = e.objectName,
            r = e.propertyName,
            i = e.propertyIndex;
          if (
            (t ||
              ((t = ph.findNode(this.rootNode, e.nodeName) || this.rootNode),
              (this.node = t)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            t)
          ) {
            if (n) {
              var o = e.objectIndex;
              switch (n) {
                case "materials":
                  if (!t.material)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this
                    );
                  if (!t.material.materials)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                      this
                    );
                  t = t.material.materials;
                  break;
                case "bones":
                  if (!t.skeleton)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                      this
                    );
                  t = t.skeleton.bones;
                  for (var a = 0; a < t.length; a++)
                    if (t[a].name === o) {
                      o = a;
                      break;
                    }
                  break;
                default:
                  if (void 0 === t[n])
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                      this
                    );
                  t = t[n];
              }
              if (void 0 !== o) {
                if (void 0 === t[o])
                  return void console.error(
                    "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                    this,
                    t
                  );
                t = t[o];
              }
            }
            var s = t[r];
            if (void 0 !== s) {
              var c = this.Versioning.None;
              (this.targetObject = t),
                void 0 !== t.needsUpdate
                  ? (c = this.Versioning.NeedsUpdate)
                  : void 0 !== t.matrixWorldNeedsUpdate &&
                    (c = this.Versioning.MatrixWorldNeedsUpdate);
              var u = this.BindingType.Direct;
              if (void 0 !== i) {
                if ("morphTargetInfluences" === r) {
                  if (!t.geometry)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                      this
                    );
                  if (t.geometry.isBufferGeometry) {
                    if (!t.geometry.morphAttributes)
                      return void console.error(
                        "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                        this
                      );
                    for (
                      a = 0;
                      a < this.node.geometry.morphAttributes.position.length;
                      a++
                    )
                      if (t.geometry.morphAttributes.position[a].name === i) {
                        i = a;
                        break;
                      }
                  } else {
                    if (!t.geometry.morphTargets)
                      return void console.error(
                        "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",
                        this
                      );
                    for (a = 0; a < this.node.geometry.morphTargets.length; a++)
                      if (t.geometry.morphTargets[a].name === i) {
                        i = a;
                        break;
                      }
                  }
                }
                (u = this.BindingType.ArrayElement),
                  (this.resolvedProperty = s),
                  (this.propertyIndex = i);
              } else
                void 0 !== s.fromArray && void 0 !== s.toArray
                  ? ((u = this.BindingType.HasFromToArray),
                    (this.resolvedProperty = s))
                  : Array.isArray(s)
                  ? ((u = this.BindingType.EntireArray),
                    (this.resolvedProperty = s))
                  : (this.propertyName = r);
              (this.getValue = this.GetterByBindingType[u]),
                (this.setValue = this.SetterByBindingTypeAndVersioning[u][c]);
            } else {
              var l = e.nodeName;
              console.error(
                "THREE.PropertyBinding: Trying to update property for track: " +
                  l +
                  "." +
                  r +
                  " but it wasn't found.",
                t
              );
            }
          } else
            console.error(
              "THREE.PropertyBinding: Trying to update node for track: " +
                this.path +
                " but it wasn't found."
            );
        },
        unbind: function () {
          (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        },
      }),
      Object.assign(ph.prototype, {
        _getValue_unbound: ph.prototype.getValue,
        _setValue_unbound: ph.prototype.setValue,
      }),
      Object.assign(
        function () {
          (this.uuid = He.generateUUID()),
            (this._objects = Array.prototype.slice.call(arguments)),
            (this.nCachedObjects_ = 0);
          var t = {};
          this._indicesByUUID = t;
          for (var e = 0, n = arguments.length; e !== n; ++e)
            t[arguments[e].uuid] = e;
          (this._paths = []),
            (this._parsedPaths = []),
            (this._bindings = []),
            (this._bindingsIndicesByPath = {});
          var r = this;
          this.stats = {
            objects: {
              get total() {
                return r._objects.length;
              },
              get inUse() {
                return this.total - r.nCachedObjects_;
              },
            },
            get bindingsPerObject() {
              return r._bindings.length;
            },
          };
        }.prototype,
        {
          isAnimationObjectGroup: !0,
          add: function () {
            for (
              var t = this._objects,
                e = t.length,
                n = this.nCachedObjects_,
                r = this._indicesByUUID,
                i = this._paths,
                o = this._parsedPaths,
                a = this._bindings,
                s = a.length,
                c = void 0,
                u = 0,
                l = arguments.length;
              u !== l;
              ++u
            ) {
              var h = arguments[u],
                p = h.uuid,
                f = r[p];
              if (void 0 === f) {
                (f = e++), (r[p] = f), t.push(h);
                for (var d = 0, m = s; d !== m; ++d)
                  a[d].push(new ph(h, i[d], o[d]));
              } else if (f < n) {
                c = t[f];
                var v = --n,
                  g = t[v];
                (r[g.uuid] = f), (t[f] = g), (r[p] = v), (t[v] = h);
                for (d = 0, m = s; d !== m; ++d) {
                  var y = a[d],
                    x = y[v],
                    b = y[f];
                  (y[f] = x),
                    void 0 === b && (b = new ph(h, i[d], o[d])),
                    (y[v] = b);
                }
              } else
                t[f] !== c &&
                  console.error(
                    "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                  );
            }
            this.nCachedObjects_ = n;
          },
          remove: function () {
            for (
              var t = this._objects,
                e = this.nCachedObjects_,
                n = this._indicesByUUID,
                r = this._bindings,
                i = r.length,
                o = 0,
                a = arguments.length;
              o !== a;
              ++o
            ) {
              var s = arguments[o],
                c = s.uuid,
                u = n[c];
              if (void 0 !== u && u >= e) {
                var l = e++,
                  h = t[l];
                (n[h.uuid] = u), (t[u] = h), (n[c] = l), (t[l] = s);
                for (var p = 0, f = i; p !== f; ++p) {
                  var d = r[p],
                    m = d[l],
                    v = d[u];
                  (d[u] = m), (d[l] = v);
                }
              }
            }
            this.nCachedObjects_ = e;
          },
          uncache: function () {
            for (
              var t = this._objects,
                e = t.length,
                n = this.nCachedObjects_,
                r = this._indicesByUUID,
                i = this._bindings,
                o = i.length,
                a = 0,
                s = arguments.length;
              a !== s;
              ++a
            ) {
              var c = arguments[a],
                u = c.uuid,
                l = r[u];
              if (void 0 !== l)
                if ((delete r[u], l < n)) {
                  var h = --n,
                    p = t[h],
                    f = t[(y = --e)];
                  (r[p.uuid] = l),
                    (t[l] = p),
                    (r[f.uuid] = h),
                    (t[h] = f),
                    t.pop();
                  for (var d = 0, m = o; d !== m; ++d) {
                    var v = (x = i[d])[h],
                      g = x[y];
                    (x[l] = v), (x[h] = g), x.pop();
                  }
                } else {
                  var y;
                  (r[(f = t[(y = --e)]).uuid] = l), (t[l] = f), t.pop();
                  for (d = 0, m = o; d !== m; ++d) {
                    var x;
                    ((x = i[d])[l] = x[y]), x.pop();
                  }
                }
            }
            this.nCachedObjects_ = n;
          },
          subscribe_: function (t, e) {
            var n = this._bindingsIndicesByPath,
              r = n[t],
              i = this._bindings;
            if (void 0 !== r) return i[r];
            var o = this._paths,
              a = this._parsedPaths,
              s = this._objects,
              c = s.length,
              u = this.nCachedObjects_,
              l = new Array(c);
            (r = i.length), (n[t] = r), o.push(t), a.push(e), i.push(l);
            for (var h = u, p = s.length; h !== p; ++h) {
              var f = s[h];
              l[h] = new ph(f, t, e);
            }
            return l;
          },
          unsubscribe_: function (t) {
            var e = this._bindingsIndicesByPath,
              n = e[t];
            if (void 0 !== n) {
              var r = this._paths,
                i = this._parsedPaths,
                o = this._bindings,
                a = o.length - 1,
                s = o[a];
              (e[t[a]] = n),
                (o[n] = s),
                o.pop(),
                (i[n] = i[a]),
                i.pop(),
                (r[n] = r[a]),
                r.pop();
            }
          },
        }
      ),
      Object.assign(fh.prototype, {
        play: function () {
          return this._mixer._activateAction(this), this;
        },
        stop: function () {
          return this._mixer._deactivateAction(this), this.reset();
        },
        reset: function () {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          );
        },
        isRunning: function () {
          return (
            this.enabled &&
            !this.paused &&
            0 !== this.timeScale &&
            null === this._startTime &&
            this._mixer._isActiveAction(this)
          );
        },
        isScheduled: function () {
          return this._mixer._isActiveAction(this);
        },
        startAt: function (t) {
          return (this._startTime = t), this;
        },
        setLoop: function (t, e) {
          return (this.loop = t), (this.repetitions = e), this;
        },
        setEffectiveWeight: function (t) {
          return (
            (this.weight = t),
            (this._effectiveWeight = this.enabled ? t : 0),
            this.stopFading()
          );
        },
        getEffectiveWeight: function () {
          return this._effectiveWeight;
        },
        fadeIn: function (t) {
          return this._scheduleFading(t, 0, 1);
        },
        fadeOut: function (t) {
          return this._scheduleFading(t, 1, 0);
        },
        crossFadeFrom: function (t, e, n) {
          if ((t.fadeOut(e), this.fadeIn(e), n)) {
            var r = this._clip.duration,
              i = t._clip.duration,
              o = i / r,
              a = r / i;
            t.warp(1, o, e), this.warp(a, 1, e);
          }
          return this;
        },
        crossFadeTo: function (t, e, n) {
          return t.crossFadeFrom(this, e, n);
        },
        stopFading: function () {
          var t = this._weightInterpolant;
          return (
            null !== t &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(t)),
            this
          );
        },
        setEffectiveTimeScale: function (t) {
          return (
            (this.timeScale = t),
            (this._effectiveTimeScale = this.paused ? 0 : t),
            this.stopWarping()
          );
        },
        getEffectiveTimeScale: function () {
          return this._effectiveTimeScale;
        },
        setDuration: function (t) {
          return (this.timeScale = this._clip.duration / t), this.stopWarping();
        },
        syncWith: function (t) {
          return (
            (this.time = t.time),
            (this.timeScale = t.timeScale),
            this.stopWarping()
          );
        },
        halt: function (t) {
          return this.warp(this._effectiveTimeScale, 0, t);
        },
        warp: function (t, e, n) {
          var r = this._mixer,
            i = r.time,
            o = this._timeScaleInterpolant,
            a = this.timeScale;
          null === o &&
            ((o = r._lendControlInterpolant()),
            (this._timeScaleInterpolant = o));
          var s = o.parameterPositions,
            c = o.sampleValues;
          return (
            (s[0] = i), (s[1] = i + n), (c[0] = t / a), (c[1] = e / a), this
          );
        },
        stopWarping: function () {
          var t = this._timeScaleInterpolant;
          return (
            null !== t &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(t)),
            this
          );
        },
        getMixer: function () {
          return this._mixer;
        },
        getClip: function () {
          return this._clip;
        },
        getRoot: function () {
          return this._localRoot || this._mixer._root;
        },
        _update: function (t, e, n, r) {
          if (this.enabled) {
            var i = this._startTime;
            if (null !== i) {
              var o = (t - i) * n;
              if (o < 0 || 0 === n) return;
              (this._startTime = null), (e = n * o);
            }
            e *= this._updateTimeScale(t);
            var a = this._updateTime(e),
              s = this._updateWeight(t);
            if (s > 0)
              for (
                var c = this._interpolants,
                  u = this._propertyBindings,
                  l = 0,
                  h = c.length;
                l !== h;
                ++l
              )
                c[l].evaluate(a), u[l].accumulate(r, s);
          } else this._updateWeight(t);
        },
        _updateWeight: function (t) {
          var e = 0;
          if (this.enabled) {
            e = this.weight;
            var n = this._weightInterpolant;
            if (null !== n) {
              var r = n.evaluate(t)[0];
              (e *= r),
                t > n.parameterPositions[1] &&
                  (this.stopFading(), 0 === r && (this.enabled = !1));
            }
          }
          return (this._effectiveWeight = e), e;
        },
        _updateTimeScale: function (t) {
          var e = 0;
          if (!this.paused) {
            e = this.timeScale;
            var n = this._timeScaleInterpolant;
            if (null !== n)
              (e *= n.evaluate(t)[0]),
                t > n.parameterPositions[1] &&
                  (this.stopWarping(),
                  0 === e ? (this.paused = !0) : (this.timeScale = e));
          }
          return (this._effectiveTimeScale = e), e;
        },
        _updateTime: function (t) {
          var e = this.time + t,
            n = this._clip.duration,
            r = this.loop,
            i = this._loopCount,
            o = 2202 === r;
          if (0 === t) return -1 === i ? e : o && 1 == (1 & i) ? n - e : e;
          if (2200 === r) {
            -1 === i && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            t: {
              if (e >= n) e = n;
              else {
                if (!(e < 0)) {
                  this.time = e;
                  break t;
                }
                e = 0;
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (this.time = e),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: t < 0 ? -1 : 1,
                });
            }
          } else {
            if (
              (-1 === i &&
                (t >= 0
                  ? ((i = 0), this._setEndings(!0, 0 === this.repetitions, o))
                  : this._setEndings(0 === this.repetitions, !0, o)),
              e >= n || e < 0)
            ) {
              var a = Math.floor(e / n);
              (e -= n * a), (i += Math.abs(a));
              var s = this.repetitions - i;
              if (s <= 0)
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (e = t > 0 ? n : 0),
                  (this.time = e),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: t > 0 ? 1 : -1,
                  });
              else {
                if (1 === s) {
                  var c = t < 0;
                  this._setEndings(c, !c, o);
                } else this._setEndings(!1, !1, o);
                (this._loopCount = i),
                  (this.time = e),
                  this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: a,
                  });
              }
            } else this.time = e;
            if (o && 1 == (1 & i)) return n - e;
          }
          return e;
        },
        _setEndings: function (t, e, n) {
          var r = this._interpolantSettings;
          n
            ? ((r.endingStart = 2401), (r.endingEnd = 2401))
            : ((r.endingStart = t ? (this.zeroSlopeAtStart ? 2401 : _e) : 2402),
              (r.endingEnd = e ? (this.zeroSlopeAtEnd ? 2401 : _e) : 2402));
        },
        _scheduleFading: function (t, e, n) {
          var r = this._mixer,
            i = r.time,
            o = this._weightInterpolant;
          null === o &&
            ((o = r._lendControlInterpolant()), (this._weightInterpolant = o));
          var a = o.parameterPositions,
            s = o.sampleValues;
          return (a[0] = i), (s[0] = e), (a[1] = i + t), (s[1] = n), this;
        },
      }),
      (dh.prototype = Object.assign(Object.create(Ge.prototype), {
        constructor: dh,
        _bindAction: function (t, e) {
          var n = t._localRoot || this._root,
            r = t._clip.tracks,
            i = r.length,
            o = t._propertyBindings,
            a = t._interpolants,
            s = n.uuid,
            c = this._bindingsByRootAndName,
            u = c[s];
          void 0 === u && ((u = {}), (c[s] = u));
          for (var l = 0; l !== i; ++l) {
            var h = r[l],
              p = h.name,
              f = u[p];
            if (void 0 !== f) o[l] = f;
            else {
              if (void 0 !== (f = o[l])) {
                null === f._cacheIndex &&
                  (++f.referenceCount, this._addInactiveBinding(f, s, p));
                continue;
              }
              var d = e && e._propertyBindings[l].binding.parsedPath;
              ++(f = new nh(
                ph.create(n, p, d),
                h.ValueTypeName,
                h.getValueSize()
              )).referenceCount,
                this._addInactiveBinding(f, s, p),
                (o[l] = f);
            }
            a[l].resultBuffer = f.buffer;
          }
        },
        _activateAction: function (t) {
          if (!this._isActiveAction(t)) {
            if (null === t._cacheIndex) {
              var e = (t._localRoot || this._root).uuid,
                n = t._clip.uuid,
                r = this._actionsByClip[n];
              this._bindAction(t, r && r.knownActions[0]),
                this._addInactiveAction(t, n, e);
            }
            for (
              var i = t._propertyBindings, o = 0, a = i.length;
              o !== a;
              ++o
            ) {
              var s = i[o];
              0 == s.useCount++ &&
                (this._lendBinding(s), s.saveOriginalState());
            }
            this._lendAction(t);
          }
        },
        _deactivateAction: function (t) {
          if (this._isActiveAction(t)) {
            for (
              var e = t._propertyBindings, n = 0, r = e.length;
              n !== r;
              ++n
            ) {
              var i = e[n];
              0 == --i.useCount &&
                (i.restoreOriginalState(), this._takeBackBinding(i));
            }
            this._takeBackAction(t);
          }
        },
        _initMemoryManager: function () {
          (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
          var t = this;
          this.stats = {
            actions: {
              get total() {
                return t._actions.length;
              },
              get inUse() {
                return t._nActiveActions;
              },
            },
            bindings: {
              get total() {
                return t._bindings.length;
              },
              get inUse() {
                return t._nActiveBindings;
              },
            },
            controlInterpolants: {
              get total() {
                return t._controlInterpolants.length;
              },
              get inUse() {
                return t._nActiveControlInterpolants;
              },
            },
          };
        },
        _isActiveAction: function (t) {
          var e = t._cacheIndex;
          return null !== e && e < this._nActiveActions;
        },
        _addInactiveAction: function (t, e, n) {
          var r = this._actions,
            i = this._actionsByClip,
            o = i[e];
          if (void 0 === o)
            (o = { knownActions: [t], actionByRoot: {} }),
              (t._byClipCacheIndex = 0),
              (i[e] = o);
          else {
            var a = o.knownActions;
            (t._byClipCacheIndex = a.length), a.push(t);
          }
          (t._cacheIndex = r.length), r.push(t), (o.actionByRoot[n] = t);
        },
        _removeInactiveAction: function (t) {
          var e = this._actions,
            n = e[e.length - 1],
            r = t._cacheIndex;
          (n._cacheIndex = r), (e[r] = n), e.pop(), (t._cacheIndex = null);
          var i = t._clip.uuid,
            o = this._actionsByClip,
            a = o[i],
            s = a.knownActions,
            c = s[s.length - 1],
            u = t._byClipCacheIndex;
          (c._byClipCacheIndex = u),
            (s[u] = c),
            s.pop(),
            (t._byClipCacheIndex = null),
            delete a.actionByRoot[(t._localRoot || this._root).uuid],
            0 === s.length && delete o[i],
            this._removeInactiveBindingsForAction(t);
        },
        _removeInactiveBindingsForAction: function (t) {
          for (var e = t._propertyBindings, n = 0, r = e.length; n !== r; ++n) {
            var i = e[n];
            0 == --i.referenceCount && this._removeInactiveBinding(i);
          }
        },
        _lendAction: function (t) {
          var e = this._actions,
            n = t._cacheIndex,
            r = this._nActiveActions++,
            i = e[r];
          (t._cacheIndex = r), (e[r] = t), (i._cacheIndex = n), (e[n] = i);
        },
        _takeBackAction: function (t) {
          var e = this._actions,
            n = t._cacheIndex,
            r = --this._nActiveActions,
            i = e[r];
          (t._cacheIndex = r), (e[r] = t), (i._cacheIndex = n), (e[n] = i);
        },
        _addInactiveBinding: function (t, e, n) {
          var r = this._bindingsByRootAndName,
            i = r[e],
            o = this._bindings;
          void 0 === i && ((i = {}), (r[e] = i)),
            (i[n] = t),
            (t._cacheIndex = o.length),
            o.push(t);
        },
        _removeInactiveBinding: function (t) {
          var e = this._bindings,
            n = t.binding,
            r = n.rootNode.uuid,
            i = n.path,
            o = this._bindingsByRootAndName,
            a = o[r],
            s = e[e.length - 1],
            c = t._cacheIndex;
          (s._cacheIndex = c),
            (e[c] = s),
            e.pop(),
            delete a[i],
            0 === Object.keys(a).length && delete o[r];
        },
        _lendBinding: function (t) {
          var e = this._bindings,
            n = t._cacheIndex,
            r = this._nActiveBindings++,
            i = e[r];
          (t._cacheIndex = r), (e[r] = t), (i._cacheIndex = n), (e[n] = i);
        },
        _takeBackBinding: function (t) {
          var e = this._bindings,
            n = t._cacheIndex,
            r = --this._nActiveBindings,
            i = e[r];
          (t._cacheIndex = r), (e[r] = t), (i._cacheIndex = n), (e[n] = i);
        },
        _lendControlInterpolant: function () {
          var t = this._controlInterpolants,
            e = this._nActiveControlInterpolants++,
            n = t[e];
          return (
            void 0 === n &&
              (((n = new du(
                new Float32Array(2),
                new Float32Array(2),
                1,
                this._controlInterpolantsResultBuffer
              )).__cacheIndex = e),
              (t[e] = n)),
            n
          );
        },
        _takeBackControlInterpolant: function (t) {
          var e = this._controlInterpolants,
            n = t.__cacheIndex,
            r = --this._nActiveControlInterpolants,
            i = e[r];
          (t.__cacheIndex = r), (e[r] = t), (i.__cacheIndex = n), (e[n] = i);
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function (t, e) {
          var n = e || this._root,
            r = n.uuid,
            i = "string" == typeof t ? Su.findByName(n, t) : t,
            o = null !== i ? i.uuid : t,
            a = this._actionsByClip[o],
            s = null;
          if (void 0 !== a) {
            var c = a.actionByRoot[r];
            if (void 0 !== c) return c;
            (s = a.knownActions[0]), null === i && (i = s._clip);
          }
          if (null === i) return null;
          var u = new fh(this, i, e);
          return this._bindAction(u, s), this._addInactiveAction(u, o, r), u;
        },
        existingAction: function (t, e) {
          var n = e || this._root,
            r = n.uuid,
            i = "string" == typeof t ? Su.findByName(n, t) : t,
            o = i ? i.uuid : t,
            a = this._actionsByClip[o];
          return (void 0 !== a && a.actionByRoot[r]) || null;
        },
        stopAllAction: function () {
          var t = this._actions,
            e = this._nActiveActions,
            n = this._bindings,
            r = this._nActiveBindings;
          (this._nActiveActions = 0), (this._nActiveBindings = 0);
          for (var i = 0; i !== e; ++i) t[i].reset();
          for (i = 0; i !== r; ++i) n[i].useCount = 0;
          return this;
        },
        update: function (t) {
          t *= this.timeScale;
          for (
            var e = this._actions,
              n = this._nActiveActions,
              r = (this.time += t),
              i = Math.sign(t),
              o = (this._accuIndex ^= 1),
              a = 0;
            a !== n;
            ++a
          ) {
            e[a]._update(r, t, i, o);
          }
          var s = this._bindings,
            c = this._nActiveBindings;
          for (a = 0; a !== c; ++a) s[a].apply(o);
          return this;
        },
        setTime: function (t) {
          this.time = 0;
          for (var e = 0; e < this._actions.length; e++)
            this._actions[e].time = 0;
          return this.update(t);
        },
        getRoot: function () {
          return this._root;
        },
        uncacheClip: function (t) {
          var e = this._actions,
            n = t.uuid,
            r = this._actionsByClip,
            i = r[n];
          if (void 0 !== i) {
            for (var o = i.knownActions, a = 0, s = o.length; a !== s; ++a) {
              var c = o[a];
              this._deactivateAction(c);
              var u = c._cacheIndex,
                l = e[e.length - 1];
              (c._cacheIndex = null),
                (c._byClipCacheIndex = null),
                (l._cacheIndex = u),
                (e[u] = l),
                e.pop(),
                this._removeInactiveBindingsForAction(c);
            }
            delete r[n];
          }
        },
        uncacheRoot: function (t) {
          var e = t.uuid,
            n = this._actionsByClip;
          for (var r in n) {
            var i = n[r].actionByRoot[e];
            void 0 !== i &&
              (this._deactivateAction(i), this._removeInactiveAction(i));
          }
          var o = this._bindingsByRootAndName[e];
          if (void 0 !== o)
            for (var a in o) {
              var s = o[a];
              s.restoreOriginalState(), this._removeInactiveBinding(s);
            }
        },
        uncacheAction: function (t, e) {
          var n = this.existingAction(t, e);
          null !== n &&
            (this._deactivateAction(n), this._removeInactiveAction(n));
        },
      })),
      (mh.prototype.clone = function () {
        return new mh(
          void 0 === this.value.clone ? this.value : this.value.clone()
        );
      }),
      (vh.prototype = Object.assign(Object.create(Xa.prototype), {
        constructor: vh,
        isInstancedInterleavedBuffer: !0,
        copy: function (t) {
          return (
            Xa.prototype.copy.call(this, t),
            (this.meshPerAttribute = t.meshPerAttribute),
            this
          );
        },
      })),
      Object.assign(
        function (t, e, n, r) {
          (this.ray = new er(t, e)),
            (this.near = n || 0),
            (this.far = r || 1 / 0),
            (this.camera = null),
            (this.params = {
              Mesh: {},
              Line: {},
              LOD: {},
              Points: { threshold: 1 },
              Sprite: {},
            }),
            Object.defineProperties(this.params, {
              PointCloud: {
                get: function () {
                  return (
                    console.warn(
                      "THREE.Raycaster: params.PointCloud has been renamed to params.Points."
                    ),
                    this.Points
                  );
                },
              },
            });
        }.prototype,
        {
          linePrecision: 1,
          set: function (t, e) {
            this.ray.set(t, e);
          },
          setFromCamera: function (t, e) {
            e && e.isPerspectiveCamera
              ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                this.ray.direction
                  .set(t.x, t.y, 0.5)
                  .unproject(e)
                  .sub(this.ray.origin)
                  .normalize(),
                (this.camera = e))
              : e && e.isOrthographicCamera
              ? (this.ray.origin
                  .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
                  .unproject(e),
                this.ray.direction
                  .set(0, 0, -1)
                  .transformDirection(e.matrixWorld),
                (this.camera = e))
              : console.error("THREE.Raycaster: Unsupported camera type.");
          },
          intersectObject: function (t, e, n) {
            var r = n || [];
            return yh(t, this, r, e), r.sort(gh), r;
          },
          intersectObjects: function (t, e, n) {
            var r = n || [];
            if (!1 === Array.isArray(t))
              return (
                console.warn(
                  "THREE.Raycaster.intersectObjects: objects is not an Array."
                ),
                r
              );
            for (var i = 0, o = t.length; i < o; i++) yh(t[i], this, r, e);
            return r.sort(gh), r;
          },
        }
      ),
      Object.assign(
        function (t, e, n) {
          return (
            (this.radius = void 0 !== t ? t : 1),
            (this.phi = void 0 !== e ? e : 0),
            (this.theta = void 0 !== n ? n : 0),
            this
          );
        }.prototype,
        {
          set: function (t, e, n) {
            return (this.radius = t), (this.phi = e), (this.theta = n), this;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            return (
              (this.radius = t.radius),
              (this.phi = t.phi),
              (this.theta = t.theta),
              this
            );
          },
          makeSafe: function () {
            return (
              (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))),
              this
            );
          },
          setFromVector3: function (t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z);
          },
          setFromCartesianCoords: function (t, e, n) {
            return (
              (this.radius = Math.sqrt(t * t + e * e + n * n)),
              0 === this.radius
                ? ((this.theta = 0), (this.phi = 0))
                : ((this.theta = Math.atan2(t, n)),
                  (this.phi = Math.acos(He.clamp(e / this.radius, -1, 1)))),
              this
            );
          },
        }
      ),
      Object.assign(
        function (t, e, n) {
          return (
            (this.radius = void 0 !== t ? t : 1),
            (this.theta = void 0 !== e ? e : 0),
            (this.y = void 0 !== n ? n : 0),
            this
          );
        }.prototype,
        {
          set: function (t, e, n) {
            return (this.radius = t), (this.theta = e), (this.y = n), this;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            return (
              (this.radius = t.radius),
              (this.theta = t.theta),
              (this.y = t.y),
              this
            );
          },
          setFromVector3: function (t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z);
          },
          setFromCartesianCoords: function (t, e, n) {
            return (
              (this.radius = Math.sqrt(t * t + n * n)),
              (this.theta = Math.atan2(t, n)),
              (this.y = e),
              this
            );
          },
        }
      );
    var xh = new ke();
    function bh(t, e) {
      (this.min = void 0 !== t ? t : new ke(1 / 0, 1 / 0)),
        (this.max = void 0 !== e ? e : new ke(-1 / 0, -1 / 0));
    }
    Object.assign(bh.prototype, {
      set: function (t, e) {
        return this.min.copy(t), this.max.copy(e), this;
      },
      setFromPoints: function (t) {
        this.makeEmpty();
        for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
        return this;
      },
      setFromCenterAndSize: function (t, e) {
        var n = xh.copy(e).multiplyScalar(0.5);
        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.min.copy(t.min), this.max.copy(t.max), this;
      },
      makeEmpty: function () {
        return (
          (this.min.x = this.min.y = 1 / 0),
          (this.max.x = this.max.y = -1 / 0),
          this
        );
      },
      isEmpty: function () {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      },
      getCenter: function (t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box2: .getCenter() target is now required"),
            (t = new ke())),
          this.isEmpty()
            ? t.set(0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5)
        );
      },
      getSize: function (t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box2: .getSize() target is now required"),
            (t = new ke())),
          this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
        );
      },
      expandByPoint: function (t) {
        return this.min.min(t), this.max.max(t), this;
      },
      expandByVector: function (t) {
        return this.min.sub(t), this.max.add(t), this;
      },
      expandByScalar: function (t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this;
      },
      containsPoint: function (t) {
        return !(
          t.x < this.min.x ||
          t.x > this.max.x ||
          t.y < this.min.y ||
          t.y > this.max.y
        );
      },
      containsBox: function (t) {
        return (
          this.min.x <= t.min.x &&
          t.max.x <= this.max.x &&
          this.min.y <= t.min.y &&
          t.max.y <= this.max.y
        );
      },
      getParameter: function (t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Box2: .getParameter() target is now required"),
            (e = new ke())),
          e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y)
          )
        );
      },
      intersectsBox: function (t) {
        return !(
          t.max.x < this.min.x ||
          t.min.x > this.max.x ||
          t.max.y < this.min.y ||
          t.min.y > this.max.y
        );
      },
      clampPoint: function (t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Box2: .clampPoint() target is now required"),
            (e = new ke())),
          e.copy(t).clamp(this.min, this.max)
        );
      },
      distanceToPoint: function (t) {
        return xh.copy(t).clamp(this.min, this.max).sub(t).length();
      },
      intersect: function (t) {
        return this.min.max(t.min), this.max.min(t.max), this;
      },
      union: function (t) {
        return this.min.min(t.min), this.max.max(t.max), this;
      },
      translate: function (t) {
        return this.min.add(t), this.max.add(t), this;
      },
      equals: function (t) {
        return t.min.equals(this.min) && t.max.equals(this.max);
      },
    });
    var wh = new Ye(),
      _h = new Ye();
    function Mh(t, e) {
      (this.start = void 0 !== t ? t : new Ye()),
        (this.end = void 0 !== e ? e : new Ye());
    }
    function Sh(t) {
      Rn.call(this), (this.material = t), (this.render = function () {});
    }
    Object.assign(Mh.prototype, {
      set: function (t, e) {
        return this.start.copy(t), this.end.copy(e), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.start.copy(t.start), this.end.copy(t.end), this;
      },
      getCenter: function (t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Line3: .getCenter() target is now required"),
            (t = new Ye())),
          t.addVectors(this.start, this.end).multiplyScalar(0.5)
        );
      },
      delta: function (t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Line3: .delta() target is now required"),
            (t = new Ye())),
          t.subVectors(this.end, this.start)
        );
      },
      distanceSq: function () {
        return this.start.distanceToSquared(this.end);
      },
      distance: function () {
        return this.start.distanceTo(this.end);
      },
      at: function (t, e) {
        return (
          void 0 === e &&
            (console.warn("THREE.Line3: .at() target is now required"),
            (e = new Ye())),
          this.delta(e).multiplyScalar(t).add(this.start)
        );
      },
      closestPointToPointParameter: function (t, e) {
        wh.subVectors(t, this.start), _h.subVectors(this.end, this.start);
        var n = _h.dot(_h),
          r = _h.dot(wh) / n;
        return e && (r = He.clamp(r, 0, 1)), r;
      },
      closestPointToPoint: function (t, e, n) {
        var r = this.closestPointToPointParameter(t, e);
        return (
          void 0 === n &&
            (console.warn(
              "THREE.Line3: .closestPointToPoint() target is now required"
            ),
            (n = new Ye())),
          this.delta(n).multiplyScalar(r).add(this.start)
        );
      },
      applyMatrix4: function (t) {
        return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
      },
      equals: function (t) {
        return t.start.equals(this.start) && t.end.equals(this.end);
      },
    }),
      (Sh.prototype = Object.create(Rn.prototype)),
      (Sh.prototype.constructor = Sh),
      (Sh.prototype.isImmediateRenderObject = !0);
    var Eh = new Ye(),
      Th = new Ye(),
      Ah = new Qe(),
      Lh = ["a", "b", "c"];
    function Ph(t, e, n, r) {
      (this.object = t), (this.size = void 0 !== e ? e : 1);
      var i = void 0 !== n ? n : 16711680,
        o = void 0 !== r ? r : 1,
        a = 0,
        s = this.object.geometry;
      s && s.isGeometry
        ? (a = 3 * s.faces.length)
        : s && s.isBufferGeometry && (a = s.attributes.normal.count);
      var c = new Hr(),
        u = new Or(2 * a * 3, 3);
      c.addAttribute("position", u),
        Ls.call(this, c, new xs({ color: i, linewidth: o })),
        (this.matrixAutoUpdate = !1),
        this.update();
    }
    (Ph.prototype = Object.create(Ls.prototype)),
      (Ph.prototype.constructor = Ph),
      (Ph.prototype.update = function () {
        this.object.updateMatrixWorld(!0),
          Ah.getNormalMatrix(this.object.matrixWorld);
        var t = this.object.matrixWorld,
          e = this.geometry.attributes.position,
          n = this.object.geometry;
        if (n && n.isGeometry)
          for (
            var r = n.vertices, i = n.faces, o = 0, a = 0, s = i.length;
            a < s;
            a++
          )
            for (var c = i[a], u = 0, l = c.vertexNormals.length; u < l; u++) {
              var h = r[c[Lh[u]]],
                p = c.vertexNormals[u];
              Eh.copy(h).applyMatrix4(t),
                Th.copy(p)
                  .applyMatrix3(Ah)
                  .normalize()
                  .multiplyScalar(this.size)
                  .add(Eh),
                e.setXYZ(o, Eh.x, Eh.y, Eh.z),
                (o += 1),
                e.setXYZ(o, Th.x, Th.y, Th.z),
                (o += 1);
            }
        else if (n && n.isBufferGeometry) {
          var f = n.attributes.position,
            d = n.attributes.normal;
          for (o = 0, u = 0, l = f.count; u < l; u++)
            Eh.set(f.getX(u), f.getY(u), f.getZ(u)).applyMatrix4(t),
              Th.set(d.getX(u), d.getY(u), d.getZ(u)),
              Th.applyMatrix3(Ah).normalize().multiplyScalar(this.size).add(Eh),
              e.setXYZ(o, Eh.x, Eh.y, Eh.z),
              (o += 1),
              e.setXYZ(o, Th.x, Th.y, Th.z),
              (o += 1);
        }
        e.needsUpdate = !0;
      });
    var Rh = new Ye();
    function Ch(t, e) {
      Rn.call(this),
        (this.light = t),
        this.light.updateMatrixWorld(),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.color = e);
      for (
        var n = new Hr(),
          r = [
            0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0,
            1, 1, 0, 0, 0, 0, -1, 1,
          ],
          i = 0,
          o = 1;
        i < 32;
        i++, o++
      ) {
        var a = (i / 32) * Math.PI * 2,
          s = (o / 32) * Math.PI * 2;
        r.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1);
      }
      n.addAttribute("position", new Or(r, 3));
      var c = new xs({ fog: !1 });
      (this.cone = new Ls(n, c)), this.add(this.cone), this.update();
    }
    (Ch.prototype = Object.create(Rn.prototype)),
      (Ch.prototype.constructor = Ch),
      (Ch.prototype.dispose = function () {
        this.cone.geometry.dispose(), this.cone.material.dispose();
      }),
      (Ch.prototype.update = function () {
        this.light.updateMatrixWorld();
        var t = this.light.distance ? this.light.distance : 1e3,
          e = t * Math.tan(this.light.angle);
        this.cone.scale.set(e, e, t),
          Rh.setFromMatrixPosition(this.light.target.matrixWorld),
          this.cone.lookAt(Rh),
          void 0 !== this.color
            ? this.cone.material.color.set(this.color)
            : this.cone.material.color.copy(this.light.color);
      });
    var Oh = new Ye(),
      Ih = new pn(),
      Nh = new pn();
    function Dh(t) {
      for (
        var e = (function t(e) {
            var n = [];
            e && e.isBone && n.push(e);
            for (var r = 0; r < e.children.length; r++)
              n.push.apply(n, t(e.children[r]));
            return n;
          })(t),
          n = new Hr(),
          r = [],
          i = [],
          o = new vr(0, 0, 1),
          a = new vr(0, 1, 0),
          s = 0;
        s < e.length;
        s++
      ) {
        var c = e[s];
        c.parent &&
          c.parent.isBone &&
          (r.push(0, 0, 0),
          r.push(0, 0, 0),
          i.push(o.r, o.g, o.b),
          i.push(a.r, a.g, a.b));
      }
      n.addAttribute("position", new Or(r, 3)),
        n.addAttribute("color", new Or(i, 3));
      var u = new xs({
        vertexColors: R,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0,
      });
      Ls.call(this, n, u),
        (this.root = t),
        (this.bones = e),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1);
    }
    function zh(t, e, n) {
      (this.light = t), this.light.updateMatrixWorld(), (this.color = n);
      var r = new Uc(e, 4, 2),
        i = new Mr({ wireframe: !0, fog: !1 });
      si.call(this, r, i),
        (this.matrix = this.light.matrixWorld),
        (this.matrixAutoUpdate = !1),
        this.update();
    }
    function Fh(t, e) {
      (this.type = "RectAreaLightHelper"), (this.light = t), (this.color = e);
      var n = new Hr();
      n.addAttribute(
        "position",
        new Or([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)
      ),
        n.computeBoundingSphere();
      var r = new xs({ fog: !1 });
      Es.call(this, n, r);
      var i = new Hr();
      i.addAttribute(
        "position",
        new Or([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)
      ),
        i.computeBoundingSphere(),
        this.add(new si(i, new Mr({ side: T, fog: !1 }))),
        this.update();
    }
    (Dh.prototype = Object.create(Ls.prototype)),
      (Dh.prototype.constructor = Dh),
      (Dh.prototype.updateMatrixWorld = function (t) {
        var e = this.bones,
          n = this.geometry,
          r = n.getAttribute("position");
        Nh.getInverse(this.root.matrixWorld);
        for (var i = 0, o = 0; i < e.length; i++) {
          var a = e[i];
          a.parent &&
            a.parent.isBone &&
            (Ih.multiplyMatrices(Nh, a.matrixWorld),
            Oh.setFromMatrixPosition(Ih),
            r.setXYZ(o, Oh.x, Oh.y, Oh.z),
            Ih.multiplyMatrices(Nh, a.parent.matrixWorld),
            Oh.setFromMatrixPosition(Ih),
            r.setXYZ(o + 1, Oh.x, Oh.y, Oh.z),
            (o += 2));
        }
        (n.getAttribute("position").needsUpdate = !0),
          Rn.prototype.updateMatrixWorld.call(this, t);
      }),
      (zh.prototype = Object.create(si.prototype)),
      (zh.prototype.constructor = zh),
      (zh.prototype.dispose = function () {
        this.geometry.dispose(), this.material.dispose();
      }),
      (zh.prototype.update = function () {
        void 0 !== this.color
          ? this.material.color.set(this.color)
          : this.material.color.copy(this.light.color);
      }),
      (Fh.prototype = Object.create(Es.prototype)),
      (Fh.prototype.constructor = Fh),
      (Fh.prototype.update = function () {
        if (
          (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1),
          void 0 !== this.color)
        )
          this.material.color.set(this.color),
            this.children[0].material.color.set(this.color);
        else {
          this.material.color
            .copy(this.light.color)
            .multiplyScalar(this.light.intensity);
          var t = this.material.color,
            e = Math.max(t.r, t.g, t.b);
          e > 1 && t.multiplyScalar(1 / e),
            this.children[0].material.color.copy(this.material.color);
        }
      }),
      (Fh.prototype.dispose = function () {
        this.geometry.dispose(),
          this.material.dispose(),
          this.children[0].geometry.dispose(),
          this.children[0].material.dispose();
      });
    var Uh = new Ye(),
      Bh = new vr(),
      Gh = new vr();
    function jh(t, e, n) {
      Rn.call(this),
        (this.light = t),
        this.light.updateMatrixWorld(),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.color = n);
      var r = new Js(e);
      r.rotateY(0.5 * Math.PI),
        (this.material = new Mr({ wireframe: !0, fog: !1 })),
        void 0 === this.color && (this.material.vertexColors = R);
      var i = r.getAttribute("position"),
        o = new Float32Array(3 * i.count);
      r.addAttribute("color", new Sr(o, 3)),
        this.add(new si(r, this.material)),
        this.update();
    }
    function Vh(t, e) {
      (this.lightProbe = t), (this.size = e);
      var n = { GAMMA_OUTPUT: "" },
        r = new bi({
          defines: n,
          uniforms: {
            sh: { value: this.lightProbe.sh.coefficients },
            intensity: { value: this.lightProbe.intensity },
          },
          vertexShader: [
            "varying vec3 vNormal;",
            "void main() {",
            "\tvNormal = normalize( normalMatrix * normal );",
            "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
            "}",
          ].join("\n"),
          fragmentShader: [
            "#define RECIPROCAL_PI 0.318309886",
            "vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {",
            "\t// matrix is assumed to be orthogonal",
            "\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );",
            "}",
            "vec3 linearToOutput( in vec3 a ) {",
            "\t#ifdef GAMMA_OUTPUT",
            "\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );",
            "\t#else",
            "\t\treturn a;",
            "\t#endif",
            "}",
            "// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf",
            "vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {",
            "\t// normal is assumed to have unit length",
            "\tfloat x = normal.x, y = normal.y, z = normal.z;",
            "\t// band 0",
            "\tvec3 result = shCoefficients[ 0 ] * 0.886227;",
            "\t// band 1",
            "\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;",
            "\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;",
            "\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;",
            "\t// band 2",
            "\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;",
            "\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;",
            "\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );",
            "\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;",
            "\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );",
            "\treturn result;",
            "}",
            "uniform vec3 sh[ 9 ]; // sh coefficients",
            "uniform float intensity; // light probe intensity",
            "varying vec3 vNormal;",
            "void main() {",
            "\tvec3 normal = normalize( vNormal );",
            "\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );",
            "\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );",
            "\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;",
            "\toutgoingLight = linearToOutput( outgoingLight );",
            "\tgl_FragColor = vec4( outgoingLight, 1.0 );",
            "}",
          ].join("\n"),
        }),
        i = new Uc(1, 32, 16);
      si.call(this, i, r), this.onBeforeRender();
    }
    function Hh(t, e, n, r) {
      (t = t || 10),
        (e = e || 10),
        (n = new vr(void 0 !== n ? n : 4473924)),
        (r = new vr(void 0 !== r ? r : 8947848));
      for (
        var i = e / 2,
          o = t / e,
          a = t / 2,
          s = [],
          c = [],
          u = 0,
          l = 0,
          h = -a;
        u <= e;
        u++, h += o
      ) {
        s.push(-a, 0, h, a, 0, h), s.push(h, 0, -a, h, 0, a);
        var p = u === i ? n : r;
        p.toArray(c, l),
          (l += 3),
          p.toArray(c, l),
          (l += 3),
          p.toArray(c, l),
          (l += 3),
          p.toArray(c, l),
          (l += 3);
      }
      var f = new Hr();
      f.addAttribute("position", new Or(s, 3)),
        f.addAttribute("color", new Or(c, 3));
      var d = new xs({ vertexColors: R });
      Ls.call(this, f, d);
    }
    function kh(t, e, n, r, i, o) {
      (t = t || 10),
        (e = e || 16),
        (n = n || 8),
        (r = r || 64),
        (i = new vr(void 0 !== i ? i : 4473924)),
        (o = new vr(void 0 !== o ? o : 8947848));
      var a,
        s,
        c,
        u,
        l,
        h,
        p,
        f = [],
        d = [];
      for (u = 0; u <= e; u++)
        (c = (u / e) * (2 * Math.PI)),
          (a = Math.sin(c) * t),
          (s = Math.cos(c) * t),
          f.push(0, 0, 0),
          f.push(a, 0, s),
          (p = 1 & u ? i : o),
          d.push(p.r, p.g, p.b),
          d.push(p.r, p.g, p.b);
      for (u = 0; u <= n; u++)
        for (p = 1 & u ? i : o, h = t - (t / n) * u, l = 0; l < r; l++)
          (c = (l / r) * (2 * Math.PI)),
            (a = Math.sin(c) * h),
            (s = Math.cos(c) * h),
            f.push(a, 0, s),
            d.push(p.r, p.g, p.b),
            (c = ((l + 1) / r) * (2 * Math.PI)),
            (a = Math.sin(c) * h),
            (s = Math.cos(c) * h),
            f.push(a, 0, s),
            d.push(p.r, p.g, p.b);
      var m = new Hr();
      m.addAttribute("position", new Or(f, 3)),
        m.addAttribute("color", new Or(d, 3));
      var v = new xs({ vertexColors: R });
      Ls.call(this, m, v);
    }
    function Wh(t, e, n, r) {
      (this.audio = t),
        (this.range = e || 1),
        (this.divisionsInnerAngle = n || 16),
        (this.divisionsOuterAngle = r || 2);
      var i = new Hr(),
        o = this.divisionsInnerAngle + 2 * this.divisionsOuterAngle,
        a = new Float32Array(3 * (3 * o + 3));
      i.addAttribute("position", new Sr(a, 3));
      var s = new xs({ color: 65280 }),
        c = new xs({ color: 16776960 });
      Es.call(this, i, [c, s]), this.update();
    }
    (jh.prototype = Object.create(Rn.prototype)),
      (jh.prototype.constructor = jh),
      (jh.prototype.dispose = function () {
        this.children[0].geometry.dispose(),
          this.children[0].material.dispose();
      }),
      (jh.prototype.update = function () {
        var t = this.children[0];
        if (void 0 !== this.color) this.material.color.set(this.color);
        else {
          var e = t.geometry.getAttribute("color");
          Bh.copy(this.light.color), Gh.copy(this.light.groundColor);
          for (var n = 0, r = e.count; n < r; n++) {
            var i = n < r / 2 ? Bh : Gh;
            e.setXYZ(n, i.r, i.g, i.b);
          }
          e.needsUpdate = !0;
        }
        t.lookAt(Uh.setFromMatrixPosition(this.light.matrixWorld).negate());
      }),
      (Vh.prototype = Object.create(si.prototype)),
      (Vh.prototype.constructor = Vh),
      (Vh.prototype.dispose = function () {
        this.geometry.dispose(), this.material.dispose();
      }),
      (Vh.prototype.onBeforeRender = function () {
        this.position.copy(this.lightProbe.position),
          this.scale.set(1, 1, 1).multiplyScalar(this.size),
          (this.material.uniforms.intensity.value = this.lightProbe.intensity);
      }),
      (Hh.prototype = Object.assign(Object.create(Ls.prototype), {
        constructor: Hh,
        copy: function (t) {
          return (
            Ls.prototype.copy.call(this, t),
            this.geometry.copy(t.geometry),
            this.material.copy(t.material),
            this
          );
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
      })),
      (kh.prototype = Object.create(Ls.prototype)),
      (kh.prototype.constructor = kh),
      (Wh.prototype = Object.create(Es.prototype)),
      (Wh.prototype.constructor = Wh),
      (Wh.prototype.update = function () {
        var t,
          e,
          n = this.audio,
          r = this.range,
          i = this.divisionsInnerAngle,
          o = this.divisionsOuterAngle,
          a = He.degToRad(n.panner.coneInnerAngle),
          s = He.degToRad(n.panner.coneOuterAngle),
          c = a / 2,
          u = s / 2,
          l = 0,
          h = 0,
          p = this.geometry,
          f = p.attributes.position;
        function d(n, i, o, a) {
          var s = (i - n) / o;
          for (f.setXYZ(l, 0, 0, 0), h++, t = n; t < i; t += s)
            (e = l + h),
              f.setXYZ(e, Math.sin(t) * r, 0, Math.cos(t) * r),
              f.setXYZ(
                e + 1,
                Math.sin(Math.min(t + s, i)) * r,
                0,
                Math.cos(Math.min(t + s, i)) * r
              ),
              f.setXYZ(e + 2, 0, 0, 0),
              (h += 3);
          p.addGroup(l, h, a), (l += h), (h = 0);
        }
        p.clearGroups(),
          d(-u, -c, o, 0),
          d(-c, c, i, 1),
          d(c, u, o, 0),
          (f.needsUpdate = !0),
          a === s && (this.material[0].visible = !1);
      }),
      (Wh.prototype.dispose = function () {
        this.geometry.dispose(),
          this.material[0].dispose(),
          this.material[1].dispose();
      });
    var qh = new Ye(),
      Xh = new Ye(),
      Yh = new Qe();
    function Jh(t, e, n, r) {
      (this.object = t), (this.size = void 0 !== e ? e : 1);
      var i = void 0 !== n ? n : 16776960,
        o = void 0 !== r ? r : 1,
        a = 0,
        s = this.object.geometry;
      s && s.isGeometry
        ? (a = s.faces.length)
        : console.warn(
            "THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."
          );
      var c = new Hr(),
        u = new Or(2 * a * 3, 3);
      c.addAttribute("position", u),
        Ls.call(this, c, new xs({ color: i, linewidth: o })),
        (this.matrixAutoUpdate = !1),
        this.update();
    }
    (Jh.prototype = Object.create(Ls.prototype)),
      (Jh.prototype.constructor = Jh),
      (Jh.prototype.update = function () {
        this.object.updateMatrixWorld(!0),
          Yh.getNormalMatrix(this.object.matrixWorld);
        for (
          var t = this.object.matrixWorld,
            e = this.geometry.attributes.position,
            n = this.object.geometry,
            r = n.vertices,
            i = n.faces,
            o = 0,
            a = 0,
            s = i.length;
          a < s;
          a++
        ) {
          var c = i[a],
            u = c.normal;
          qh
            .copy(r[c.a])
            .add(r[c.b])
            .add(r[c.c])
            .divideScalar(3)
            .applyMatrix4(t),
            Xh.copy(u)
              .applyMatrix3(Yh)
              .normalize()
              .multiplyScalar(this.size)
              .add(qh),
            e.setXYZ(o, qh.x, qh.y, qh.z),
            (o += 1),
            e.setXYZ(o, Xh.x, Xh.y, Xh.z),
            (o += 1);
        }
        e.needsUpdate = !0;
      });
    var Zh = new Ye(),
      Qh = new Ye(),
      Kh = new Ye();
    function $h(t, e, n) {
      Rn.call(this),
        (this.light = t),
        this.light.updateMatrixWorld(),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.color = n),
        void 0 === e && (e = 1);
      var r = new Hr();
      r.addAttribute(
        "position",
        new Or([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
      );
      var i = new xs({ fog: !1 });
      (this.lightPlane = new Es(r, i)),
        this.add(this.lightPlane),
        (r = new Hr()).addAttribute("position", new Or([0, 0, 0, 0, 0, 1], 3)),
        (this.targetLine = new Es(r, i)),
        this.add(this.targetLine),
        this.update();
    }
    ($h.prototype = Object.create(Rn.prototype)),
      ($h.prototype.constructor = $h),
      ($h.prototype.dispose = function () {
        this.lightPlane.geometry.dispose(),
          this.lightPlane.material.dispose(),
          this.targetLine.geometry.dispose(),
          this.targetLine.material.dispose();
      }),
      ($h.prototype.update = function () {
        Zh.setFromMatrixPosition(this.light.matrixWorld),
          Qh.setFromMatrixPosition(this.light.target.matrixWorld),
          Kh.subVectors(Qh, Zh),
          this.lightPlane.lookAt(Qh),
          void 0 !== this.color
            ? (this.lightPlane.material.color.set(this.color),
              this.targetLine.material.color.set(this.color))
            : (this.lightPlane.material.color.copy(this.light.color),
              this.targetLine.material.color.copy(this.light.color)),
          this.targetLine.lookAt(Qh),
          (this.targetLine.scale.z = Kh.length());
      });
    var tp = new Ye(),
      ep = new wi();
    function np(t) {
      var e = new Hr(),
        n = new xs({ color: 16777215, vertexColors: P }),
        r = [],
        i = [],
        o = {},
        a = new vr(16755200),
        s = new vr(16711680),
        c = new vr(43775),
        u = new vr(16777215),
        l = new vr(3355443);
      function h(t, e, n) {
        p(t, n), p(e, n);
      }
      function p(t, e) {
        r.push(0, 0, 0),
          i.push(e.r, e.g, e.b),
          void 0 === o[t] && (o[t] = []),
          o[t].push(r.length / 3 - 1);
      }
      h("n1", "n2", a),
        h("n2", "n4", a),
        h("n4", "n3", a),
        h("n3", "n1", a),
        h("f1", "f2", a),
        h("f2", "f4", a),
        h("f4", "f3", a),
        h("f3", "f1", a),
        h("n1", "f1", a),
        h("n2", "f2", a),
        h("n3", "f3", a),
        h("n4", "f4", a),
        h("p", "n1", s),
        h("p", "n2", s),
        h("p", "n3", s),
        h("p", "n4", s),
        h("u1", "u2", c),
        h("u2", "u3", c),
        h("u3", "u1", c),
        h("c", "t", u),
        h("p", "c", l),
        h("cn1", "cn2", l),
        h("cn3", "cn4", l),
        h("cf1", "cf2", l),
        h("cf3", "cf4", l),
        e.addAttribute("position", new Or(r, 3)),
        e.addAttribute("color", new Or(i, 3)),
        Ls.call(this, e, n),
        (this.camera = t),
        this.camera.updateProjectionMatrix &&
          this.camera.updateProjectionMatrix(),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.pointMap = o),
        this.update();
    }
    function rp(t, e, n, r, i, o, a) {
      tp.set(i, o, a).unproject(r);
      var s = e[t];
      if (void 0 !== s)
        for (
          var c = n.getAttribute("position"), u = 0, l = s.length;
          u < l;
          u++
        )
          c.setXYZ(s[u], tp.x, tp.y, tp.z);
    }
    (np.prototype = Object.create(Ls.prototype)),
      (np.prototype.constructor = np),
      (np.prototype.update = function () {
        var t = this.geometry,
          e = this.pointMap;
        ep.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
          rp("c", e, t, ep, 0, 0, -1),
          rp("t", e, t, ep, 0, 0, 1),
          rp("n1", e, t, ep, -1, -1, -1),
          rp("n2", e, t, ep, 1, -1, -1),
          rp("n3", e, t, ep, -1, 1, -1),
          rp("n4", e, t, ep, 1, 1, -1),
          rp("f1", e, t, ep, -1, -1, 1),
          rp("f2", e, t, ep, 1, -1, 1),
          rp("f3", e, t, ep, -1, 1, 1),
          rp("f4", e, t, ep, 1, 1, 1),
          rp("u1", e, t, ep, 0.7, 1.1, -1),
          rp("u2", e, t, ep, -0.7, 1.1, -1),
          rp("u3", e, t, ep, 0, 2, -1),
          rp("cf1", e, t, ep, -1, 0, 1),
          rp("cf2", e, t, ep, 1, 0, 1),
          rp("cf3", e, t, ep, 0, -1, 1),
          rp("cf4", e, t, ep, 0, 1, 1),
          rp("cn1", e, t, ep, -1, 0, -1),
          rp("cn2", e, t, ep, 1, 0, -1),
          rp("cn3", e, t, ep, 0, -1, -1),
          rp("cn4", e, t, ep, 0, 1, -1),
          (t.getAttribute("position").needsUpdate = !0);
      });
    var ip = new kn();
    function op(t, e) {
      (this.object = t), void 0 === e && (e = 16776960);
      var n = new Uint16Array([
          0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
          7,
        ]),
        r = new Float32Array(24),
        i = new Hr();
      i.setIndex(new Sr(n, 1)),
        i.addAttribute("position", new Sr(r, 3)),
        Ls.call(this, i, new xs({ color: e })),
        (this.matrixAutoUpdate = !1),
        this.update();
    }
    function ap(t, e) {
      (this.type = "Box3Helper"), (this.box = t), (e = e || 16776960);
      var n = new Uint16Array([
          0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
          7,
        ]),
        r = new Hr();
      r.setIndex(new Sr(n, 1)),
        r.addAttribute(
          "position",
          new Or(
            [
              1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1,
              -1, -1, 1, -1, -1,
            ],
            3
          )
        ),
        Ls.call(this, r, new xs({ color: e })),
        this.geometry.computeBoundingSphere();
    }
    function sp(t, e, n) {
      (this.type = "PlaneHelper"),
        (this.plane = t),
        (this.size = void 0 === e ? 1 : e);
      var r = void 0 !== n ? n : 16776960,
        i = new Hr();
      i.addAttribute(
        "position",
        new Or(
          [
            1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1,
            1, 1, 1, 1, 0, 0, 1, 0, 0, 0,
          ],
          3
        )
      ),
        i.computeBoundingSphere(),
        Es.call(this, i, new xs({ color: r }));
      var o = new Hr();
      o.addAttribute(
        "position",
        new Or([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)
      ),
        o.computeBoundingSphere(),
        this.add(
          new si(
            o,
            new Mr({ color: r, opacity: 0.2, transparent: !0, depthWrite: !1 })
          )
        );
    }
    (op.prototype = Object.create(Ls.prototype)),
      (op.prototype.constructor = op),
      (op.prototype.update = function (t) {
        if (
          (void 0 !== t &&
            console.warn("THREE.BoxHelper: .update() has no longer arguments."),
          void 0 !== this.object && ip.setFromObject(this.object),
          !ip.isEmpty())
        ) {
          var e = ip.min,
            n = ip.max,
            r = this.geometry.attributes.position,
            i = r.array;
          (i[0] = n.x),
            (i[1] = n.y),
            (i[2] = n.z),
            (i[3] = e.x),
            (i[4] = n.y),
            (i[5] = n.z),
            (i[6] = e.x),
            (i[7] = e.y),
            (i[8] = n.z),
            (i[9] = n.x),
            (i[10] = e.y),
            (i[11] = n.z),
            (i[12] = n.x),
            (i[13] = n.y),
            (i[14] = e.z),
            (i[15] = e.x),
            (i[16] = n.y),
            (i[17] = e.z),
            (i[18] = e.x),
            (i[19] = e.y),
            (i[20] = e.z),
            (i[21] = n.x),
            (i[22] = e.y),
            (i[23] = e.z),
            (r.needsUpdate = !0),
            this.geometry.computeBoundingSphere();
        }
      }),
      (op.prototype.setFromObject = function (t) {
        return (this.object = t), this.update(), this;
      }),
      (op.prototype.copy = function (t) {
        return Ls.prototype.copy.call(this, t), (this.object = t.object), this;
      }),
      (op.prototype.clone = function () {
        return new this.constructor().copy(this);
      }),
      (ap.prototype = Object.create(Ls.prototype)),
      (ap.prototype.constructor = ap),
      (ap.prototype.updateMatrixWorld = function (t) {
        var e = this.box;
        e.isEmpty() ||
          (e.getCenter(this.position),
          e.getSize(this.scale),
          this.scale.multiplyScalar(0.5),
          Rn.prototype.updateMatrixWorld.call(this, t));
      }),
      (sp.prototype = Object.create(Es.prototype)),
      (sp.prototype.constructor = sp),
      (sp.prototype.updateMatrixWorld = function (t) {
        var e = -this.plane.constant;
        Math.abs(e) < 1e-8 && (e = 1e-8),
          this.scale.set(0.5 * this.size, 0.5 * this.size, e),
          (this.children[0].material.side = e < 0 ? T : E),
          this.lookAt(this.plane.normal),
          Rn.prototype.updateMatrixWorld.call(this, t);
      });
    var cp,
      up,
      lp = new Ye();
    function hp(t, e, n, r, i, o) {
      Rn.call(this),
        void 0 === t && (t = new Ye(0, 0, 1)),
        void 0 === e && (e = new Ye(0, 0, 0)),
        void 0 === n && (n = 1),
        void 0 === r && (r = 16776960),
        void 0 === i && (i = 0.2 * n),
        void 0 === o && (o = 0.2 * i),
        void 0 === cp &&
          ((cp = new Hr()).addAttribute(
            "position",
            new Or([0, 0, 0, 0, 1, 0], 3)
          ),
          (up = new Yc(0, 0.5, 1, 5, 1)).translate(0, -0.5, 0)),
        this.position.copy(e),
        (this.line = new Es(cp, new xs({ color: r }))),
        (this.line.matrixAutoUpdate = !1),
        this.add(this.line),
        (this.cone = new si(up, new Mr({ color: r }))),
        (this.cone.matrixAutoUpdate = !1),
        this.add(this.cone),
        this.setDirection(t),
        this.setLength(n, i, o);
    }
    function pp(t) {
      var e = [0, 0, 0, (t = t || 1), 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
        n = new Hr();
      n.addAttribute("position", new Or(e, 3)),
        n.addAttribute(
          "color",
          new Or(
            [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
            3
          )
        );
      var r = new xs({ vertexColors: R });
      Ls.call(this, n, r);
    }
    (hp.prototype = Object.create(Rn.prototype)),
      (hp.prototype.constructor = hp),
      (hp.prototype.setDirection = function (t) {
        if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
        else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
        else {
          lp.set(t.z, 0, -t.x).normalize();
          var e = Math.acos(t.y);
          this.quaternion.setFromAxisAngle(lp, e);
        }
      }),
      (hp.prototype.setLength = function (t, e, n) {
        void 0 === e && (e = 0.2 * t),
          void 0 === n && (n = 0.2 * e),
          this.line.scale.set(1, Math.max(1e-4, t - e), 1),
          this.line.updateMatrix(),
          this.cone.scale.set(n, e, n),
          (this.cone.position.y = t),
          this.cone.updateMatrix();
      }),
      (hp.prototype.setColor = function (t) {
        this.line.material.color.set(t), this.cone.material.color.set(t);
      }),
      (hp.prototype.copy = function (t) {
        return (
          Rn.prototype.copy.call(this, t, !1),
          this.line.copy(t.line),
          this.cone.copy(t.cone),
          this
        );
      }),
      (hp.prototype.clone = function () {
        return new this.constructor().copy(this);
      }),
      (pp.prototype = Object.create(Ls.prototype)),
      (pp.prototype.constructor = pp);
    function fp(t) {
      console.warn(
        "THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."
      ),
        qu.call(this, t),
        (this.type = "catmullrom");
    }
    (Uu.create = function (t, e) {
      return (
        console.log("THREE.Curve.create() has been deprecated"),
        (t.prototype = Object.create(Uu.prototype)),
        (t.prototype.constructor = t),
        (t.prototype.getPoint = e),
        t
      );
    }),
      Object.assign(il.prototype, {
        createPointsGeometry: function (t) {
          console.warn(
            "THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
          );
          var e = this.getPoints(t);
          return this.createGeometry(e);
        },
        createSpacedPointsGeometry: function (t) {
          console.warn(
            "THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
          );
          var e = this.getSpacedPoints(t);
          return this.createGeometry(e);
        },
        createGeometry: function (t) {
          console.warn(
            "THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
          );
          for (var e = new di(), n = 0, r = t.length; n < r; n++) {
            var i = t[n];
            e.vertices.push(new Ye(i.x, i.y, i.z || 0));
          }
          return e;
        },
      }),
      Object.assign(ol.prototype, {
        fromPoints: function (t) {
          console.warn(
            "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
          ),
            this.setFromPoints(t);
        },
      }),
      Object.create(qu.prototype),
      Object.create(qu.prototype),
      (fp.prototype = Object.create(qu.prototype)),
      Object.assign(fp.prototype, {
        initFromArray: function () {
          console.error("THREE.Spline: .initFromArray() has been removed.");
        },
        getControlPointsArray: function () {
          console.error(
            "THREE.Spline: .getControlPointsArray() has been removed."
          );
        },
        reparametrizeByArcLength: function () {
          console.error(
            "THREE.Spline: .reparametrizeByArcLength() has been removed."
          );
        },
      }),
      (Hh.prototype.setColors = function () {
        console.error(
          "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
        );
      }),
      (Dh.prototype.update = function () {
        console.error(
          "THREE.SkeletonHelper: update() no longer needs to be called."
        );
      }),
      Object.assign(Pu.prototype, {
        extractUrlBase: function (t) {
          return (
            console.warn(
              "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
            ),
            bl(t)
          );
        },
      }),
      (Pu.Handlers = {
        add: function () {
          console.error(
            "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
          );
        },
        get: function () {
          console.error(
            "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
          );
        },
      }),
      Object.assign(El.prototype, {
        setTexturePath: function (t) {
          return (
            console.warn(
              "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
            ),
            this.setResourcePath(t)
          );
        },
      }),
      Object.assign(bh.prototype, {
        center: function (t) {
          return (
            console.warn(
              "THREE.Box2: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(t)
          );
        },
        empty: function () {
          return (
            console.warn(
              "THREE.Box2: .empty() has been renamed to .isEmpty()."
            ),
            this.isEmpty()
          );
        },
        isIntersectionBox: function (t) {
          return (
            console.warn(
              "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        },
        size: function (t) {
          return (
            console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
            this.getSize(t)
          );
        },
      }),
      Object.assign(kn.prototype, {
        center: function (t) {
          return (
            console.warn(
              "THREE.Box3: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(t)
          );
        },
        empty: function () {
          return (
            console.warn(
              "THREE.Box3: .empty() has been renamed to .isEmpty()."
            ),
            this.isEmpty()
          );
        },
        isIntersectionBox: function (t) {
          return (
            console.warn(
              "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        },
        isIntersectionSphere: function (t) {
          return (
            console.warn(
              "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
            ),
            this.intersectsSphere(t)
          );
        },
        size: function (t) {
          return (
            console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
            this.getSize(t)
          );
        },
      }),
      (Mh.prototype.center = function (t) {
        return (
          console.warn(
            "THREE.Line3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(t)
        );
      }),
      Object.assign(He, {
        random16: function () {
          return (
            console.warn(
              "THREE.Math: .random16() has been deprecated. Use Math.random() instead."
            ),
            Math.random()
          );
        },
        nearestPowerOfTwo: function (t) {
          return (
            console.warn(
              "THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
            ),
            He.floorPowerOfTwo(t)
          );
        },
        nextPowerOfTwo: function (t) {
          return (
            console.warn(
              "THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
            ),
            He.ceilPowerOfTwo(t)
          );
        },
      }),
      Object.assign(Qe.prototype, {
        flattenToArrayOffset: function (t, e) {
          return (
            console.warn(
              "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
            ),
            this.toArray(t, e)
          );
        },
        multiplyVector3: function (t) {
          return (
            console.warn(
              "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
            ),
            t.applyMatrix3(this)
          );
        },
        multiplyVector3Array: function () {
          console.error(
            "THREE.Matrix3: .multiplyVector3Array() has been removed."
          );
        },
        applyToBuffer: function (t) {
          return (
            console.warn(
              "THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
            ),
            this.applyToBufferAttribute(t)
          );
        },
        applyToVector3Array: function () {
          console.error(
            "THREE.Matrix3: .applyToVector3Array() has been removed."
          );
        },
      }),
      Object.assign(pn.prototype, {
        extractPosition: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
            ),
            this.copyPosition(t)
          );
        },
        flattenToArrayOffset: function (t, e) {
          return (
            console.warn(
              "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
            ),
            this.toArray(t, e)
          );
        },
        getPosition: function () {
          return (
            console.warn(
              "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
            ),
            new Ye().setFromMatrixColumn(this, 3)
          );
        },
        setRotationFromQuaternion: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
            ),
            this.makeRotationFromQuaternion(t)
          );
        },
        multiplyToArray: function () {
          console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
        },
        multiplyVector3: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        },
        multiplyVector4: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        },
        multiplyVector3Array: function () {
          console.error(
            "THREE.Matrix4: .multiplyVector3Array() has been removed."
          );
        },
        rotateAxis: function (t) {
          console.warn(
            "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
          ),
            t.transformDirection(this);
        },
        crossVector: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        },
        translate: function () {
          console.error("THREE.Matrix4: .translate() has been removed.");
        },
        rotateX: function () {
          console.error("THREE.Matrix4: .rotateX() has been removed.");
        },
        rotateY: function () {
          console.error("THREE.Matrix4: .rotateY() has been removed.");
        },
        rotateZ: function () {
          console.error("THREE.Matrix4: .rotateZ() has been removed.");
        },
        rotateByAxis: function () {
          console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
        },
        applyToBuffer: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
            ),
            this.applyToBufferAttribute(t)
          );
        },
        applyToVector3Array: function () {
          console.error(
            "THREE.Matrix4: .applyToVector3Array() has been removed."
          );
        },
        makeFrustum: function (t, e, n, r, i, o) {
          return (
            console.warn(
              "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
            ),
            this.makePerspective(t, e, r, n, i, o)
          );
        },
      }),
      (Ci.prototype.isIntersectionLine = function (t) {
        return (
          console.warn(
            "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
          ),
          this.intersectsLine(t)
        );
      }),
      (We.prototype.multiplyVector3 = function (t) {
        return (
          console.warn(
            "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
          ),
          t.applyQuaternion(this)
        );
      }),
      Object.assign(er.prototype, {
        isIntersectionBox: function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        },
        isIntersectionPlane: function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
            ),
            this.intersectsPlane(t)
          );
        },
        isIntersectionSphere: function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
            ),
            this.intersectsSphere(t)
          );
        },
      }),
      Object.assign(pr.prototype, {
        area: function () {
          return (
            console.warn(
              "THREE.Triangle: .area() has been renamed to .getArea()."
            ),
            this.getArea()
          );
        },
        barycoordFromPoint: function (t, e) {
          return (
            console.warn(
              "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
            ),
            this.getBarycoord(t, e)
          );
        },
        midpoint: function (t) {
          return (
            console.warn(
              "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
            ),
            this.getMidpoint(t)
          );
        },
        normal: function (t) {
          return (
            console.warn(
              "THREE.Triangle: .normal() has been renamed to .getNormal()."
            ),
            this.getNormal(t)
          );
        },
        plane: function (t) {
          return (
            console.warn(
              "THREE.Triangle: .plane() has been renamed to .getPlane()."
            ),
            this.getPlane(t)
          );
        },
      }),
      Object.assign(pr, {
        barycoordFromPoint: function (t, e, n, r, i) {
          return (
            console.warn(
              "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
            ),
            pr.getBarycoord(t, e, n, r, i)
          );
        },
        normal: function (t, e, n, r) {
          return (
            console.warn(
              "THREE.Triangle: .normal() has been renamed to .getNormal()."
            ),
            pr.getNormal(t, e, n, r)
          );
        },
      }),
      Object.assign(al.prototype, {
        extractAllPoints: function (t) {
          return (
            console.warn(
              "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
            ),
            this.extractPoints(t)
          );
        },
        extrude: function (t) {
          return (
            console.warn(
              "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
            ),
            new Cc(this, t)
          );
        },
        makeGeometry: function (t) {
          return (
            console.warn(
              "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
            ),
            new Hc(this, t)
          );
        },
      }),
      Object.assign(ke.prototype, {
        fromAttribute: function (t, e, n) {
          return (
            console.warn(
              "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, n)
          );
        },
        distanceToManhattan: function (t) {
          return (
            console.warn(
              "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
            ),
            this.manhattanDistanceTo(t)
          );
        },
        lengthManhattan: function () {
          return (
            console.warn(
              "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        },
      }),
      Object.assign(Ye.prototype, {
        setEulerFromRotationMatrix: function () {
          console.error(
            "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
          );
        },
        setEulerFromQuaternion: function () {
          console.error(
            "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
          );
        },
        getPositionFromMatrix: function (t) {
          return (
            console.warn(
              "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
            ),
            this.setFromMatrixPosition(t)
          );
        },
        getScaleFromMatrix: function (t) {
          return (
            console.warn(
              "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
            ),
            this.setFromMatrixScale(t)
          );
        },
        getColumnFromMatrix: function (t, e) {
          return (
            console.warn(
              "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
            ),
            this.setFromMatrixColumn(e, t)
          );
        },
        applyProjection: function (t) {
          return (
            console.warn(
              "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
            ),
            this.applyMatrix4(t)
          );
        },
        fromAttribute: function (t, e, n) {
          return (
            console.warn(
              "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, n)
          );
        },
        distanceToManhattan: function (t) {
          return (
            console.warn(
              "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
            ),
            this.manhattanDistanceTo(t)
          );
        },
        lengthManhattan: function () {
          return (
            console.warn(
              "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        },
      }),
      Object.assign(en.prototype, {
        fromAttribute: function (t, e, n) {
          return (
            console.warn(
              "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, n)
          );
        },
        lengthManhattan: function () {
          return (
            console.warn(
              "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        },
      }),
      Object.assign(di.prototype, {
        computeTangents: function () {
          console.error("THREE.Geometry: .computeTangents() has been removed.");
        },
        computeLineDistances: function () {
          console.error(
            "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
          );
        },
      }),
      Object.assign(Rn.prototype, {
        getChildByName: function (t) {
          return (
            console.warn(
              "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
            ),
            this.getObjectByName(t)
          );
        },
        renderDepth: function () {
          console.warn(
            "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
          );
        },
        translate: function (t, e) {
          return (
            console.warn(
              "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
            ),
            this.translateOnAxis(e, t)
          );
        },
        getWorldRotation: function () {
          console.error(
            "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
          );
        },
      }),
      Object.defineProperties(Rn.prototype, {
        eulerOrder: {
          get: function () {
            return (
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
              this.rotation.order
            );
          },
          set: function (t) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
              (this.rotation.order = t);
          },
        },
        useQuaternion: {
          get: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
          set: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
        },
      }),
      Object.defineProperties(ps.prototype, {
        objects: {
          get: function () {
            return (
              console.warn("THREE.LOD: .objects has been renamed to .levels."),
              this.levels
            );
          },
        },
      }),
      Object.defineProperty(vs.prototype, "useVertexTexture", {
        get: function () {
          console.warn("THREE.Skeleton: useVertexTexture has been removed.");
        },
        set: function () {
          console.warn("THREE.Skeleton: useVertexTexture has been removed.");
        },
      }),
      (fs.prototype.initBones = function () {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      }),
      Object.defineProperty(Uu.prototype, "__arcLengthDivisions", {
        get: function () {
          return (
            console.warn(
              "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
            ),
            this.arcLengthDivisions
          );
        },
        set: function (t) {
          console.warn(
            "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
          ),
            (this.arcLengthDivisions = t);
        },
      }),
      (_i.prototype.setLens = function (t, e) {
        console.warn(
          "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
        ),
          void 0 !== e && (this.filmGauge = e),
          this.setFocalLength(t);
      }),
      Object.defineProperties(sl.prototype, {
        onlyShadow: {
          set: function () {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          },
        },
        shadowCameraFov: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
            ),
              (this.shadow.camera.fov = t);
          },
        },
        shadowCameraLeft: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
            ),
              (this.shadow.camera.left = t);
          },
        },
        shadowCameraRight: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
            ),
              (this.shadow.camera.right = t);
          },
        },
        shadowCameraTop: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
            ),
              (this.shadow.camera.top = t);
          },
        },
        shadowCameraBottom: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
            ),
              (this.shadow.camera.bottom = t);
          },
        },
        shadowCameraNear: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
            ),
              (this.shadow.camera.near = t);
          },
        },
        shadowCameraFar: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
            ),
              (this.shadow.camera.far = t);
          },
        },
        shadowCameraVisible: {
          set: function () {
            console.warn(
              "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
            );
          },
        },
        shadowBias: {
          set: function (t) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
              (this.shadow.bias = t);
          },
        },
        shadowDarkness: {
          set: function () {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          },
        },
        shadowMapWidth: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
            ),
              (this.shadow.mapSize.width = t);
          },
        },
        shadowMapHeight: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
            ),
              (this.shadow.mapSize.height = t);
          },
        },
      }),
      Object.defineProperties(Sr.prototype, {
        length: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
              ),
              this.array.length
            );
          },
        },
      }),
      Object.assign(Sr.prototype, {
        copyIndicesArray: function () {
          console.error(
            "THREE.BufferAttribute: .copyIndicesArray() has been removed."
          );
        },
        setArray: function (t) {
          return (
            console.warn(
              "THREE.BufferAttribute: .setArray has been deprecated. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
            ),
            (this.count = void 0 !== t ? t.length / this.itemSize : 0),
            (this.array = t),
            this
          );
        },
      }),
      Object.assign(Hr.prototype, {
        addIndex: function (t) {
          console.warn(
            "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
          ),
            this.setIndex(t);
        },
        addDrawCall: function (t, e, n) {
          void 0 !== n &&
            console.warn(
              "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
            ),
            console.warn(
              "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
            ),
            this.addGroup(t, e);
        },
        clearDrawCalls: function () {
          console.warn(
            "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
          ),
            this.clearGroups();
        },
        computeTangents: function () {
          console.warn(
            "THREE.BufferGeometry: .computeTangents() has been removed."
          );
        },
        computeOffsets: function () {
          console.warn(
            "THREE.BufferGeometry: .computeOffsets() has been removed."
          );
        },
      }),
      Object.defineProperties(Hr.prototype, {
        drawcalls: {
          get: function () {
            return (
              console.error(
                "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
        offsets: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferGeometry: .offsets has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
      }),
      Object.assign(Xa.prototype, {
        setArray: function (t) {
          return (
            console.warn(
              "THREE.InterleavedBuffer: .setArray has been deprecated. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
            ),
            (this.count = void 0 !== t ? t.length / this.stride : 0),
            (this.array = t),
            this
          );
        },
      }),
      Object.assign(Oc.prototype, {
        getArrays: function () {
          console.error(
            "THREE.ExtrudeBufferGeometry: .getArrays() has been removed."
          );
        },
        addShapeList: function () {
          console.error(
            "THREE.ExtrudeBufferGeometry: .addShapeList() has been removed."
          );
        },
        addShape: function () {
          console.error(
            "THREE.ExtrudeBufferGeometry: .addShape() has been removed."
          );
        },
      }),
      Object.defineProperties(mh.prototype, {
        dynamic: {
          set: function () {
            console.warn(
              "THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
            );
          },
        },
        onUpdate: {
          value: function () {
            return (
              console.warn(
                "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
              ),
              this
            );
          },
        },
      }),
      Object.defineProperties(_r.prototype, {
        wrapAround: {
          get: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
        },
        overdraw: {
          get: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
        },
        wrapRGB: {
          get: function () {
            return (
              console.warn("THREE.Material: .wrapRGB has been removed."),
              new vr()
            );
          },
        },
        shading: {
          get: function () {
            console.error(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            );
          },
          set: function (t) {
            console.warn(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            ),
              (this.flatShading = 1 === t);
          },
        },
        stencilMask: {
          get: function () {
            return (
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              ),
              this.stencilFuncMask
            );
          },
          set: function (t) {
            console.warn(
              "THREE." +
                this.type +
                ": .stencilMask has been removed. Use .stencilFuncMask instead."
            ),
              (this.stencilFuncMask = t);
          },
        },
      }),
      Object.defineProperties(iu.prototype, {
        metal: {
          get: function () {
            return (
              console.warn(
                "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
              ),
              !1
            );
          },
          set: function () {
            console.warn(
              "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
            );
          },
        },
      }),
      Object.defineProperties(bi.prototype, {
        derivatives: {
          get: function () {
            return (
              console.warn(
                "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
              this.extensions.derivatives
            );
          },
          set: function (t) {
            console.warn(
              "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
            ),
              (this.extensions.derivatives = t);
          },
        },
      }),
      Object.assign(ka.prototype, {
        clearTarget: function (t, e, n, r) {
          console.warn(
            "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
          ),
            this.setRenderTarget(t),
            this.clear(e, n, r);
        },
        animate: function (t) {
          console.warn(
            "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
          ),
            this.setAnimationLoop(t);
        },
        getCurrentRenderTarget: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
            ),
            this.getRenderTarget()
          );
        },
        getMaxAnisotropy: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
            ),
            this.capabilities.getMaxAnisotropy()
          );
        },
        getPrecision: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
            ),
            this.capabilities.precision
          );
        },
        resetGLState: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
            ),
            this.state.reset()
          );
        },
        supportsFloatTextures: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
            ),
            this.extensions.get("OES_texture_float")
          );
        },
        supportsHalfFloatTextures: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
            ),
            this.extensions.get("OES_texture_half_float")
          );
        },
        supportsStandardDerivatives: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
            ),
            this.extensions.get("OES_standard_derivatives")
          );
        },
        supportsCompressedTextureS3TC: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
            ),
            this.extensions.get("WEBGL_compressed_texture_s3tc")
          );
        },
        supportsCompressedTexturePVRTC: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
            ),
            this.extensions.get("WEBGL_compressed_texture_pvrtc")
          );
        },
        supportsBlendMinMax: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
            ),
            this.extensions.get("EXT_blend_minmax")
          );
        },
        supportsVertexTextures: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
            ),
            this.capabilities.vertexTextures
          );
        },
        supportsInstancedArrays: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
            ),
            this.extensions.get("ANGLE_instanced_arrays")
          );
        },
        enableScissorTest: function (t) {
          console.warn(
            "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
          ),
            this.setScissorTest(t);
        },
        initMaterial: function () {
          console.warn(
            "THREE.WebGLRenderer: .initMaterial() has been removed."
          );
        },
        addPrePlugin: function () {
          console.warn(
            "THREE.WebGLRenderer: .addPrePlugin() has been removed."
          );
        },
        addPostPlugin: function () {
          console.warn(
            "THREE.WebGLRenderer: .addPostPlugin() has been removed."
          );
        },
        updateShadowMap: function () {
          console.warn(
            "THREE.WebGLRenderer: .updateShadowMap() has been removed."
          );
        },
        setFaceCulling: function () {
          console.warn(
            "THREE.WebGLRenderer: .setFaceCulling() has been removed."
          );
        },
        allocTextureUnit: function () {
          console.warn(
            "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
          );
        },
        setTexture: function () {
          console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
        },
        setTexture2D: function () {
          console.warn(
            "THREE.WebGLRenderer: .setTexture2D() has been removed."
          );
        },
        setTextureCube: function () {
          console.warn(
            "THREE.WebGLRenderer: .setTextureCube() has been removed."
          );
        },
        getActiveMipMapLevel: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
            ),
            this.getActiveMipmapLevel()
          );
        },
      }),
      Object.defineProperties(ka.prototype, {
        shadowMapEnabled: {
          get: function () {
            return this.shadowMap.enabled;
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
            ),
              (this.shadowMap.enabled = t);
          },
        },
        shadowMapType: {
          get: function () {
            return this.shadowMap.type;
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
            ),
              (this.shadowMap.type = t);
          },
        },
        shadowMapCullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        context: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
              ),
              this.getContext()
            );
          },
        },
      }),
      Object.defineProperties(Ra.prototype, {
        cullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderReverseSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderSingleSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
      }),
      Object.defineProperties(Ti.prototype, {
        activeCubeFace: {
          set: function () {
            console.warn(
              "THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget()."
            );
          },
        },
        activeMipMapLevel: {
          set: function () {
            console.warn(
              "THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget()."
            );
          },
        },
      }),
      Object.defineProperties(nn.prototype, {
        wrapS: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
              this.texture.wrapS
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
            ),
              (this.texture.wrapS = t);
          },
        },
        wrapT: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
              this.texture.wrapT
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
            ),
              (this.texture.wrapT = t);
          },
        },
        magFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
              this.texture.magFilter
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
            ),
              (this.texture.magFilter = t);
          },
        },
        minFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
              this.texture.minFilter
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
            ),
              (this.texture.minFilter = t);
          },
        },
        anisotropy: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
              this.texture.anisotropy
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
            ),
              (this.texture.anisotropy = t);
          },
        },
        offset: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
              this.texture.offset
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .offset is now .texture.offset."
            ),
              (this.texture.offset = t);
          },
        },
        repeat: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
              this.texture.repeat
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
            ),
              (this.texture.repeat = t);
          },
        },
        format: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
              this.texture.format
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .format is now .texture.format."
            ),
              (this.texture.format = t);
          },
        },
        type: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
              this.texture.type
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .type is now .texture.type."
            ),
              (this.texture.type = t);
          },
        },
        generateMipmaps: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
              this.texture.generateMipmaps
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
            ),
              (this.texture.generateMipmaps = t);
          },
        },
      }),
      Object.defineProperties(Va.prototype, {
        standing: {
          set: function () {
            console.warn("THREE.WebVRManager: .standing has been removed.");
          },
        },
        userHeight: {
          set: function () {
            console.warn("THREE.WebVRManager: .userHeight has been removed.");
          },
        },
      }),
      (Jl.prototype.load = function (t) {
        console.warn(
          "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
        );
        var e = this;
        return (
          new zl().load(t, function (t) {
            e.setBuffer(t);
          }),
          this
        );
      }),
      (eh.prototype.getData = function () {
        return (
          console.warn(
            "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
          ),
          this.getFrequencyData()
        );
      }),
      (Ei.prototype.updateCubeMap = function (t, e) {
        return (
          console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
          this.update(t, e)
        );
      });
    (Ke.crossOrigin = void 0),
      (Ke.loadTexture = function (t, e, n, r) {
        console.warn(
          "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
        );
        var i = new Fu();
        i.setCrossOrigin(this.crossOrigin);
        var o = i.load(t, n, void 0, r);
        return e && (o.mapping = e), o;
      }),
      (Ke.loadTextureCube = function (t, e, n, r) {
        console.warn(
          "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
        );
        var i = new zu();
        i.setCrossOrigin(this.crossOrigin);
        var o = i.load(t, n, void 0, r);
        return e && (o.mapping = e), o;
      }),
      (Ke.loadCompressedTexture = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
        );
      }),
      (Ke.loadCompressedTextureCube = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
        );
      });
    function dp(t, e, n, r, i) {
      return r + ((i - r) * (t - e)) / (n - e);
    }
    function mp(t, e, n) {
      (this.x = t), (this.y = e), (this.z = n);
    }
    "undefined" != typeof __THREE_DEVTOOLS__ &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("register", { detail: { revision: "109" } })
      ),
      (mp.prototype.dot2 = function (t, e) {
        return this.x * t + this.y * e;
      }),
      (mp.prototype.dot3 = function (t, e, n) {
        return this.x * t + this.y * e + this.z * n;
      });
    var vp = [
        new mp(1, 1, 0),
        new mp(-1, 1, 0),
        new mp(1, -1, 0),
        new mp(-1, -1, 0),
        new mp(1, 0, 1),
        new mp(-1, 0, 1),
        new mp(1, 0, -1),
        new mp(-1, 0, -1),
        new mp(0, 1, 1),
        new mp(0, -1, 1),
        new mp(0, 1, -1),
        new mp(0, -1, -1),
      ],
      gp = [
        151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225,
        140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247,
        120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57,
        177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74,
        165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122,
        60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54,
        65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169,
        200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3,
        64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85,
        212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170,
        213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43,
        172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185,
        112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191,
        179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31,
        181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150,
        254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195,
        78, 66, 215, 61, 156, 180,
      ],
      yp = new Array(512),
      xp = new Array(512);
    function bp(t) {
      return t * t * t * (t * (6 * t - 15) + 10);
    }
    function wp(t, e, n) {
      return (1 - n) * t + n * e;
    }
    function _p(t, e, n) {
      var r = Math.floor(t),
        i = Math.floor(e),
        o = Math.floor(n);
      (t -= r), (e -= i), (n -= o);
      var a = xp[(r &= 255) + yp[(i &= 255) + yp[(o &= 255)]]].dot3(t, e, n),
        s = xp[r + yp[i + yp[o + 1]]].dot3(t, e, n - 1),
        c = xp[r + yp[i + 1 + yp[o]]].dot3(t, e - 1, n),
        u = xp[r + yp[i + 1 + yp[o + 1]]].dot3(t, e - 1, n - 1),
        l = xp[r + 1 + yp[i + yp[o]]].dot3(t - 1, e, n),
        h = xp[r + 1 + yp[i + yp[o + 1]]].dot3(t - 1, e, n - 1),
        p = xp[r + 1 + yp[i + 1 + yp[o]]].dot3(t - 1, e - 1, n),
        f = xp[r + 1 + yp[i + 1 + yp[o + 1]]].dot3(t - 1, e - 1, n - 1),
        d = bp(t),
        m = bp(e),
        v = bp(n);
      return wp(
        wp(wp(a, l, d), wp(s, h, d), v),
        wp(wp(c, p, d), wp(u, f, d), v),
        m
      );
    }
    function Mp(t) {
      return (
        (function (t) {
          if (Array.isArray(t)) {
            for (var e = 0, n = new Array(t.length); e < t.length; e++)
              n[e] = t[e];
            return n;
          }
        })(t) ||
        Ep(t) ||
        (function () {
          throw new TypeError(
            "Invalid attempt to spread non-iterable instance"
          );
        })()
      );
    }
    function Sp(t) {
      return (
        (function (t) {
          if (Array.isArray(t)) return t;
        })(t) ||
        Ep(t) ||
        (function () {
          throw new TypeError(
            "Invalid attempt to destructure non-iterable instance"
          );
        })()
      );
    }
    function Ep(t) {
      if (
        Symbol.iterator in Object(t) ||
        "[object Arguments]" === Object.prototype.toString.call(t)
      )
        return Array.from(t);
    }
    function Tp(t, e, n, r, i, o, a) {
      try {
        var s = t[o](a),
          c = s.value;
      } catch (t) {
        return void n(t);
      }
      s.done ? e(c) : Promise.resolve(c).then(r, i);
    }
    !(function (t) {
      t > 0 && t < 1 && (t *= 65536),
        (t = Math.floor(t)) < 256 && (t |= t << 8);
      for (var e = 0; e < 256; e++) {
        var n;
        (n = 1 & e ? gp[e] ^ (255 & t) : gp[e] ^ ((t >> 8) & 255)),
          (yp[e] = yp[e + 256] = n),
          (xp[e] = xp[e + 256] = vp[n % 12]);
      }
    })(0);
    var Ap = 64,
      Lp = 64,
      Pp = document.createElement("canvas").getContext("2d");
    (Pp.canvas.width = Ap), (Pp.canvas.height = Lp);
    var Rp = new tn(Pp.canvas),
      Cp = new Fu(),
      Op = new Cn(),
      Ip = new ka({ alpha: !0 });
    Ip.setClearColor(0, 0), (Ip.shadowMap.enabled = !0);
    var Np = new gl(16777215, 1);
    Op.add(Np);
    var Dp = new si(void 0, new Mr({ map: Rp }));
    Op.add(Dp);
    var zp = new si();
    function Fp(t) {
      return new Promise(function (e) {
        return Cp.load(t, e);
      });
    }
    function Up(t) {
      return Promise.all(t.map(Fp));
    }
    (zp.position.z = 20), Op.add(zp);
    var Bp = function (t, e) {
      return Gp.apply(this, arguments);
    };
    function Gp() {
      var t;
      return (
        (t = regeneratorRuntime.mark(function t(e, n) {
          var r, i, o, a, s, u, h, p, f, d, g, y, x, b, w, _;
          return regeneratorRuntime.wrap(function (t) {
            for (;;)
              switch ((t.prev = t.next)) {
                case 0:
                  return (
                    (r = !1),
                    (i = l()),
                    (o = i.width),
                    (a = i.height),
                    (s = i.scale),
                    (u = n.map(function () {
                      return { opacity: 0, prevOpacity: 0 };
                    })),
                    Ip.setPixelRatio(s),
                    (h = new dl(
                      o / -2,
                      o / 2,
                      a / 2,
                      a / -2,
                      1,
                      1e3
                    )).position.set(0, 0, 10),
                    h.lookAt(Op.position),
                    (t.next = 9),
                    Up([window.assets.title, window.assets.noise].concat(Mp(n)))
                  );
                case 9:
                  return (
                    (p = t.sent),
                    (f = Sp(p)),
                    (d = f[0]),
                    (g = f[1]),
                    (y = f.slice(2)),
                    (x = function (t) {
                      var e = t.width,
                        n = t.height,
                        r = e < 768,
                        i = d.image,
                        o = e * (r ? 0.8 : 0.4),
                        a = o * (i.height / i.width);
                      (zp.position.y = r ? n / 2 - a - 60 : 0),
                        zp.geometry.dispose(),
                        (zp.geometry = new ji(
                          o,
                          a,
                          Math.round(o / 10),
                          Math.round(a / 10)
                        )),
                        zp.material.dispose(),
                        (zp.material = new iu({
                          alphaTest: 0.5,
                          transparent: !0,
                          map: d,
                          displacementScale: -8,
                          displacementMap: g,
                        }));
                    }),
                    (b = y.map(function (t, e) {
                      return (
                        (u[e].plane = new si()),
                        (u[e].plane.position.z = 20),
                        Op.add(u[e].plane),
                        function (n) {
                          var r = n.width,
                            i = n.height,
                            o = t.image;
                          if (o.height / o.width < i / r) {
                            var a = (r * o.height) / (i * o.width);
                            t.repeat.set(a, 1), (t.offset.x = (1 - a) / 2);
                          } else {
                            var s = (i * o.width) / (r * o.height);
                            t.repeat.set(1, s), (t.offset.y = (1 - s) / 2);
                          }
                          u[e].plane.geometry.dispose(),
                            (u[e].plane.geometry = new ji(
                              r,
                              i,
                              Math.round(r * (window.assets.vectors || 0.33)),
                              Math.round(i * (window.assets.vectors || 0.33))
                            )),
                            u[e].plane.material.dispose(),
                            (u[e].plane.material = new iu({
                              map: t,
                              displacementMap: t,
                              displacementScale: -10,
                              transparent: !0,
                            }));
                        }
                      );
                    })),
                    c(function () {
                      var t = l(),
                        n = t.width,
                        i = t.height;
                      return (
                        Ip.setSize(n, i),
                        (h.left = n / -2),
                        (h.right = n / 2),
                        (h.top = i / 2),
                        (h.bottom = i / -2),
                        h.updateProjectionMatrix(),
                        Dp.geometry.dispose(),
                        (Dp.geometry = new ji(n, i)),
                        x({ width: n, height: i }),
                        b.map(function (t) {
                          return t({ width: n, height: i });
                        }),
                        m(function (t) {
                          var n = Math.sin(0.02 * t),
                            i = Math.sin(0.02 * t + 1);
                          Np.intensity = dp(n, -1, 1, 0.9, 1.1);
                          for (var o = 0; o < Ap; o += 1)
                            for (var a = 0; a < Lp; a += 1) {
                              var s = _p(o / Ap, a / Lp, 0.008 * t),
                                c = Math.min(255, dp(s, -1, 1, 120, 400));
                              (Pp.fillStyle = "rgb("
                                .concat(c, ", ")
                                .concat(c, ", ")
                                .concat(c, ")")),
                                Pp.fillRect(o, a, 1, 1);
                            }
                          Rp.needsUpdate = !0;
                          var l = e.getBoundingClientRect().y < -20;
                          zp.position.z = v(
                            zp.position.z,
                            r || l ? 20 : 8,
                            0.02
                          );
                          for (var p = 0; p < u.length; p += 1)
                            (u[p].opacity > 0 || u[p].prevOpacity > 0.01) &&
                              ((u[p].prevOpacity = v(
                                u[p].prevOpacity,
                                u[p].opacity,
                                u[p].opacity ? 0.02 : 0.01
                              )),
                              u[p].plane.rotation.set(
                                v(
                                  0,
                                  dp(n, -1, 1, -0.002, 0.002),
                                  u[p].prevOpacity
                                ),
                                v(
                                  0,
                                  dp(i, -1, 1, -0.002, 0.002),
                                  u[p].prevOpacity
                                ),
                                0
                              ),
                              (u[p].plane.position.z = v(
                                20,
                                10,
                                u[p].prevOpacity
                              )));
                          Ip.render(Op, h);
                        })
                      );
                    }),
                    (w = function (t) {
                      u[t] && ((r = !0), (u[t].opacity = 1));
                    }),
                    (_ = function (t) {
                      u[t] && ((r = !1), (u[t].opacity = 0));
                    }),
                    t.abrupt("return", {
                      show: w,
                      hide: _,
                      element: Ip.domElement,
                    })
                  );
                case 20:
                case "end":
                  return t.stop();
              }
          }, t);
        })),
        (Gp = function () {
          var e = this,
            n = arguments;
          return new Promise(function (r, i) {
            var o = t.apply(e, n);
            function a(t) {
              Tp(o, r, i, a, s, "next", t);
            }
            function s(t) {
              Tp(o, r, i, a, s, "throw", t);
            }
            a(void 0);
          });
        }).apply(this, arguments)
      );
    }
    function jp(t, e, n, r, i, o, a) {
      try {
        var s = t[o](a),
          c = s.value;
      } catch (t) {
        return void n(t);
      }
      s.done ? e(c) : Promise.resolve(c).then(r, i);
    }
    !(function (t) {
      y.apply(this, arguments);
    })(document.querySelector(".mouse"));
    for (
      var Vp,
        Hp = [],
        kp = document.getElementById("mirror"),
        Wp = kp.parentNode,
        qp = document.querySelectorAll(".item[data-cover]"),
        Xp = Array.prototype.slice.call(qp).filter(function (t) {
          return !t.classList.contains("hidden");
        }),
        Yp = l().width,
        Jp = 0;
      Jp < qp.length;
      Jp += 1
    )
      Hp.push((Yp < 768 && qp[Jp].dataset.coverM) || qp[Jp].dataset.cover);
    ((Vp = regeneratorRuntime.mark(function t() {
      var e, n, r, i;
      return regeneratorRuntime.wrap(function (t) {
        for (;;)
          switch ((t.prev = t.next)) {
            case 0:
              return (t.next = 2), Bp(kp, Hp);
            case 2:
              (e = t.sent),
                (n = e.show),
                (r = e.hide),
                (i = e.element),
                Wp.insertBefore(i, kp),
                Wp.classList.add("loaded"),
                c(function () {
                  var t = l();
                  i.style.marginBottom = "-".concat(i.style.height);
                  var e = t.height / 3;
                  if (t.width < 768) {
                    var o = function () {
                      for (var t = 0; t < Xp.length; t += 1) {
                        var i = qp[t].getBoundingClientRect(),
                          o = i.top,
                          a = i.height;
                        o <= e && o + a >= e
                          ? qp[t].classList.contains("hover") ||
                            (n(t),
                            qp[t].classList.add("hover"),
                            document.body.classList.add("cover"))
                          : qp[t].classList.contains("hover") &&
                            (r(t),
                            qp[t].classList.remove("hover"),
                            document.body.classList.remove("cover"));
                      }
                    };
                    return (
                      window.addEventListener("scroll", o),
                      function () {
                        window.removeEventListener("scroll", o);
                      }
                    );
                  }
                  for (
                    var a = function (t) {
                        (qp[t].mouseenter = function () {
                          n(t), document.body.classList.add("cover");
                        }),
                          (qp[t].mouseleave = function () {
                            r(t), document.body.classList.remove("cover");
                          }),
                          qp[t].addEventListener(
                            "mouseenter",
                            qp[t].mouseenter
                          ),
                          qp[t].addEventListener(
                            "mouseleave",
                            qp[t].mouseleave
                          );
                      },
                      s = 0;
                    s < qp.length;
                    s += 1
                  )
                    a(s);
                  return function () {
                    for (var t = 0; t < qp.length; t += 1)
                      qp[t].removeEventListener("mouseenter", qp[t].mouseenter),
                        qp[t].removeEventListener(
                          "mouseleave",
                          qp[t].mouseleave
                        );
                  };
                });
            case 9:
            case "end":
              return t.stop();
          }
      }, t);
    })),
    function () {
      var t = this,
        e = arguments;
      return new Promise(function (n, r) {
        var i = Vp.apply(t, e);
        function o(t) {
          jp(i, n, r, o, a, "next", t);
        }
        function a(t) {
          jp(i, n, r, o, a, "throw", t);
        }
        o(void 0);
      });
    })();
  },
]);
